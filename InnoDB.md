# 内存结构

Buffer Pool
Change Buffer
Adaptive Hash Index
Log Buffer (主要是 Redo Log Buffer)

## 页结构

File Header (38 byte)
Page Header (56 byte)
Infimun Record + Suprenum Record (26 byte)
User Records (大小不定, 根据数据量伸缩)
Free Space (大小不定, 根据数据量伸缩)
Page Directory (大小不定, 根据数据量伸缩)
File Tailer (8 byte)

默认情况下, 一页总共 16 k


通过 FileHeader 中的上一下和下一页的数据，页与页之间可以形成双向链表

行与行之间则形成了单向链表。我们存入的行数据最终会到 User Records 中

User Records 中的数据，是按照主键 id 来进行排序的，当我们按照主键来进行查找时，会沿着这个单向链表一直往后找


## Insert Buffer 

插入缓冲，也称之为 Insert Buffer。经常会理解插入缓冲时缓冲池的一个部分，这样的理解是片面的，Insert Buffer 的信息一部分在内存中，另外一部分像数据页一样，存在于物理页中。

主键是行唯一的标识符，在应用程序中行记录的插入顺序是按照主键递增的顺序进行插入的。因此，插入聚集索引一般是顺序的，不需要磁盘的随机读取。

id 列是自增长的，这意味着当执行插入操作时，id 列会自动增长，页中的行记录按 id 执行顺序存放。一般情况下，不需要随机读取另一页执行记录的存放。因此，在这样的情况下，插入操作一般很快就能完成。

但是每张表上不可能只有一个聚集索引，在更多的情况下，一张表上有多个非聚集的辅助索引(二级索引)。   
大部分情况下, 一张表中存在一个以上的非聚集的并且不是唯一的索引, 在进行插入操作时，数据页的存放还是按主键 id 的执行顺序存放，但是对于非聚集索引，叶子节点的插入不再是顺序的了。  
这时就需要离散地访问非聚集索引页，插入性能在这里变低了, 因为 B+ 树的特性决定了非聚集索引插入的离散性。

InnoDB 存储引擎开创性地设计了插入缓冲, 对于非聚集索引的插入或更新操作，不是每一次直接插入索引页中，而是先判断插入的非聚集索引页是否在缓冲池中。
    如果在，则直接插入, 
    如果不在，则先放入一个插入缓冲区中, 然后再以一定的频率执行插入缓冲和非聚集索引页子节点的合并操作，这时通常能将多个插入合并到一个操作中（因为在一个索引页中），这就大大提高了对非聚集索引执行插入和修改操作的性能    


插入缓冲的使用需要满足以下两个条件：
> 1. 索引是辅助索引
> 2. 索引不是唯一的

当满足以上两个条件时，InnoDB存储引擎会使用插入缓冲，这样就能提高性能了。

有一种可能性:   
应用程序执行大量的插入和更新操作，这些操作都涉及了不唯一的非聚集索引，如果在这个过程中数据库发生了宕机，这时候会有大量的插入缓冲并没有合并到实际的非聚集索引中。  
如果是这样，恢复可能需要很长的时间，极端情况下甚至需要几个小时来执行合并恢复操作。

辅助索引不能是唯一的，因为在把它插入到插入缓冲时， 我们并不去查找索引页的情况。如果是唯一性的, 需要校验唯一性，就会出现离散读的情况，插入缓冲就失去了意义。

## Changer Buffer

最新的 MySQL5.7 已经支持 change buffer, 可以理解为 insert buffer 的升级, 也就是对常见的DML语言都可以进行缓冲，包含 insert delete 以及 update，对应的分别是 insert buffer，delete buffer 以及 purge buffer。

change buffer 的使用对象仍然是非唯一的辅助索引。


Update Demo

第一个部分是将记录的 delete_mask 标记为删除, delete buffer 对应的是update的第一个过程
第二个部分是真正的将记录删除, purge buffer对应的是第二个部分


insert buffer 的数据结构是一棵 B+ 树, 全局只有一棵 insert buffer B+ 树, 它负责对所有的表进行 insert buffer，而这棵 B+ 树放在共享表空间中。  
非叶子节点存放的是查询的search key值，它的构造如下：  space - mark - offst - metadata

这个结构一共占用 9 个字节，其中，space 表示待插入的记录所在的表的表空间 id，这个 id 是每个表都要有的唯一的 id, 其中 space 占用 4 个字节，marker 占用 1 个字节，  
用来兼容老版本的 insert buffer，offset 占用 4 个字节，表示页所在的偏移量。
metadata 占用 4 个字节，它用来排序每个记录进入 insert buffer 的顺序。

过程:  

当一个辅助索引要插入到数据页的时候，如果这个数据页不在缓冲池中，那么innodb会根据规则构造一个search key，接下来将这个记录插入到insert buffer的B+树里面去

为了保证每次merge insert buffer成功，需要设置一个特殊的数据页来标记每个辅助索引页的可用空间，这个数据页的类型为insert buffer bitmap，这个页可以追踪很多辅助索引页的可用空间


Merged Insert Buffer 的时机 ？

辅助索引页被读取到缓冲池的时候
insert buffer Bitmap 追踪到该辅助索引页已经没有足够的可用空间时，一般的阈值是辅助索引页空间的 1/32
master thread 每秒执行一次 merge insert buffer 的操作


## 两次写

插入缓冲带给 InnoDB 存储引擎的是性能，那么两次写带给 InnoDB 存储引擎的是数据的可靠性。

当数据库宕机时，可能发生数据库正在写一个页面，而这个页只写了一部分（比如16K的页，只写前4K的页）的情况，我们称之为部分写失效（partial page write）。


Redo log 中记录的是对页的物理操作, 物理页操作。  
如果这个页本身已经损坏，再对其进行重做是没有意义的。  

在应用（apply）Redo log 前，我们需要一个页的副本，当写入失效发生时，先通过页的副本来还原该页，再进行重做，这就是 doublewrite.

doublewrite 由两部分组成：
一部分是内存中的 doublewrite buffer，大小为 2MB
另一部分是物理磁盘上共享表空间中连续的 128 个页，即两个区（extent），大小同样为 2MB (页的副本) 

当缓冲池的脏页刷新时，并不直接写磁盘，而是会通过 memcpy 函数将脏页先拷贝到内存中的 doublewrite buffer, 
之后通过 doublewrite buffer 再分两次，每次写入 1MB 到共享表空间的物理磁盘上, 然后马上调用 fsync 函数，同步磁盘，避免缓冲写带来的问题。
因为 doublewrite 页是连续的，因此这个过程是顺序写的，开销并不是很大。
在完成 doublewrite 页的写入后，再将 doublewrite buffer 中的页写入各个表空间文件中，此时的写入则是离散的

## 自适应哈希索引

InnoDB 存储引擎会监控对表上索引的查找，如果观察到建立哈希索引可以带来速度的提升，则建立哈希索引，所以称之为自适应（adaptive）的。  
自适应哈希索引通过缓冲池的 B+ 树构造而来，因此建立的速度很快。而且不需要将整个表都建哈希索引，InnoDB 存储引擎会自动根据访问的频率和模式来为某些页建立哈希索引。


## MySQL 的日志文件

错误日志
慢查询日志
查询日志


### bin log

MySQL Server 层记录的日志。

记录了对数据库执行**更改**的所有操作, 还包括了执行数据库更改操作的时间和执行时间等附加信息。

#### 主要的作用
> 1. 恢复: 某些数据的恢复需要二进制日志，如当一个数据库全备文件恢复后，我们可以通过二进制日志进行 point-in-time 的恢复, 具体的做法, 可以看一下这篇[文章](https://blog.csdn.net/qingsong3333/article/details/76945192)
> 2. 复制：通过复制和执行二进制日志使得一台远程的 MySQL 数据库 (一般称为 slave, standby, 从数据库) 与一台 MySQL 数据库 (一般称为 master, primary, 主数据库) 进行实时同步


####  开发 bin log 功能

```config

# 开启 bin log 
log_bin=ON

# bin log 文件的目录和文件名, 在实际中还会在后面追加多一个索引后缀, 没有配置, 默认为 bin_log, 所在路径为数据库所在目录 (datadir)
log_bin_basename=/var/lib/mysql/mysql-bin

# bin log 文件的索引文件的目录和文件名，这个文件管理了所有的 bin log 文件的目录, 不建议修改
log_bin_index=/var/lib/mysql/mysql-bin.index

# 5.7 及后面的版本, 需要指定一个不能和其他集群中机器重名的字符串
server-id=123454
```

二进制日志文件在默认情况下并没有启动，需要你手动指定参数来启动。   
开启这个选项是会对数据库整体性能有所影响, 但是性能的损失十分有限。根据 MySQL 官方手册中的测试表明，开启二进制日志会使得性能下降 1%。  
但考虑到可以使用复制 (replication) 和 point-in-time 的恢复，这些性能损失绝对是可以并且是应该被接受的。

####  bin log 文件相关的一些配置

**max_binlog_size**: 指定了单个二进制日志文件的最大值，如果超过该值，则产生新的二进制日志文件，后缀名 +1，并记录到 .index 文件。

**binlog_cache_size**: 当使用事务的表存储引擎时, 所有未提交（uncommitted）的二进制日志会被记录到一个缓存中，等该事务提交时（committed）时直接将缓冲中的二进制日志写入二进制日志文件，而该缓冲的大小由 binlog_cache_size 决定，默认大小为 32KB, binlog_cache_size 是基于会话（session）的，也就是说，当一个线程开始一个事务时，MySQL 会自动分配一个大小为 binlog_cache_size 的缓存, 不能太大也不能太小。

**sync_binlog**: 默认情况下，二进制日志并不是在每次写的时候同步到磁盘, 因此，当数据库所在操作系统发生宕机时，可能会有最后一部分数据没有写入二进制日志文件中。这会给恢复和复制带来问题。这个参数后面的配置是一个数字, 表示每写多少次缓存就同步到磁盘。设为 1，即 sync_binlog=1 表示采用同步写磁盘的方式来写二进制日志，这时写操作不使用操作系统的缓冲来写二进制日志。

即使将 sync_binlog 设为 1，还是会有一种情况会导致问题的发生。当使用 InnoDB 存储引擎时，在一个事务发出COMMIT 动作之前，由于 sync_binlog 设为 1，因此会将二进制日志立即写入磁盘。如果这时已经写入了二进制日志，但是提交还没有发生，并且此时发生了宕机，那么在 MySQL 数据库下次启动时，因为 COMMIT 操作并没有发生，所以这个事务会被回滚掉。但是二进制日志已经记录了该事务信息，不能被回滚。可以通过将参数 innodb_support_xa 设为 1 来解决。

**binlog_do_db**和**binlog_ignore_db**: 表示需要写入或者忽略写入哪些库的日志。默认为空，表示需要将所有库的日志同步到二进制日志。

**binlog_format**:  记录二进制日志的格式

> 1. STATEMENT: 二进制日志文件记录的是日志的逻辑 SQL 语句, 对于复制是有一定要求的, 如 rand, uuid 等函数，或者有使用触发器等可能会导致主从服务器上表的数据不一致
> 2. ROW:  二进制日志记录的不再是简单的 SQL 语句了，而是记录表的行更改情况。MySQL 5.1 版本开始，如果设置了 binlog_format 为 ROW，可以将 InnoDB 的事务隔离基本设为 READ COMMITTED，以获得更好的并发性。
> 3. MIXED:  MySQL 默认采用 STATEMENT 格式进行二进制日志文件的记录，但是在一些情况下会使用 ROW 格式。

在 MIXED 中使用 ROW 记录日志的情况有
> 1. 表的存储引擎为 NDB，这时对于表的 DML 操作都会以 ROW 格式记录
> 2. 使用了 UUID(), USER(), CURRENT_USER(), FOUND_ROWS(), ROW_COUNT() 等不确定函数
> 3. 使用了 INSERT DELAY 语句
> 4. 使用了用户定义函数 (UDF)
> 5. 使用了临时表 (temporary table)

binlog_format 并不是所有的存储引擎都支持。

将参数 binlog_format 设置为 ROW，这可以为数据库的恢复和复制带来更好的可靠性。但是不能忽略一点的是，这会带来二进制文件大小的增加，有些语句下的 ROW 格式可能需要更大的容量。

通过 MySQL 提供的工具 mysqlbinlog 进行日志文件的查看。


### redo log

InnoDB 存储引擎层的日志。

默认情况下会有两个文件，名称分别为 ib_logfile0 和 ib_logfile1。MySQL 官方手册中将其称为 InnoDB 存储引擎的日志文件，不过更准确的定义应该是重做日志文件 (redo log file)。
它们记录了对于 InnoDB 存储引擎的事务日志。

重做日志文件的主要目的是，万一实例或者介质失败（media failure），重做日志文件就能派上用场。  
如数据库由于所在主机掉电导致实例失败，InnoDB 存储引擎会使用重做日志恢复到掉电前的时刻，以此来保证数据的完整性。

每个 InnoDB 存储引擎至少有 1 个重做日志文件组（group），每个文件组下至少有 2 个重做日志文件，如默认的 ib_logfile0、ib_logfile1。

为了得到更高的可靠性，你可以设置多个镜像日志组（mirrored log groups），将不同的文件组放在不同的磁盘上。

日志组中每个重做日志文件的大小一致，并以循环方式使用。InnoDB 存储引擎先写重做日志文件 1，当达到文件的最后时，会切换至重做日志文件 2，当重做日志文件 2 也被写满时，会再切换到重做日志文件 1 中。

#### redo log 相关的配置

**innodb_log_file_size**: 重做日志文件的大小

**innodb_log_files_in_group**: 日志文件组中重做日志文件的数量，默认为2

**innodb_mirrored_log_groups**: 日志镜像文件组的数量，默认为1，代表只有一个日志文件组，没有镜像

**innodb_log_group_home_dir**: 日志文件组所在路径，默认在数据库路径下


重做日志文件的大小设置对于 MySQL 数据库各方面还是有影响的。一方面不能设置得太大，如果设置得很大，在恢复时可能需要很长的时间；另一方面又不能太小了，否则可能导致一个事务的日志需要多次切换重做日志文件

InnoDB 存储引擎的重做日志文件记录的关于每个页（Page）的更改的物理情况

对于写入重做日志文件的操作不是直接写，而是先写入一个重做日志缓冲（redo log buffer）中，然后根据按照一定的条件写入日志文件

在主线程中每秒会将重做日志缓冲写入磁盘的重做日志文件中，不论事务是否已经提交

**innodb_flush_log_at_trx_commit**
> 1. 0 代表当提交事务时，并不将事务的重做日志写入磁盘上的日志文件，而是等待主线程每秒的刷新
> 2. 1 是在 commit 时将重做日志缓冲同步写到磁盘，默认配置。
> 3. 2 是重做日志异步写到磁盘，即不能完全保证 commit 时肯定会写入重做日志文件，只是有这个动作 (不会调用系统的 flush 操作, 将操作系统的缓存写入到磁盘)


### undo log

InnoDB 存储引擎层的日志。

对于数据库进行修改时，数据库不但会产生 redo，而且还会产生一定量的 undo。即使你执行的事务或语句由于某种原因失败了，或者如果你用一条 ROLLBACK 语句请求回滚，就可以利用这些 undo 信息将数据回滚到修改之前的样子。   
与 redo 不同的是，redo 存放在重做日志文件中，undo 存放在数据库内部的一个特殊段 (segment) 中，这称为 undo 段 (undo segment), undo 段位于共享表空间内。

通常对于 undo 有这样的误解：undo 用于将数据库物理地恢复到执行语句或事务之前样子——但事实并非如此。数据库只是逻辑地恢复到原来的样子，所有修改都被逻辑地取消，但是数据结构本身在回滚之后可能大不相同。

数据库的主要任务就是协调对于数据记录的并发访问。如一个事务在修改当前一个页中某几条记录，但同时还有别的事务在对同一个页中另几条记录进行修改。 因此，不能将一个页回滚到事务开始的样子，因为这样会影响其他事务正在进行的工作。

因此，当 InnoDB 存储引擎回滚时，它实际上做的是与先前相反的工作。对于每个 INSERT，InnoDB 存储引擎会完成一个 DELETE; 对于每个 DELETE，InnoDB 存储引擎会执行一个 INSERT; 对于每个 UPDATE，InnoDB 存储引擎则会执行一个相反的 UPDATE，  
将修改前的行放回去

分配一个新的段，即表空间会增大。如果我们执行 ROLLBACK 时，会将插入的事务进行回滚，但是表空间的大小并不会因此而收缩。


## bin log, redo log, undo log

redo log 通常是物理日志，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样怎样，它用来恢复提交后的物理数据页(恢复数据页，且只能恢复到最后一次提交的位置)

undo 用来回滚行记录到某个版本。undo log 一般是逻辑日志，根据每行记录进行记录

bin log 二进制日志, 在存储引擎的上层产生的。 redo log是innodb层产生的，只记录该存储引擎中表的修改。

并且二进制日志先于redo log被记录

bin log 操作的方法是逻辑性的语句, redo log 是在物理格式上的日志，它记录的是数据库中每个页的修改。

二进制日志只在每次事务提交的时候一次性写入缓存中的日志"文件"(对于非事务表的操作，则是每次执行语句成功后就直接写入)

redo log 在数据准备修改前写入缓存中的redo log中，然后才对缓存中的数据执行修改操作；而且保证在发出事务提交指令时，先向缓存中的redo log写入日志，写入完成后才执行提交动作

因为 bin log 只在提交的时候一次性写入，所以二进制日志中的记录方式和提交顺序有关，且一次提交对应一次记录

redo log中是记录的物理页的修改，redo log文件中同一个事务可能多次记录，最后一个提交的事务记录会覆盖所有未提交的事务记录
redo log是并发写入的，不同事务之间的不同版本的记录会穿插写入到redo log文件中

事务日志记录的是物理页的情况，它具有幂等性，因此记录日志的方式极其简练, 例如新插入一行后又删除该行，前后状态没有变化
二进制日志记录的是所有影响数据的操作，记录的内容较多。例如插入一行记录一次，删除该行又记录一次


二进制日志记录的是所有影响数据的操作，记录的内容较多。例如插入一行记录一次，删除该行又记录一次

undo log是采用段(segment)的方式来记录的，每个undo操作在记录的时候占用一个undo log segment

当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。
有时候应用到行版本控制的时候，也是通过undo log来实现的：当读取的某一行被其他事务锁定时，它可以从undo log中分析出该行记录以前的数据是什么，从而提供该行版本信息，让用户实现非锁定一致性读取。

undo log也会产生redo log，因为undo log也要实现持久性保护


## 链接

https://www.cnblogs.com/wade-luffy/default.html?page=18
https://mp.weixin.qq.com/s/-puz311svMVbBAdRioPrnQ
https://www.cnblogs.com/bdsir/p/8745553.html
https://dev.mysql.com/doc/refman/8.0/en/innodb-in-memory-structures.html
https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html#auto_id_9