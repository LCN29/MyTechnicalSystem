# 1 查询 SQL 执行过程

## 1.1 连接

客户端和服务器建立连接。

### 1.1.1 通信协议

MySQL 是支持多种通信协议的,可以使用同步/异步的方式, 支持长连接/短连接。

#### 1.1.1.1 通信类型: 同步或者异步

同步通信的特点: 
> 1. 同步通信依赖于被调用方, 受限于被调用方的性能。也就是, 应用操作数据库, 线程会阻塞, 等待数据库的返回
> 2. 一般只能做到一对一, 很难做到一对多的通信


异步通信的特点:
> 1. 异步可以避免应用阻塞等待, 但是不能节省 SQL 执行的时间
> 2. 如果异步存在并发, 每一个 SQL 的执行都要单独建立一个连接,避免数据混乱。

异步通信会会给服务端带来巨大的压力 (一个连接就会创建一个线程, 线程间切换会占用 大量 CPU 资源)。  
另外异步通信还带来了编码的复杂度, 所以一般不建议使用。如果要异步, 必须使用连接池, 排队从连接池获取连接而不是创建新连接。  
一般来说我们连接数据库都是同步连接。

#### 1.1.1.2 连接方式: 长连接或者短连接

MySQL 既支持短连接, 也支持长连接。  
短连接就是操作完毕以后, 马上 close 掉。长连接可以保持打开, 减少服务端创建和释放连接的消耗, 后面的程序访问的时候还可以使用这个连接。  

一般我们会在连接池中使用长连接, 保持长连接会消耗内存。长时间不活动的连接,MySQL 服务器会断开, 默认都是 28800 秒, 8 小时

```sh
# 非交互式超时时间,如 JDBC 程序
show global variables like 'wait_timeout';

# 交互式超时时间,如数据库工具
show global variables like 'interactive_timeout';
```

#### 1.1.1.3 连接线程

查看 MySQL 当前有多少个线程

```sh
show global status like 'Thread%';
```

|  线程变量名 | 含义 |
| :-: | :-:|
| Threads_cached| 缓存中的线程连接数|
| Threads_connected | 当前打开的连接数|
| Threads_created| 已经创建的线程数, 一般 treads_cached 和 treads_connected 参数之和, 当并发数高的情况下, Threads_created 就会暴增, 这时可以适当提高 thread_cache_size 的大小|
| Threads_running| 非睡眠状态的连接数,通常指并发连接数|


也可以通过在 root 的情况下通过 **SHOW PROCESSLIST;**, 查看所有的线程状态

查询结果中的 **State** 一些常见的状态

| State | 状态|
| :-: | :-:|
| Sleep| 线程正在等待客户端,向它发送一个新语句|
| Query | 线程正在执行查询或往客户端发送数据|
| Locked| 该查询被其它查询锁定|
| Copying to tmp table on disk | 临时结果集合大于 tmp_table_size。线程把临时表从存储器内部格式改变为磁盘模式, 以节约存储器 |
| Sending data | 线程正在为 SELECT 语句处理行, 同时正在向客户端发送数据 |
| Sorting for group | 线程正在进行分类,以满足 GROUP BY 要求|
| Sorting for order | 线程正在进行分类,以满足 ORDER BY 要求|

MySQL 服务允许的最大连接数是 151 个, 最大可以设置成 16384 (2^14)


#### 1.1.1.4 通信协议

MySQL 支持的协议

**Unix Socket**  
在 Linux 中登录 MySQL 的命令行客户端, 如果没有指定 -h 参数, 它就用 socket 方式登录 (省略了 -S /var/lib/mysql/mysql.sock)。    
可以不用通过网络协议, 就连接到 MySQL 的服务器, 它需要用到服务器上的一个物理文件 (/var/lib/mysql/mysql.sock)。
具体的位置可以通过 **/tmp/mysql.sock** 查看 mysql.sock 的位置。

**TCP/IP 协议**
在 Linux 中登录 MySQL 的命令行客户端, 如果指定了 -h 参数, 就会用 TCP/IP 协议。  
一般在应用程序中都是以 TCP/IP 协议连接的。

**Named Pipes** 和 **Share Memory**  
这两种通信方式只能在 Windows 上面使用,一般用得比较少

### 1.1.2 通信方式

> 1. 单工: 在两台计算机通信的时候,数据的传输是单向的
> 2. 半双工: 在两台计算机之间,数据传输是双向的,你可以给我发送,我也可以给你发送, 但是在这个通讯连接里面,同一时间只能有一台服务器在发送数据
> 3. 全双工: 数据的传输是双向的, 并且可以同时传输


**MySQL 使用了半双工的通信方式**  

要么是客户端向服务端发送数据,要么是服务端向客户端发送数据,这两个动作不能同时发生。  
所以客户端发送 SQL 语句给服务端的时候, (在一次连接里面) 数据是不能分成小块发送的, 不管你的 SQL 语句有多大, 都是一次性发送。  
这种情况可能会影响到 insert 多条数据, where in 很多的情况等, 这时候可以通过 max_allowed_packet 参数的值 (默认值为 4 M), 提高单次传送的数据上限。



## 1.2 查询缓存

MySQL 内部自带了一个缓存模块, 但是这个缓存模块默认是默认是关闭的。

可以通过 
```sh
show variables like 'query_cache%';
```
进行查看。

MySQL 不推荐使用它自带的缓存的原因: 
> 1. MySQL 自带的缓存的应用场景有限，第一个是它要求 SQL 语句必须一模一样，中间多一个空格，字母大小写不同都被认为是不同的的 SQL
> 2. 第二个是表里面任何一条数据发生变化的时候, 这张表所有缓存都会失效, 所以对于有大量数据更新的应用，也不适合

在 MySQL 8.0 中, 查询缓存已经被移除了。

## 1.3 语法解析和预处理 ((Parser & Preprocessor)  

对客户端的语句基于 SQL 语法进行词法和语法分析和语义的解析

### 1.3.1 词法解析

把一个完整的 SQL 语句打碎成一个个的单词

```SQL
select name from user where id = 1 and age > 10;
```

它会打碎成 12 个符号，每个符号是什么类型，从哪里开始到哪里结束。

### 1.3.2 语法解析

对 SQL 做一些语法检查, 比如单引号有没有闭合, 然后根据 MySQL 定义的语法规则，根据 SQL 语句生成一个解析树 (select_lex)。

![Alt 'SelectSQLSelectLexDemo'](https://raw.githubusercontent.com/PictureRespository/MySQL/main/picture/SelectSQLSelectLexDemo.png)



