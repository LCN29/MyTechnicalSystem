# 3 MySQL事务与锁详解

## 3.1 数据库事务

### 3.1.1 事务定义

事务是数据库管理系统 (DBMS) 执行过程中的一个逻辑单位, 由一个有限的数据库操作序列构成, 这些操作要么都做, 要么都不做, 是一个不可分割的工作单位。

事务是数据库最小的工作单元, 是不可以再分的, 可能包含了一个或者一系列的 DML 语句。

### 3.1.2 事务的四大特性

事务的四大特性: ACID

**Atomicity (原子性)**  
对数据库的一系列的操作, 要么都是成功, 要么都是失败, 不可能出现部分成功或者部分失败的情况。  

以转账的场景为例, 一个账户的余额减少, 对应一个账户的增加, 这两个一定是同时成功或者同时失败的。

在 InnoDB 里面是通过 undo log 来实现的, 它记录了数据修改之前的值 (逻辑日志) , 一旦发生异常, 就可以用 undo log 来实现回滚操作

**consistent (一致性)**  
数据库的完整性约束没有被破坏, 事务执行的前后都是合法的数据状态。

比如说转账的这个场景, A 账户余额减少 1000, B 账户余额只增加了 500, 这个时候因为两个操作都成功了, 按照我们对原子性的定义, 它是满足原子性的, 但是它没有满足一致性, 因为它导致了会计科目的不平衡。

**Isolation (隔离性)**
多个事务, 对表或者行的并发操作, 是透明的, 互相不干扰的, 一个未完成事务不会影响另外一个未完成事务。

**Durable (持久性)**  
一旦一个事务被提交, 它应该持久保存, 不会因为与其他操作冲突而取消这个事务。

持久性是通过 redo log 和 double write 双写缓冲来实现的。  
我们操作数据的时候, 会先写到内存的 buffer pool 里面, 同时记录 redo log, 如果在刷盘之前出现异常, 在重启后就可以读取 redo log 的内容, 写入到磁盘, 保证数据的持久性。  
恢复成功的前提是数据页本身没有被破坏, 是完整的, 这个通过双写缓冲 (double write) 保证。

### 3.1.3 数据库什么时候会出现事务

**自动开启和自动提交**

```sql
update 表名 set 字段 = 值 where 条件;
```

上面的 SQL 会自动开启了一个事务, 并且自动提交了, 所以最终写入了磁盘。  

这种行为是通过 InnoDB 里面有一个 autocommit 的参数 (`show variables like 'autocommit';`) 控制的, 它的默认值是 on/true, 表示在操作数据的时候, 会自动开启一个事务, 和自动提交事务。

**手动开启和手动提交**

把 autocommit 设置成 false/off, 那么数据库的事务就需要我们手动开启和手动结束。

手动开启事务的方法
> 1. begin
> 2. start transcation

手动提交事务/手动撤销事务
> 1. commit
> 2. rollback
> 3. 客户端的连接断开的时候, 事务也会结束

### 3.1.4 事务并发会带来的问题

#### 3.1.4.1 脏读

如图: 

![Alt 'DirtyRead'](https://raw.githubusercontent.com/PictureRespository/MiddleWare/main/MySQL/DirtyRead.png)

> 1. Transcation A 查询 id = 1 的记录的 age = 16
> 2. Transcation B 更新 id = 1 的记录的 age = 18, 但是还未提交事务
> 3. Transcation A 再次查询 id = 1 的记录的 age = 18

在一个事务里面, 由于其他的事务修改了数据并且没有提交, 而导致了前后两次读取数据不一致的情况, 这种事务并发的问题叫做 **脏读**

#### 3.1.4.2 不可重复读

如图: 

![Alt 'NonrepeatableRead'](https://raw.githubusercontent.com/PictureRespository/MiddleWare/main/MySQL/NonrepeatableRead.png)

> 1. Transcation A 查询 id = 1 的记录的 age = 16
> 2. Transcation B 更新 id = 1 的记录的 age = 18, 并且提交了事务
> 3. Transcation A 再次查询 id = 1 的记录的 age = 18

一个事务里面, 读取到了其他事务已提交的数据导致前后两次读取数据不一致的情况, 这种事务并发的问题叫做 **不可重复读**

#### 3.1.4.2 幻读

如图:

![Alt 'PhantomRead'](https://raw.githubusercontent.com/PictureRespository/MiddleWare/main/MySQL/PhantomRead.png)

> 1. Transcation A 查询 age > 15 的记录总条数的 count = 1
> 2. Transcation B 插入了一条 age = 18 的记录, 并且提交了事务
> 3. Transcation A 再次查询 age > 15 的记录总条数的 count = 2

一个事务里面, 由于其他事务插入或者删除数据导致前后两次读取数据数据不一致, 这种事务并发的问题叫做 **幻读**

幻读和不可重复读的区别:
> 1. 不可重复读强调的是记录的修改
> 2. 幻读强调的集合的增减

事务并发带来的三大问题, 无论是脏读, 还是不可重复读, 还是幻读, 它们都是数据库的**读一致性**的问题, 都是在一个事务里面前后两次读取出现了不一致的情况。
读一致性的问题, 必须要由数据库提供一定的事务隔离机制来解决。

### 3.1.5 SQL92 标准

数据库厂商都按照这个标准, 提供一定的事务隔离级别, 来解决事务并发的问题。 

SQL92 里面定义了四个隔离级别
> 1. Read Uncommitted (未提交读) :, 一个事务可以读取到其他事务未提交的数据, 会出现脏读, 它没有解决任何的问题
> 2. Read Committed (已提交读) : 一个事务只能读取到其他事务已提交的数据, 不能读取到其他事务未提交的数据, 它解决了脏读的问题, 但是会出现不可重复读的问题
> 3. Repeatable Read (可重复读): 在同一个事务里面多次读取同样的数据结果是一样的, 它解决了不可重复读的问题, 但是会出现幻读的问题
> 4. Serializable (串行化) : 在这个隔离级别里面, 所有的事务都是串行执行的, 也就是对数据的操作需要排队, 已经不存在事务的并发操作了, 所以它解决了所有的问题

这个是 SQL92 的标准, 但是不同的数据库厂商或者存储引擎的实现有一定的差异, 比如 Oracle 里面就只有两种 RC (已提交读) 和 Serializable (串行化) 

### 3.1.6 MySQL InnoDB 对隔离级别的支持

在 MySQL InnoDB 里面, 不需要使用串行化的隔离级别去解决所有问题。

| 事务隔离级别 | 脏读 | 不可重复读 | 幻读 |
| :-: | :-: |  :-:|  :-:  |
| 未提交读 (Read Uncommitted)  |  可能 | 可能  |  可能  |
| 已提交读 (Read Committed) |  不可能 | 可能   |  可能  |
| 可重复读 (Repeatable Read) | 不可能  | 不可能   |  对 InnoDB 不可能  |
| 串行化 (Serializable) |  不可能 |  不可能  | 不可能  |

InnoDB 支持的四个隔离级别和 SQL92 定义的基本一致, 隔离级别越高, 事务的并发度就越低。唯一的区别就在于, InnoDB 在 RR 的级别就解决了幻读的问题。  
这个也是 InnoDB 默认使用 RR 作为事务隔离级别的原因, 既保证了数据的一致性, 又支持较高的并发度。

### 3.1.7 两大实现方案

要解决读一致性的问题, 保证一个事务中前后两次读取数据结果一致, 实现事务隔离, 应该怎么做?

#### 3.1.7.1 LBCC

要保证前后两次读取数据一致, 那么读取数据的时候, 锁定要操作的数据, 不允许其他的事务修改就行了。这种方案叫做基于锁的并发控制 Lock Based Concurrency Control (LBCC) 。  
如果仅仅是基于锁来实现事务隔离, 一个事务读取的时候不允许其他时候修改, 那就意味着不支持并发的读写操作, 而我们的大多数应用都是读多写少的, 这样会极大地影响操作数据的效率。

#### 3.1.7.2 MVCC

要让一个事务前后两次读取的数据保持一致, 那么可以在修改数据的时候给它建立一个备份或者叫快照, 后面再来读取这个快照就行了。  
这种方案叫做多版本的并发控制 Multi Version Concurrency Control (MVCC) 。

MVCC 的核心思想是: 可以查到在这个事务开始之前已经存在的数据, 即使它在后面被修改或者删除了。在这个事务之后新增的数据, 是查不到的。

**MVCC 的实现**

InnoDB 为每行记录都实现了三个隐藏字段
> 1. DB_ROW_ID: 6 个字节, 行标识
> 2. DB_TRX_ID: 6 个字节, 插入或更新行的最后一个事务的事务 ID, 事务编号是自动递增的 (我们把它理解为创建版本号, 在数据新增或者修改为新数据的时候, 记录当前事务 ID) 
> 3. DB_ROLL_PTR: 7 个字节, 回滚指针 (我们把它理解为删除版本号, 数据被删除的时候, 记录删除的事务 ID) 

如图: 
![Alt 'MVCCSimpleModel'](https://raw.githubusercontent.com/PictureRespository/MiddleWare/main/MySQL/MVCCSimpleModel.png)

如上面的演示, 通过版本号的控制, 无论其他事务是插入 / 修改 / 删除, 第一个事务查询到的数据都没有变化。

在 InnoDB 中, MVCC 是通过 Undo log 实现的, MVCC 和锁是协同使用的。  
Oracle, Postgres 等等其他数据库都有 MVCC 的实现。  

### 3.1.8 支持事务的存储引擎
> 1. InnoDB
> 2. NDB


## 3.2 MySQL InnoDB 锁的基本类型

官网把锁分成了 8 大类
> 1. Shared and Exclusive Locks
> 2. Intention Locks
> 3. Record Locks
> 4. Gap Locks
> 5. Next-Key Locks
> 6. Insert Intention Locks
> 7. AUTO-INC Locks
> 8. Predicate Locks for Spatial Indexes

2 个行级锁 (Shared and Exclusive Locks) 和 2 个表级锁 (Intention Locks) 可以成为锁的基本模式。  
Record Locks、Gap Locks、Next-Key Locks 可以成为锁的算法, 也就是分别在什么情况下锁定什么范围。

### 3.2.1 锁粒度

表锁: 锁住一张表, 行锁: 锁住表里面的一行数据。  
> 1. 从锁定粒度上看, 表锁肯定是大于行锁的。
> 2. 从加锁效率上看, 表锁快于行锁。表锁只需要直接锁住这张表就行了, 而行锁, 还需要在表里面去检索这一行数据
> 3. 从冲突的概率上看, 表锁大于行锁。在表锁上, 其他任何一个事务都不能操作这张表。 但是行锁, 其他的事务还可以来操作表里面其他的行数据

注: MyISAM 只支持表级锁。

### 3.2.2 共享锁

Shared Locks (共享锁) , 获取了一行数据的读锁以后, 可以用来读取数据, 所以它也叫做读锁, 多个事务可以共享一把读锁。  
注意不要在加上了读锁以后去写数据, 不然的话可能会出现死锁的情况。  

可以用 `select …… lock in share mode` 的方式手动加读锁, 只要事务结束, 锁就会自动释放

### 3.2.3 排他锁

Exclusive Locks (排它锁), 用来操作数据的, 所以又叫做写锁。只要一个事务获取了一行数据的排它锁, 其他的事务就不能再获取这一行数据的共享锁和排它锁

排它锁的加锁方式有两种
> 1. 自动加排它锁, 在操作数据的时候, 包括增删改, 都会默认加上一个排它锁
> 2. 手工加排它锁, 可以用一个 `FOR UPDATE` 给一行数据加上一个排它锁

### 3.2.4 行锁的原理

**场景一**  
假设当前有一张表 t1, 有 2 个字段: int 类型的 id 和 varchar 类型的 name, 表中没有任何的索引。 表中已经有 2 条数据

> 1. 事务 A : `select * from t1 where id = 1 for update;`, 锁住 id = 1 的行
> 2. 事务 B : `select * from t1 where id = 2 for update;`, 这时候加锁失败, 阻塞住了
> 3. 事务 C : `insert into t1 values(3, 'test')`, 这时候插入失败, 同样阻塞住了

**场景二** 

假设当前有一张表 t1, 有 2 个字段: int 类型的 id 和 varchar 类型的 name, 表中的 id 是主键索引。表中已经有 2 条数据

> 1. 事务 A : `select * from t1 where id = 1 for update;`, 锁住 id = 1 的行
> 2. 事务 B : `select * from t1 where id = 1 for update;`, 尝试锁住 id = 1 的行失败, 阻塞住
> 3. 事务 C : `select * from t1 where id = 2 for update;`, 尝试锁住 id = 2 的行, 成功

**场景三**  

假设当前有一张表 t1, 有 2 个字段: int 类型的 id 和 varchar 类型的 name, 表中的 id 是主键索引, name 是唯一索引。表中已经有 2 条数据

> 1. 事务 A : `select * from t1 where name = 'one' for update;`, 锁住 name = one 的行
> 2. 事务 B : `select * from t1 where name = 'one' for update;`, 尝试锁住 name = one 的行失败, 阻塞住
> 3. 事务 C : `select * from t1 where id = 1 for update;`, 尝试锁住 id = 1 的行失败, 阻塞住

通过上面的情景可以得到:   

InnoDB 的行锁, 既不是锁行记录, 也不是锁字段, 而是就是通过**锁住索引**来实现的。

**为什么表里面没有索引的时候, 锁住一行数据会导致锁表 (一张表有没有可能没有索引)**

索引的定义
> 1. 如果我们定义了主键 (PRIMARY KEY), 那么 InnoDB 会选择主键作为聚集索引
> 2. 如果没有显式定义主键, 则 InnoDB 会选择第一个不包含有 NULL 值的唯一索引作为主键索引
> 3. 如果也没有这样的唯一索引, 则 InnoDB 会选择内置 6 字节长的 ROWID 作为隐藏的聚集索引, 它会随着行记录的写入而主键递增

所以查询没有使用索引, 会进行全表扫描, 然后把每一个隐藏的聚集索引都锁住了。

**为什么通过唯一索引给数据行加锁, 主键索引也会被锁住**

通过辅助索引进行查询数据时, 先在辅助索引里面找到对应的主键的值, 然后再在主键索引里面查询数据。  
所以我们通过辅助索引锁定一行数据的时候, 它跟我们检索数据的步骤是一样的, 会通过主键值找到主键索引, 然后锁定。

### 3.2.4 意向锁 

意向锁是由数据库自己维护的
> 1. 给一行数据加上共享锁之前, 数据库会自动在这张表上面加一个意向共享锁 (Intention Sharded Lock, 简称 IS 锁)
> 2. 给一行数据加上排他锁之前, 数据库会自动在这张表上面加一个意向排他锁 (Intention Exclusive Lock, 简称 IX 锁)

也就是说:  
> 1. 如果一张表上面至少有一个意向共享锁, 说明有其他的事务给其中的某些数据行加上了共享锁。  
> 2. 如果一张表上面至少有一个意向排他锁, 说明有其他的事务给其中的某些数据行加上了排他锁

两个表级别的锁存在
> 1. 有了表级别的锁, 在 InnoDB 里面就可以支持更多粒度的锁。
> 2. 可以把它理解成一个标志, 是用来提高加锁的效率的。 比如如果要给一张表加表锁, 那么就需要判断是否有行锁, 必须先要去判断有没其他的事务锁定了其中了某些行, 有了意向锁这个标志, 就可以不去遍历行

### 3.2.5 锁算法

假设当前有一张表 t, 有 2 个字段: int 类型的 id 和 varchar 类型的 name, id 是主键索引。  
表中当前有 4 条数据, id 分别为 1, 4, 7, 10.

![Alt 'Record'](https://raw.githubusercontent.com/PictureRespository/MiddleWare/main/MySQL/Record.png)

数据库里面存在的主键值, 把它叫做 Record, 记录, 这里有 4 个 Record

![Alt 'Gap'](https://raw.githubusercontent.com/PictureRespository/MiddleWare/main/MySQL/Gap.png)

根据主键, 这些存在的 Record 隔开的数据不存在的区间, 叫做 Gap, 间 隙, 它是一个左开右开的区间

![Alt 'Next-Key'](https://raw.githubusercontent.com/PictureRespository/MiddleWare/main/MySQL/NextKey.png)

间隙 (Gap) 连同右边的记录 (Record) , 叫做临键的区间, 它是一个左开右闭的区间

#### 3.2.5.1 Record Lock - 记录锁

对表中的某行记录加锁, 就是记录锁, 记录锁锁住的是记录的索引。 
记录锁主要用于唯一性的索引(包括唯一索引和主键索引), 非唯一性索引的只会出现间隙锁或临键锁。

对唯一性的索引使用等值查询, 精确匹配到一条记录的时候, 这个时候使用的就是记录锁。

记录锁是一个排他锁, 会阻塞其他事务的所有相关操作。

#### 3.2.5.2 Gap Lock - 间隙锁

在记录和记录之间存在着某些间隙, 对这些间隙进行加锁, 就是间隙锁。

> 1. 使用唯一性索引进行等值查询, 没有命中任何一条记录, 这时候是间隙锁, 锁住的是**当前查询条件的值所在的 2 个记录之间的间隙**。比如现在查询条件是 6, 那么所在的是 (4, 7) 区间
> 2. 使用唯一性索引进行等值查询, 命中任何一条记录, 这时候是记录锁
> 3. 使用非唯一性索引进行等值查询, 无论是否命中记录, 这时候是间隙锁, 锁住的是**当前查询条件的值所在的 2 个记录之间的间隙**
> 4. 使用索引进行范围查询, 没有命中任何一条记录, 这时候是间隙锁, 锁住的是**查询条件的值组成的范围, 不包含条件值本身**。比如查询条件是 between 1 and 8, 那么所在的是 (1, 8) 区间
> 5. 使用索引进行范围查询, 命中任何一条记录, 这时候是临键锁,

例子: 
> 1. 事务 A: `select * from t where id = 6 for update;`, 找不到, 导致 4 - 7 进行出现间隙锁
> 2. 事务 B: `insert into t ('id', 'name') values(5, 'name');` 在 4 - 7 之间有间隙锁, 插入失败
> 3. 事务 C: `select * from t where id = 6 for update;`, 查询结果为空, 没有被阻塞

**importance**
特别说明:
> 1. 间隙锁主要是阻塞插入 insert, 对于删改查都不会有影响, 查很容易理解, 出现了删改, InnoDB 的 MVCC 机制可以保证数据在事务中的正常
> 2. 相同的间隙锁之间不冲突, 2 个间隙锁的区间可以是包含关系, 也可以是部分重叠
> 3. 间隙锁只在 RR 的隔离级别出现, 所以将隔离级别修改成别的, 可以关闭间隙锁功能
> 4. 另一种关闭间隙锁的方式, 将 `innodb_locks_unsafe_for_binlog` 设置为 0, 这时候除了外键约束和唯一性检查会加间隙锁, 其他情况都不会用间隙锁

#### 3.2.5.3 Next-Key Lock - 临键锁

临键锁就是间隙锁 + 记录锁的组合, 通过条件查询等操作, 会把符合条件的间隙和记录锁住。

**importance**
> 1. 临键锁就是 MySQL 里面默认的行锁算法, 等于**间隙锁 + 记录锁**
> 2. 临键锁等于**间隙锁 + 记录锁**, 所以其锁住的范围和间隙锁是相同的, 只是范围里面的记录会变成记录锁, 比如查询条件为 7, 那么间隙锁的范围为 (4, 10), 命中记录 7, 最终变为 (4, 7] 和 (7, 10)
> 3. 使用辅助索引, 命中的记录, 还会对这条记录的主键加上记录锁
> 4. 临键锁会进行退化: 通过等值查询匹配到一条记录, 退化为记录锁
> 5. 临键锁会进行退化: 使用唯一性索引, 没有匹配到任何记录的时候, 退化成间隙锁

使用唯一性索引, 临键锁锁住的是**条件范围内, 比范围最小值的前面最接近第一个索引(可以是索引本身) + 比范围最大值的后面最接近的第一个索引(不包含索引本身) 间所有的索引记录 + 索引记录前边的间隙**  

例如: where id > 5 and id < 9, 命中了记录 7, 同时有 4 - 7 和 7 - 10 的 2 个间隙。

```sql
select * from t2 where id > 5 and id <= 7 for update;
```
这时候锁住的范围为 (4, 7] 和 (7, 10]

```sql
select * from t2 where id > 8 and id <= 10 for update;
```
这时候锁住的范围为 (7, 10] 和 (10, +∞] 

#### 3.2.5.4 InnoDB 锁的范围总结

有个重点先说明一下, 对于非唯一性索引, 值是可以重复的。

假设现在有一张表, id 的主键, num 是普通的索引, 表中有数据

| id (主键) | num (普通索引)|
|:-:| :-:|
| 1 | 1 |
| 2 | 6  |
| 3 | 2 |
| 4 | 2 |
| 5 | 3 |
| 6 | 5 |
| 8 | 5 |
| 9 | 5 |
| 10 | 3 |

使用辅助索引时, InnoDB 在使用锁的时候, **会先按照辅助索引进行排序, 辅助索引排序后, 辅助索引有相同值时, 会再按照主键排序**, 所以排序后的变为

| id (主键) | num (普通索引)|
|:-:| :-:|
| 1 | 1 |
| 3 | 2 |
| 4 | 2 |
| 5 | 3 |
| 10 | 3|
| 6 | 5 |
| 8 | 5 |
| 9 | 5 |
| 2 |  6 |

对于间隙锁的范围, 等值查询的一般情况下, 锁住的是 **左区间是以当前条件向左找到第一条记录, 右区间是向右找到的第一条记录**
如果现在条件为 `where num = 4`,  num 4 向左找到的第一条记录为 (10, 3), 向右找到的第一条记录为 (6, 5), 所以这个条件锁住的间隙为 (3, 5), 在具体的是 (10, 3) 到 (6, 5)。  
如果这时候想里面插入 (7, 5) 是能插入成功的, 因为不在上面说的范围内。


我们知道, **当查询条件没有索引时, 会导致锁表**, 所以下面讨论的是在有索引的情况: 
影响锁的范围的影响因素
> 1. 条件是否为唯一索引
> 2. 查询的方式, 等值查询, 范围查询

**情况一: 唯一索引 + 等值查询**

> 1. 命中了记录, 直接就是记录锁
> 2. 未命中记录, 间隙锁, 锁住的就是包住这个条件的 2 个记录的区间, (注意上面间隙锁范围的说明)

**情况二: 唯一索引 + 范围查询**

使用范围查询的话, 基本锁住的范围就是条件限制的范围, 这个范围内的记录加上的都是记录锁。  

需要说明的是, 如果 where `主键 > 条件`, 这个条件不是记录, 那么会向左找到第一条记录, 以这条记录开始, 
同理如果 where `主键 < 条件`, 这个条件不是记录, 会向右找到第一条记录

**情况三: 非唯一索引 + 等值查询**

以这个条件, 向左找到第一条记录, 向右找到的第一条记录, 组成一个区间, 中间的记录为记录锁, 同时会锁住这条记录对应的主键索引。

**情况四: 非唯一索引 + 范围查询**

和唯一索引不同的, 非唯一索引, 还会增加 2 侧的间隙
> 1. where `非唯一索引 > 条件`, 无论条件是否为记录, 都会向左找到第一条记录, 从这里开始加上条件的范围组成区间, 中间出现的记录都会加上记录锁, 同理 `where 非唯一索引 < 条件` 会向右找到第一条记录, 加上条件的范围。

为了解决幻读的问题。

锁算法锁的内容

> 1. 在不通过索引条件查询时, InnoDB 会锁定表中的所有记录
> 2. InnoDB 通过索引来实现行锁, 而不是通过锁住记录, 所以当操作的两条不同记录拥有相同的索引时, 也会因为行锁被锁而发生等待
> 3. 由于 InnoDB 的索引机制, 数据库操作使用了主键索引, InnoDB 会锁住主键索引, 使用非主键索引时, InnoDB 会先锁住非主键索引, 再锁定主键索引
> 4. 当查询的索引是唯一索引时, InnoDB 存储引擎会将 Next-Key Lock 降级为 Record Lock, 即只锁住索引本身, 而不是范围
> 5. InnoDB 对于非唯一辅助索引有特殊的处理, 不仅会锁住辅助索引值所在的范围, 还会将其下一键值加上 Gap Lock 
> 6. InnoDB 使用 Next-Key Lock 机制来避免 Phantom Problem (幻读问题) 




#### 3.2.5.5 临键锁怎么解决幻读

通过加锁的形式, 限制了其他事务对这个范围内的数据的更新,
同时在非唯一索引上多追加 2 侧的间隙的锁定, 帮证数据的准确
> 1. 唯一索引, 不需要追加 2 侧的间隙的锁定, 索引唯一的, 所以锁住了这个范围, 不会在出现条件相同的情况
> 2. 非唯一索引, 则不同, 如果只锁住索引锁住的区间, 这个索引和 2 侧的索引还是有可能新增进相同的值的

比如, 现在的表数据如下

| 主键索引 (id) | 非唯一索引 (name) |
| :-: | :-:  |
| 1  |   a|
| 3 |  a|
| 6  |  d  |
| 9 |  g|

事务 A 查询的条件为 `where name >= 'd'`, 
在唯一索引的情况下, 只会锁住 [d, +∞], InnoDB 的唯一索引, 确保了后续不会在出现 d 的数据了  
但是在非唯一索引的情况下, 如果同样是锁住 [d, +∞], 第一次查询为 2 条记录, 但是另一个事务插入了 (4, d), 因为这时候 a, d 的范围还是可以插入 d 的数据的, 第二次查询就可能出现 3 条记录,  
所以在把 a, d 之间的区域锁住, 那么就不会在出现 d 数据的新增了, 总条数不变。 所以 <=, 同样的逻辑。

### 3.2.6 其他几个锁

#### 3.2.6.1 插入意向锁

插入意向锁是一种特殊的间隙锁, 但不同于间隙锁的是, 该锁只用于并发插入操作: 如果多个事务插入到相同的索引间隙中, 如果它们不在间隙中的相同位置插入, 则无需等待其他事务。  
比如说有索引记录 4 和 7, 有两个事务想要分别插入 5, 6, 在获取插入行上的排它锁之前, 每个事务都使用插入意图锁锁定 4 和 7 之间的间隙, 但是不会互相阻塞, 因为行是不冲突的。  
简单来说: 插入意向锁锁定了索引之间的间隙, 但是事务之间只要不插入同一个位置, 彼此之间是不会阻塞的。

#### 3.2.6.2 自增锁

自增锁是一种比较特殊的表级锁, 主要用于在事务中插入自增字段。  
通过 `innodb_autoinc_lock_mode` 配置控制自动增量锁定的算法, 允许用户在 `可预测的自动增量值序列`和`插入操作的最大并发之间`进行权衡选择。

为了便于介绍 innodb_autoinc_lock_mode 参数, 先将需要用到自增锁的 Insert 语句进行分类

> 1. INSERT-like: 所有可以向表中增加行的语句, 包含 insert, insert ... select, replace, replace ... select, load data, insert ... on duplicate key update 6 个语句
> 2. Simple inserts: 可以预先确定要插入的行数的语句, 直接的 insert 和 replace
> 3. Bulk inserts: 事先不知道要插入的行数的语句, insert ... select, replace ... select, load data
> 4. Mixed-mode inserts: 在 Simple inserts 语句的基础上, 部分行手动指定了自增列的值, 比如, insert into t1(id, name) values(1, 'one'), (Null, 'two'), (Null, 'three') 和 insert ... on duplicate key update 语句 


innodb_autoinc_lock_mode 三种取值的含义

**traditional (取值: 0)**

在此锁定模式下, 所有 "INSERT-like" 语句获得一个特殊的表级 AUTO-INC 锁, 用于插入具有 AUTO_INCREMENT 列的表。  
此锁定通常保持到 insert 语句结束 (不是事务结束) , 以确保为给定的INSERT语句序列以可预测和可重复的顺序分配自动递增值, 并确保自动递增由任何给定语句分配的值是连续的。

在**基于语句复制 (statement-based replication**) 的情况下, 这意味着当在从服务器上复制 SQL 语句时, 自动增量列使用与主服务器上相同的值。多个 INSERT 语句的执行结果是确定性的, 从服务器再现与主服务器相同的数据

**consecutive (取值: 1)**

在此锁定模式下, "Simple inserts" (要插入的行数事先已知) , 不使用表级 AUTO-INC 锁, 而是通过在 mutex (轻量锁) 的控制下获得所需数量的自动递增值来避免表级 AUTO-INC 锁, 它只在分配过程的持续时间内保持, 而不是直到语句完成。  
当然: 如果另一个事务保持 AUTO-INC 锁, 则 “Simple inserts” 则需要等待 AUTO-INC 锁, 然后按照 "Bulk inserts" 处理。

此锁定模式确保, 当有行数不预先知道的 INSERT 存在时, 任何 “INSERT-like” 语句分配的所有自动递增值是连续的, 并且对于基于语句的复制 (statement-based replication) 操作是安全的。
此模式大体是和 traditional 一致的。但有个特殊场景需要注意: 混合模式的插入, 可能会有部分多余自增值丢失。   
InnoDB 分配比要插入的行数更多的自动增量值。但是, 所有自动分配的值都是连续生成的 (因此高于) 由最近执行的前一条语句生成的自动增量值, "多余" 的数字丢失。

**interleaved (取值: 2)**

在此锁定模式下, 所有 "INSERT-like" 语句不使用 AUTO-INC 锁, 可以同时执行多个语句, 这是最快和最可扩展的锁定模式。

但是当使用基于语句的复制或恢复方案时, 从二进制日志重播SQL语句时, 这是不安全的

在此锁定模式下, 自动递增值保证在所有并发执行的 "INSERT-like" 语句中是唯一且单调递增的。但是, 由于多个语句可以同时生成数字 (即, 跨语句交叉编号) , 为任何给定语句插入的行生成的值可能不是连续的。  
如果执行的语句是 "simple inserts", 其中要插入的行数已提前知道, 则除了 "Mixed-mode inserts" 之外, 为单个语句生成的数字不会有间隙。然而, 当执行 "Bulk inserts"时, 在由任何给定语句分配的自动递增值中可能存在间隙。  

如果不使用二进制日志作为恢复或复制的一部分来重放 SQL 语句, 则可以使用 interleaved 模式来消除所有使用表级 AUTO-INC 锁, 以实现更大的并发性和性能, 其代价是由于并发的语句交错执行, 同一语句生成的 AUTO-INCREMENT 值可能会产生间隙。

Binlog 一般用于 MySQL 的数据复制, 通俗一点就是用于主从同步。在 MySQL 中 Binlog 的格式有 3 种, 分别是: 

> 1. Statement: 基于语句, 只记录对数据做修改的 SQL 语句, 能够有效的减少 binlog 的数据量, 提高读取, 基于 Binlog 重放的性能
> 2. Row: 只记录被修改的行, 所以 Row 记录的 binlog 日志量一般来说会比 Statement 格式要多
> 3. Mixed: Statement 和 Row 的结合, 怎么个结合法呢。表结构变更使用 statement 模式来记录, 如果 SQL 语句是 update 或者 delete 语句, 那么使用 row 模式


如果 MySQL 采用的格式为 Statement, 那么 MySQL 的主从同步实际上同步的就是一条一条的 SQL 语句。如果此时采用了交叉模式, 那么并发情况下 INSERT 语句的执行顺序就无法得到保障。  
INSERT 同时交叉执行, 并且 AUTO_INCREMENT 交叉分配将会直接导致主从之间同行的数据主键 ID 不同。

和自增锁相关的三个参数
> 1. auto_increment_offset: 表示起始数字
> 2. auto_increment_increment: 表示自增的步长 (即每次增加 n 个数字, 2 就代表每次 +2) 
> 3. innodb_autoinc_lock_mode: 加锁的模式, 可以设定 3 个值, 0, 1, 2, 默认为 1

#### 3.2.6.3 空间索引的谓词锁

InnoDB 支持对包含空间的列建立 SPATIAL 索引。

要处理涉及 SPATIAL 索引的操作的锁定, next-key 锁定不能很好地支持 REPEATABLE READ 或 SERIALIZABLE 事务隔离级别, 因为在多维数据中没有绝对排序概念, 因此不清楚哪个是邻键。  
为了支持具有 SPATIAL 索引的表的隔离级别, InnoDB 使用谓词锁。SPATIAL 索引包含最小边界矩形 (MBR) 值, 因此 InnoDB 通过设置用于查询的 MBR 值的谓词锁来强制对索引进行一致读取。  
此时, 其他事务不能插入或修改与查询条件匹配的行。

## 3.3 隔离级别

### 3.3.1 隔离级别的实现

| 事务隔离级别 | 脏读 | 不可重复读 | 幻读 |
| :-: | :-: |  :-:|  :-:  |
| 未提交读 (Read Uncommitted)  |  可能 | 可能  |  可能  |
| 已提交读 (Read Committed) |  不可能 | 可能   |  可能  |
| 可重复读 (Repeatable Read) | 不可能  | 不可能   |  对 InnoDB 不可能  |
| 串行化 (Serializable) |  不可能 |  不可能  | 不可能  |

四个事务隔离级别的实现

**Read Uncommited**  

不加任何的锁

**Serializable** 

Serializable 所有的 select 语句都会被隐式的转化为 select ... in share mode, 会和 update、delete 互斥

**Repeatable Read**

RR 隔离级别下, 普通的 select 使用快照读(snapshot read), 底层使用 MVCC 来实现。
加锁的 select (select ... in share mode / select ... for update) 以及更新操作 update, delete 等语句使用当前读 (current read) , 底层使用记录锁, 间隙锁, 临键锁。

**Read Commited**

RC 隔离级别下, 普通的 select 都是快照读, 使用 MVCC 实现。  
加锁的 select 都使用记录锁, 因为没有 Gap Lock。  

除了两种特殊情况 —— 外键约束检查 (foreign-key constraint checking) 以及重复键检查 (duplicate-key checking) 时会使用间隙锁封锁区间。

所以 RC 会出现幻读的问题。

### 3.3.1 隔离级别的选择

RU 未解决任何问题。

Serializable 并发性能不行

RC 和 RR 区别
> 1. RR 的 间隙锁会导致锁定范围的扩大
> 2. 条件列为使用到索引, RR 锁表, RC 锁行
> 3. RC 的 "半一致性" (semi-consistent), 读可以增加 update 操作的并发性

在 RC 中, 一个 update 语句, 如果读到一行记录已经加锁的记录, 此时 InnoDB 返回记录最近提交的版本, 由 MySQL 上层判断此版本是否满足 update 的 where 条件。  
若满足(需要更新), 则 MySQL 会重新发起一次读操作, 此时会读取行的最新版本(并加锁)。

能够正确地使用锁 (避免不使用索引去加锁), 只锁定需要的数据, 用默认的 RR 级别就可以了。

## 3.4 死锁

在使用锁的时候, 有一个问题是需要注意和避免的, 排它锁有互斥的特性。一个事务或者说一个线程持有锁的时候, 会阻止其他的线程获取锁, 这个时候会造成阻塞等待, 如果循环等待, 会有可能造成死锁。

### 3.4.1 锁的释放和阻塞

锁的释放
> 1. 事务结束 (commit, rollback)
> 2. 客户端连接断开

如果一个事务一直未释放锁, 其他事务会阻塞一段时间后, 报错误 `[Err] 1205 - Lock wait timeout exceeded; try restarting transaction`。  
阻塞的时间默认为 50s, 可以通过 `show variables like 'innodb_lock_wait_timeout';` 进行查看。


InnoDB 内部会通过算法 (wait-for graph) 自动检测死锁, 当发现当前会死锁的话, 不会进行阻塞, 而是直接失败, 报错误 `[Err] 1213 - Deadlock found when trying to get lock; try restarting transaction`。

> 1. 事务 A begin; select * from t2 where id = 1 for update; 锁住了 id = 1 的记录
> 2. 事务 B begin; delete from t2 where id = 4; 删除 id = 4 的记录, 但是事务还未提交
> 3. 事务 A update t2 set name = 'test' where id = 4;

这时候, 事务 A 会检测到死锁, 马上退出, 而不是一直阻塞着, 等到 50 秒。

### 3.4.2 死锁的产生条件
锁本身是互斥的
> 1. 同一时刻只能有一个事务持有这把锁
> 2. 其他的事务需要在这个事务释放锁之后才能获取锁, 而不可用强行剥夺
> 3. 当多个事务形成等待环路的时候, 即发生死锁

### 3.4.3 查看锁信息 (日志)

通过 `show status like 'innodb_row_lock_%';` 可以查看到当前数据库中一些行锁的信息 (数据非实时的)

> 1. Innodb_row_lock_current_waits: 当前正在等待锁定的数量
> 2. Innodb_row_lock_time: 从系统启动到现在锁定的总时间长度, 单位 ms
> 3. Innodb_row_lock_time_avg: 每次等待所花平均时间 
> 4. Innodb_row_lock_time_max: 从系统启动到现在等待最长的一次所花的时间
> 5. Innodb_row_lock_waits: 从系统启动到现在总共等待的次数

通过上面的命令看到的是一些概要的信息。 InnoDB 还提供了三张表来分析事务和锁的情况: 

```sql
select * from information_schema.INNODB_TRX; -- 当前运行的所有事务, 还有具体的语句
```

```sql
select * from information_schema.INNODB_LOCKS; -- 当前出现的锁
```

```sql
select * from information_schema.INNODB_LOCK_WAITS; -- 锁等待的对应关系
```

如果一个事务长时候持有锁不释放, 可以 kill 事务对应的线程 Id, 也就是 INNODB_TRX 表中的 trx_mysql_thread_id。
这是一张不推荐的做法, 应该尽量在调用方进行控制, 避免死锁的出现。

### 3.4.4 死锁的避免

> 1. 在程序中, 操作多张表时, 尽量以相同的顺序来访问 (避免形成等待环路) 
> 2. 批量操作单张表数据的时候, 先对数据进行排序 (避免形成等待环路) 
> 3. 申请足够级别的锁, 如果要操作数据, 就申请排它锁
> 4. 尽量使用索引访问数据, 避免没有 where 条件的操作, 避免锁表
> 5. 如果可以, 大事务化成小事务
> 6. 使用等值查询而不是范围查询查询数据, 命中记录, 避免间隙锁对并发的影响

## 3.5 参考
[InnoDB锁](https://gitee.com/zms0803/java-docs/blob/master/summaries/mysql/locks.md)  
[深入剖析 MySQL 自增锁](https://www.bilibili.com/read/cv11517598)  
[innodb锁机制探究(三)---插入意向锁](https://cloud.tencent.com/developer/article/1539992)  
[MySQL数据库InnoDB引擎行级锁锁定范围详解](https://segmentfault.com/a/1190000013307132)