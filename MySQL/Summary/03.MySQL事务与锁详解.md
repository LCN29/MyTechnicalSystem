# 3 MySQL事务与锁详解

## 3.1 数据库事务

### 3.1.1 事务定义

事务是数据库管理系统 (DBMS) 执行过程中的一个逻辑单位, 由一个有限的数据库操作序列构成, 这些操作要么都做, 要么都不做, 是一个不可分割的工作单位。

事务是数据库最小的工作单元, 是不可以再分的, 可能包含了一个或者一系列的 DML 语句。

### 3.1.2 事务的四大特性

事务的四大特性: ACID

**Atomicity (原子性)**  
对数据库的一系列的操作, 要么都是成功, 要么都是失败, 不可能出现部分成功或者部分失败的情况。  

以转账的场景为例, 一个账户的余额减少, 对应一个账户的增加, 这两个一定是同时成功或者同时失败的。

在 InnoDB 里面是通过 undo log 来实现的, 它记录了数据修改之前的值 (逻辑日志) , 一旦发生异常, 就可以用 undo log 来实现回滚操作

**consistent (一致性)**  
数据库的完整性约束没有被破坏, 事务执行的前后都是合法的数据状态。

比如说转账的这个场景, A 账户余额减少 1000, B 账户余额只增加了 500, 这个时 候因为两个操作都成功了, 按照我们对原子性的定义, 它是满足原子性的, 但是它没有 满足一致性, 因为它导致了会计科目的不平衡。

**Isolation (隔离性)**
多个事务, 对表或者行的并发操作, 是透明的, 互相不干扰的, 一个未完成事务不会影响另外一个未完成事务。

**Durable (持久性)**  
一旦一个事务被提交, 它应该持久保存, 不会因为与其他操作冲突而取消这个事务。

持久性是通过 redo log 和 double write 双写缓冲来实现的。  
我们操作数据的时候, 会先写到内存的 buffer pool 里面, 同时记录 redo log, 如果在刷盘之前出现异常, 在重启后就可以读取 redo log 的内容, 写入到磁盘, 保证数据的持久性。  
恢复成功的前提是数据页本身没有被破坏, 是完整的, 这个通过双写缓冲 (double write) 保证。

### 3.1.3 数据库什么时候会出现事务

**自动开启和自动提交**

```sql
update 表名 set 字段 = 值 where 条件;
```

上面的 SQL 会自动开启了一个事务, 并且自动提交了, 所以最终写入了磁盘。  

这种行为是通过 InnoDB 里面有一个 autocommit 的参数 (`show variables like 'autocommit';`) 控制的, 它的默认值是 on/true, 表示在操作数据的时候, 会自动开启一个事务, 和自动提交事务。

**手动开启和手动提交**

把 autocommit 设置成 false/off, 那么数据库的事务就需要我们手动开启和手动结束。

手动开启事务的方法
> 1. begin
> 2. start transcation

手动提交事务/手动撤销事务
> 1. commit
> 2. rollback
> 3. 客户端的连接断开的时候, 事务也会结束

### 3.1.4 事务并发会带来的问题

#### 3.1.4.1 脏读

如图: 

![Alt 'DirtyRead'](https://raw.githubusercontent.com/PictureRespository/MySQL/main/picture/DirtyRead.png)

> 1. Transcation A 查询 id = 1 的记录的 age = 16
> 2. Transcation B 更新 id = 1 的记录的 age = 18, 但是还未提交事务
> 3. Transcation A 再次查询 id = 1 的记录的 age = 18

在一个事务里面, 由于其他的事务修改了数据并且没有提交, 而导致了前后两次读取数据不一致的情况, 这种事务并发的问题叫做 **脏读**

#### 3.1.4.2 不可重复读

如图: 

![Alt 'NonrepeatableRead'](https://raw.githubusercontent.com/PictureRespository/MySQL/main/picture/NonrepeatableRead.png)

> 1. Transcation A 查询 id = 1 的记录的 age = 16
> 2. Transcation B 更新 id = 1 的记录的 age = 18, 并且提交了事务
> 3. Transcation A 再次查询 id = 1 的记录的 age = 18

一个事务里面, 读取到了其他事务已提交的数据导致前后两次读取数据不一致的情况, 这种事务并发的问题叫做 **不可重复读**

#### 3.1.4.2 幻读

如图:

![Alt 'PhantomRead'](https://raw.githubusercontent.com/PictureRespository/MySQL/main/picture/PhantomRead.png)

> 1. Transcation A 查询 age > 15 的记录总条数的 count = 1
> 2. Transcation B 插入了一条 age = 18 的记录, 并且提交了事务
> 3. Transcation A 再次查询 age > 15 的记录总条数的 count = 2

一个事务里面, 由于其他事务插入数据导致前后两次读取数据数据不一致, 这种事务并发的问题叫做 **幻读**

幻读和不可重复读的区别:
> 1. 不可重复读强调的是记录的修改
> 2. 幻读强调的集合的增减


事务并发带来的三大问题, 无论是脏读, 还是不可重复读, 还是幻读, 它们都是数据库的**读一致性**的问题, 都是在一个事务里面前后两次读取出现了不一致的情况。
读一致性的问题, 必须要由数据库提供一定的事务隔离机制来解决。


### 3.1.5 SQL92 标准

数据库厂商都按照这个标准, 提供一定的事务隔离级别, 来解决事务并发的问题。 

SQL92 里面定义了四个隔离级别
> 1. Read Uncommitted (未提交读) :, 一个事务可以读取到其 他事务未提交的数据, 会出现脏读, 它没有解决任何的问题
> 2. Read Committed (已提交读) : 一个事务只能读取到其他事务已提交的数据, 不能读取到其他事务未提交的数据, 它解决了脏读的问题, 但是会出现不可重复读的问题
> 3. Repeatable Read (可重复读): 在同一个事务里面多次读取同样的数据结果是一样的, 它解决了不可重复读的问题, 但是会出现幻读的问题
> 4. Serializable (串行化) : 在这个隔离级别里面, 所有的事务都是串 行执行的, 也就是对数据的操作需要排队, 已经不存在事务的并发操作了, 所以它解决了所有的问题

这个是 SQL92 的标准, 但是不同的数据库厂商或者存储引擎的实现有一定的差异, 比如 Oracle 里面就只有两种 RC (已提交读) 和 Serializable (串行化) 

### 3.1.6 MySQL InnoDB 对隔离级别的支持

在 MySQL InnoDB 里面, 不需要使用串行化的隔离级别去解决所有问题。

| 事务隔离级别 | 脏读 | 不可重复读 | 幻读 |
| :-: | :-: |  :-:|  :-:  |
| 未提交读 (Read Uncommitted)  |  可能 | 可能  |  可能  |
| 已提交读 (Read Committed) |  不可能 | 可能   |  可能  |
| 可重复读 (Repeatable Read) | 不可能  | 不可能   |  对 InnoDB 不可能  |
| 串行化 (Serializable) |  不可能 |  不可能  | 不可能  |

InnoDB 支持的四个隔离级别和 SQL92 定义的基本一致, 隔离级别越高, 事务的并发度就越低。唯一的区别就在于, InnoDB 在 RR 的级别就解决了幻读的问题。  
这个也是 InnoDB 默认使用 RR 作为事务隔离级别的原因, 既保证了数据的一致性, 又支持较高的并发度。

### 3.1.7 两大实现方案

要解决读一致性的问题, 保证一个事务中前后两次读取数据结果一致, 实现事务隔离, 应该怎么做?

#### 3.1.7.1 LBCC

要保证前后两次读取数据一致, 那么读取数据的时候, 锁定要操作的数据, 不允许其他的事务修改就行了。这种方案叫做基于锁的并发控制 Lock Based Concurrency Control (LBCC) 。  
如果仅仅是基于锁来实现事务隔离, 一个事务读取的时候不允许其他时候修改, 那就意味着不支持并发的读写操作, 而我们的大多数应用都是读多写少的, 这样会极大地影响操作数据的效率。

#### 3.1.7.2 MVCC

要让一个事务前后两次读取的数据保持一致, 那么可以在修改数据的时候给它建立一个备份或者叫快照, 后面再来读取这个快照就行了。  
这种方案叫做多版本的并发控制 Multi Version Concurrency Control (MVCC) 。

MVCC 的核心思想是: 可以查到在这个事务开始之前已经存在的数据, 即使它在后面被修改或者删除了。在这个事务之后新增的数据, 是查不到的。

**MVCC 的实现**

InnoDB 为每行记录都实现了三个隐藏字段
> 1. DB_ROW_ID: 6 个字节, 行标识
> 2. DB_TRX_ID: 6 个字节, 插入或更新行的最后一个事务的事务 ID, 事务编号是自动递增的 (我们把它理解为创建版本号, 在数据新增或者修改为新数据的时候, 记录当前事务 ID) 
> 3. DB_ROLL_PTR: 7 个字节, 回滚指针 (我们把它理解为删除版本号, 数据被删除或记录为旧数据的时候, 记录当前事务 ID) 

如图: 
![Alt 'MVCCSimpleModel'](https://raw.githubusercontent.com/PictureRespository/MySQL/main/picture/MVCCSimpleModel.png)

如上面的演示, 通过版本号的控制, 无论其他事务是插入 / 修改 / 删除, 第一个事务查询到的数据都没有变化。

在 InnoDB 中, MVCC 是通过 Undo log 实现的, MVCC 和锁是协同使用的。  
Oracle, Postgres 等等其他数据库都有 MVCC 的实现。  

### 3.1.8 支持事务的存储引擎
> 1. InnoDB
> 2. NDB


## 3.2 MySQL InnoDB 锁的基本类型

官网把锁分成了 8 大类
> 1. Shared and Exclusive Locks
> 2. Intention Locks
> 3. Record Locks
> 4. Gap Locks
> 5. Next-Key Locks
> 6. Insert Intention Locks
> 7. AUTO-INC Locks
> 8. Predicate Locks for Spatial Indexes

2 个行级锁 (Shared and Exclusive Locks) 和 2 个表级锁 (Intention Locks) 可以成为锁的基本模式。  
Record Locks、Gap Locks、Next-Key Locks 可以成为锁的算法, 也就是分别在什么情况下锁定什么范围。

### 3.2.1 锁粒度

表锁: 锁住一张表, 行锁: 锁住表里面的一行数据。  
> 1. 从锁定粒度上看, 表锁肯定是大于行锁的。
> 2. 从加锁效率上看, 表锁快于行锁。表锁只需要直接锁住这张表就行了, 而行锁, 还需要在表里面去检索这一行数据
> 3. 从冲突的概率上看, 表锁大于行锁。在表锁上, 其他任何一个事务都不能操作这张表。 但是行锁, 其他的事务还可以来操作表里面其他的行数据

注: MyISAM 只支持表级锁。

### 3.2.2 共享锁

Shared Locks (共享锁) , 获取了一行数据的读锁以后, 可以用来读取数据, 所以它也叫做读锁, 多个事务可以共享一把读锁。  
注意不要在加上了读锁以后去写数据, 不然的话可能会出现死锁的情况。  

可以用 `select …… lock in share mode` 的方式手动加读锁, 只要事务结束, 锁就会自动释放

### 3.2.3 排他锁

Exclusive Locks (排它锁), 用来操作数据的, 所以又叫做写锁。只要一个事务获取了一行数据的排它锁, 其他的事务就不能再获取这一行数据的共享锁和排它锁

排它锁的加锁方式有两种
> 1. 自动加排它锁, 在操作数据的时候, 包括增删改, 都会默认加上一个排它锁
> 2. 手工加排它锁, 可以用一个 `FOR UPDATE` 给一行数据加上一个排它锁

### 3.2.4 行锁的原理

**场景一**  
假设当前有一张表 t1, 有 2 个字段: int 类型的 id 和 varchar 类型的 name, 表中没有任何的索引。 表中已经有 2 条数据

> 1. 事务 A : `select * from t1 where id = 1 for update;`, 锁住 id = 1 的行
> 2. 事务 B: `select * from t1 where id = 2 for update;`, 这时候加锁失败, 阻塞住了
> 3. 事务 C : `insert into t1 values(3, 'test')`, 这时候插入失败, 同样阻塞住了

**场景二** 

假设当前有一张表 t1, 有 2 个字段: int 类型的 id 和 varchar 类型的 name, 表中的 id 是主键索引。表中已经有 2 条数据

> 1. 事务 A : `select * from t1 where id = 1 for update;`, 锁住 id = 1 的行
> 2. 事务 B : `select * from t1 where id = 1 for update;`, 尝试锁住 id = 1 的行失败, 阻塞住
> 3. 事务 C : `select * from t1 where id = 2 for update;`, 尝试锁住 id = 2 的行, 成功

**场景三**  

假设当前有一张表 t1, 有 2 个字段: int 类型的 id 和 varchar 类型的 name, 表中的 id 是主键索引, name 是唯一索引。表中已经有 2 条数据

> 1. 事务 A : `select * from t1 where name = 'one' for update;`, 锁住 name = one 的行
> 2. 事务 B : `select * from t1 where name = 'one' for update;`, 尝试锁住 name = one 的行失败, 阻塞住
> 3. 事务 C : `select * from t1 where id = 1 for update;`, 尝试锁住 id = 1 的行失败, 阻塞住

通过上面的情景可以得到:   

InnoDB 的行锁, 既不是锁行记录, 也不是锁字段, 而是就是通过锁住索引来实现的。

**为什么表里面没有索引的时候, 锁住一行数据会导致锁表 (一张表有没有可能没有索引)**

索引的定义
> 1. 如果我们定义了主键 (PRIMARY KEY), 那么 InnoDB 会选择主键作为聚集索引
> 2. 如果没有显式定义主键, 则 InnoDB 会选择第一个不包含有 NULL 值的唯一索引作为主键索引
> 3. 如果也没有这样的唯一索引, 则 InnoDB 会选择内置 6 字节长的 ROWID 作为隐藏的聚集索引, 它会随着行记录的写入而主键递增

所以查询没有使用索引, 会进行全表扫描, 然后把每一个隐藏的聚集索引都锁住了。

**为什么通过唯一索引给数据行加锁, 主键索引也会被锁住**

通过辅助索引进行查询数据时, 先在辅助索引里面找到对应的主键的值, 然后再在主键索引里面查询数据。  
所以我们通过辅助索引锁定一行数据的时候, 它跟我们检索数据的步骤是一样的, 会通过主键值找到主键索引, 然后锁定。

### 3.2.4 意向锁 

意向锁是由数据库自己维护的
> 1. 给一行数据加上共享锁之前, 数据库会自动在这张表上面加一个意向共享锁 (Intention Sharded Lock, 简称 IS 锁)
> 2. 给一行数据加上排他锁之前, 数据库会自动在这张表上面加一个意向排他锁 (Intention Exclusive Lock, 简称 IX 锁)

也就是说:  
> 1. 如果一张表上面至少有一个意向共享锁, 说明有其他的事务给其中的某些数据行加上了共享锁。  
> 2. 如果一张表上面至少有一个意向排他锁, 说明有其他的事务给其中的某些数据行加上了排他锁

两个表级别的锁存在
> 1. 有了表级别的锁, 在 InnoDB 里面就可以支持更多粒度的锁。
> 2. 可以把它理解成一个标志, 是用来提高加锁的效率的。 比如如果要给一张表加表锁, 那么就需要判断是否有行锁, 必须先要去判断有没其他的事务锁定了其中了某些行, 有了意向锁这个标志, 就可以不去遍历行

### 3.2.5 锁算法

假设当前有一张表 t, 有 2 个字段: int 类型的 id 和 varchar 类型的 name, id 是主键索引。  
表中当前有 4 条数据, id 分别为 1，4，7，10.

![Alt 'Record'](https://raw.githubusercontent.com/PictureRespository/MySQL/main/picture/Record.png)

数据库里面存在的主键值，把它叫做 Record, 记录，这里有 4 个 Record

![Alt 'Gap'](https://raw.githubusercontent.com/PictureRespository/MySQL/main/picture/Gap.png)

根据主键，这些存在的 Record 隔开的数据不存在的区间，叫做 Gap，间 隙，它是一个左开右开的区间。

![Alt 'Next-Key'](https://raw.githubusercontent.com/PictureRespository/MySQL/main/picture/NextKey.png)

间隙（Gap）连同它左边的记录（Record），叫做临键的区间， 它是一个左开右闭的区间。

#### 3.2.5.1 Record Lock - 记录锁

对唯一性的索引 (包括唯一索引和主键索引) 使用等值查询, 精确匹配到一条记录的时候, 这个时候使用的就是记录锁。

记录锁的表现： 使用不同的 key 加锁, 它只锁住这条 record

#### 3.2.5.2 Gap Lock - 间隙锁

当查询的记录不存在, 没有命中任何一条 record, 无论是等值查询还是范围查询, 都会使用间隙锁。
间隙锁主要是阻塞插入 insert, 相同的间隙锁之间不冲突。

例子：
> 1. 事务 A: `select * from t where id = 6 for update;`, 找不到, 导致 4 - 7 进行出现间隙锁
> 2. 事务 B: `insert into t ('id', 'name') values(5, 'name');` 在 4 - 7 之间有间隙锁, 插入失败
> 3. 事务 C: `select * from t where id = 6 for update;`, 查询结果为空, 没有被阻塞

Gap Lock 只在 RR 中存在。如果要关闭间隙锁， 可以把事务隔离级别设置为 RC, 并且把 innodb_locks_unsafe_for_binlog 设置为 on。  
这时候除了外键约束和唯一性检查会加间隙锁，其他情况都不会用间隙锁。

#### 3.2.5.3 Next-Key Lock - 临键锁

使用范围查询, 不仅命中了 Record, 还包含了 Gap 间隙, 这时候使用的是临键锁。他说 MySQL 里面默认的行锁算法，相当于记录锁加上间隙锁。
例如: where id > 5 and id < 9, 命中了记录 7, 同时有 4 - 7 和 7 - 10 的 2 个间隙。

临键锁会进行退化
> 1. 使用唯一性索引, 通过等值查询匹配到 1 条记录, 退化为记录锁
> 2. 没有匹配到任何记录的时候, 退化成间隙锁。
