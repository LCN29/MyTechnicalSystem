# 1 MySQL 体系结构

## 1.1 查询 SQL 执行过程

![Alt 'SelectProcessorInMySQL'](https://raw.githubusercontent.com/PictureRespository/MySQL/main/picture/SelectProcessorInMySQL.png)

如图, 就是一条查询 SQL 语句的执行过程

### 1.1.1 连接

客户端和服务器建立连接。

#### 1.1.1.1 通信协议

MySQL 是支持多种通信协议的,可以使用同步/异步的方式, 支持长连接/短连接。

##### 1.1.1.1.1 通信类型: 同步或者异步

同步通信的特点: 
> 1. 同步通信依赖于被调用方, 受限于被调用方的性能。也就是, 应用操作数据库, 线程会阻塞, 等待数据库的返回
> 2. 一般只能做到一对一, 很难做到一对多的通信


异步通信的特点:
> 1. 异步可以避免应用阻塞等待, 但是不能节省 SQL 执行的时间
> 2. 如果异步存在并发, 每一个 SQL 的执行都要单独建立一个连接,避免数据混乱。

异步通信会会给服务端带来巨大的压力 (一个连接就会创建一个线程, 线程间切换会占用 大量 CPU 资源)。  
另外异步通信还带来了编码的复杂度, 所以一般不建议使用。如果要异步, 必须使用连接池, 排队从连接池获取连接而不是创建新连接。  
一般来说我们连接数据库都是同步连接。

##### 1.1.1.1.2 连接方式: 长连接或者短连接

MySQL 既支持短连接, 也支持长连接。  
短连接就是操作完毕以后, 马上 close 掉。长连接可以保持打开, 减少服务端创建和释放连接的消耗, 后面的程序访问的时候还可以使用这个连接。  

一般我们会在连接池中使用长连接, 保持长连接会消耗内存。长时间不活动的连接,MySQL 服务器会断开, 默认都是 28800 秒, 8 小时

```sh
# 非交互式超时时间,如 JDBC 程序
show global variables like 'wait_timeout';

# 交互式超时时间,如数据库工具
show global variables like 'interactive_timeout';
```

##### 1.1.1.1.3 连接线程

查看 MySQL 当前有多少个线程

```sh
show global status like 'Thread%';
```

|  线程变量名 | 含义 |
| :-: | :-:|
| Threads_cached| 缓存中的线程连接数|
| Threads_connected | 当前打开的连接数|
| Threads_created| 已经创建的线程数, 一般 treads_cached 和 treads_connected 参数之和, 当并发数高的情况下, Threads_created 就会暴增, 这时可以适当提高 thread_cache_size 的大小|
| Threads_running| 非睡眠状态的连接数,通常指并发连接数|


也可以通过在 root 的情况下通过 **SHOW PROCESSLIST;**, 查看所有的线程状态

查询结果中的 **State** 一些常见的状态

| State | 状态|
| :-: | :-:|
| Sleep| 线程正在等待客户端,向它发送一个新语句|
| Query | 线程正在执行查询或往客户端发送数据|
| Locked| 该查询被其它查询锁定|
| Copying to tmp table on disk | 临时结果集合大于 tmp_table_size。线程把临时表从存储器内部格式改变为磁盘模式, 以节约存储器 |
| Sending data | 线程正在为 SELECT 语句处理行, 同时正在向客户端发送数据 |
| Sorting for group | 线程正在进行分类,以满足 GROUP BY 要求|
| Sorting for order | 线程正在进行分类,以满足 ORDER BY 要求|

MySQL 服务允许的最大连接数是 151 个, 最大可以设置成 16384 (2^14)


##### 1.1.1.1.4 通信协议

MySQL 支持的协议

**Unix Socket**  
在 Linux 中登录 MySQL 的命令行客户端, 如果没有指定 -h 参数, 它就用 socket 方式登录 (省略了 -S /var/lib/mysql/mysql.sock)。    
可以不用通过网络协议, 就连接到 MySQL 的服务器, 它需要用到服务器上的一个物理文件 (/var/lib/mysql/mysql.sock)。
具体的位置可以通过 **/tmp/mysql.sock** 查看 mysql.sock 的位置。

**TCP/IP 协议**
在 Linux 中登录 MySQL 的命令行客户端, 如果指定了 -h 参数, 就会用 TCP/IP 协议。  
一般在应用程序中都是以 TCP/IP 协议连接的。

**Named Pipes** 和 **Share Memory**  
这两种通信方式只能在 Windows 上面使用,一般用得比较少

#### 1.1.1.2 通信方式

> 1. 单工: 在两台计算机通信的时候,数据的传输是单向的
> 2. 半双工: 在两台计算机之间,数据传输是双向的,你可以给我发送,我也可以给你发送, 但是在这个通讯连接里面,同一时间只能有一台服务器在发送数据
> 3. 全双工: 数据的传输是双向的, 并且可以同时传输


**MySQL 使用了半双工的通信方式**  

要么是客户端向服务端发送数据,要么是服务端向客户端发送数据,这两个动作不能同时发生。  
所以客户端发送 SQL 语句给服务端的时候, (在一次连接里面) 数据是不能分成小块发送的, 不管你的 SQL 语句有多大, 都是一次性发送。  
这种情况可能会影响到 insert 多条数据, where in 很多的情况等, 这时候可以通过 max_allowed_packet 参数的值 (默认值为 4 M), 提高单次传送的数据上限。



### 1.1.2 查询缓存

MySQL 内部自带了一个缓存模块, 但是这个缓存模块默认是默认是关闭的。

可以通过 
```sh
show variables like 'query_cache%';
```
进行查看。

MySQL 不推荐使用它自带的缓存的原因: 
> 1. MySQL 自带的缓存的应用场景有限, 第一个是它要求 SQL 语句必须一模一样, 中间多一个空格, 字母大小写不同都被认为是不同的的 SQL
> 2. 第二个是表里面任何一条数据发生变化的时候, 这张表所有缓存都会失效, 所以对于有大量数据更新的应用, 也不适合

在 MySQL 8.0 中, 查询缓存已经被移除了。

### 1.1.3 语法解析和预处理 ((Parser & Preprocessor)  

对客户端的语句基于 SQL 语法进行词法和语法分析和语义的解析

#### 1.1.3.1 词法解析

把一个完整的 SQL 语句打碎成一个个的单词

```SQL
select name from user where id = 1 and age > 10;
```

它会打碎成 12 个符号, 每个符号是什么类型, 从哪里开始到哪里结束。

#### 1.1.3.2 语法解析

对 SQL 做一些语法检查, 比如单引号有没有闭合, 然后根据 MySQL 定义的语法规则, 根据 SQL 语句生成一个解析树 (select_lex)。

![Alt 'SelectSQLSelectLexDemo'](https://raw.githubusercontent.com/PictureRespository/MySQL/main/picture/SelectSQLSelectLexDemo.png)

任何数据库的中间件, 比如 Mycat, Sharding-JDBC (用到了 Druid Parser) , 都 必须要有词法和语法分析功能, 在市面上也有很多的开源的词法解析的工具 (比如 LEX, Yacc) 。

#### 1.1.3.3 预处理器

解析器可以分析语法, 但是 SQL 的格式是完全正确的, 但是查询的表或者字段不存在的情况, 在解析节点还是会直接报错的。
解析 SQL 的环节里面有个预处理器。它会检查生成的解析树, 解决解析器无法解析的语义。比如, 它会检查表和列名是否存在, 检查名字和别名, 保证没有歧义。预处理之后得到一个新的解析树。

### 1.1.4 查询优化 (Query Optimizer) 与查询执行计划

一条 SQL 语句是可以有很多种执行方式的, 这些执行方式最终都会返回相同的结果, 他们是等价的。 一条 SQL 语句最终的执行方式是由 MySQL 的查询优化器模块 (Optimizer) 选择的。
查询优化器的目的就是根据解析树生成不同的执行计划 (Execution Plan) , 然后选择一种最优的执行计划, MySQL 里面使用的是基于开销 (cost) 的优化器, 那种执行计划开销最小, 就用哪种。  
在 MySQL 中可以通过 **show status like 'Last_query_cost'** 查看上一个查询的代价。

**优化器可以做什么**

> 1. 多张表进行关联查询的时候, 以哪个表的数据作为基准表
> 2. 有多个索引可以使用的时候, 选择哪个索引
> 3. 等等

具体的可以看 《数据库查询优化器的艺术-原理解析与SQL性能优化》 的内容。

优化器也不是万能的, 并不是再垃圾的 SQL 语句都能自动优化, 也不是每次都 能选择到最优的执行计划


**优化器如何获取到执行计划**

可以启用优化器的追踪 (默认是关闭的) , 进行查看

```sh
SHOW VARIABLES LIKE 'optimizer_trace'; 

# 这里只在当前的 session 开启, 如果需要全局开启, 可以加上 global
set optimizer_trace='enabled=on';
```

开启这开关是会消耗性能的, 因为它要把优化分析的结果写到表里面, 所以不要轻易开启, 或者查看完之后关闭它 (改成 off) 。

优化分析结果的查询, 可以通过下面的 SQL 进行查询
```sh
select * from information_schema.optimizer_trace;
```

它是一个 JSON 类型的数据, 主要分成三部分, 准备阶段、优化阶段和执行阶段。

优化器最终会把解析树变成一个查询执行计划, 查询执行计划是一个数据结构。  
这个执行计划依旧还不一定是最优的执行计划, MySQL 可 能覆盖不到所有的执行计划。

可以通过 **explain + 查询的 SQL 语言**, 得到优化器优化后可能执行的执行计划。

### 1.1.5 存储引擎

在关系型数据库里面, 数据是放在表 Table 里面的, 这个表理解成 Excel 电子表格的形式。所以表在存储数据的同时, 还要组织数据的存储结构, 这个存储结构就是由存储引擎决定的, 所以可以把存储引擎叫做表类型。  
在 MySQL 里面, 支持多种存储引擎, 他们是可以替换的, 所以叫做插件式的存储引擎。

```sql
show table status from `数据库`;
```

可以通过上面的 SQL 查看数据库中表的一部分信息, 其中的 Engine 字段可以查看到表使用的存储引擎。

一张表使用的存储引擎决定我们存储数据的结构, 那在服务器上它们是怎么存储的呢?
> 1. 先通过 **show variables like 'datadir';**, 查看当前数据库的文件保存路径
> 2. cd 到对应的目录, 可以看到下面通过表名命名的各种文件。

可以看到 innodb 引擎的表只有 1 个文件, memory 没有, myisam 是两个文件。

#### 1.1.5.1 存储引擎比较

可以通过 **show engines;** 查看当前的 MySQL 支持哪些存储引擎, 和支持的引擎的描述, 是否还支持事务, 对 XA 协议和 Savepoints 的支持
> 1.  XA 协议: 用来实现分布式事务 (分为本地资源管理器, 事务管理器)
> 2. Savepoints: 用来实现子事务 (嵌套事务) 。创建了一个 Savepoints 之后, 事务 就可以回滚到这个点, 不会影响到创建 Savepoints 之前的操作

**MyISAM**  

应用范围比较小。表级锁定限制了读/写的性能, 因此在 Web 和数据仓库配置中, 它通常用于只读或以读为主的工作。

特点: 
> 1. 支持表级别的锁 (插入和更新会锁表), 不支持事务。
> 2. 拥有较高的插入 (insert) 和查询 (select) 速度
> 3. 存储了表的行数 (count 速度更快) 
> 4. 不支持外键约束, 但支持全文索引

适合: 只读之类的数据分析的项目。

**InnoDB**  

Mysql 5.7 中的默认存储引擎。InnoDB 是一个事务安全 (与 ACID 兼容) 的 MySQL 存储引擎, 它具有提交、回滚和崩溃恢复功能来保护用户数据。  
InnoDB 行级锁 (不升级为更粗粒度的锁) 和 Oracle 风格的一致非锁读提高了多用户并发性和性能。InnoDB 将用户数据存储在聚集索引中, 以减少基于主键的常见查询的 I/O。
为了保持数据完整性, InnoDB 还支持外键引用完整性约束。

特点: 
> 1. 支持事务, 支持外键, 因此数据的完整性、一致性更高
> 2. 支持行级别的锁和表级别的锁
> 3. 支持读写并发, 写不阻塞读 (MVCC) 。
> 4. 特殊的索引存放方式, 可以减少 IO, 提升查询效率 - 聚集索引

适合: 经常更新的表, 存在并发读写或者有事务处理的业务系统。

**Memory**

将所有数据存储在 RAM 中, 以便在需要快速查找非关键数据的环境中快速访问。

特点: 
> 1. 把数据放在内存里面, 读写的速度很快, 但是数据库重启或者崩溃, 数据会全部消失, 只适合做临时表
> 2. 将表中的数据存储到内存中

**CSV**

它的表实际上是带有逗号分隔值的文本文件。csv 表允许以 csv 格式导入或转储数据, 以便与读写相同格式的脚本和应用程序交换数据。csv 表没有索引。

特点: 
> 1. 不允许空行, 不支持索引。
> 2. 格式通用, 可以直接编辑, 适合在不同数据库之间导入导出。

**Archive**  

这些紧凑的未索引的表用于存储和检索大量很少引用的历史、存档或安全审计信息

特点: 
> 1. 不支持索引
> 2. 不支持 update delete

#### 1.1.5.2 如何选择存储引擎 

如果对数据一致性要求比较高, 需要事务支持, 可以选择 InnoDB  
如果数据查询多更新少, 对查询性能要求比较高, 可以选择 MyISAM  
如果需要一个用于查询的临时表, 可以选择 Memory  

### 1.1.6 执行引擎 (Query Execution Engine), 返回结果

存储引擎是存储数据的形式, 而从存储引擎中获取数据的就是执行引擎了。  
它利用存储引擎提供的相应的 API 来完成操作, 不同功能的存储引擎实现的 API 是相同的, 就如接口和实现类的关系。  
最后把数据返回给客户端, 即使没有结果也要返回











## 1.2 MySQL 架构总结

基于上面分析的流程, 我们一起来梳理一下 MySQL 的内部模块

### 1.2.1 MySQL 版本
> 1. MariaDB, 使用全新的 Maria 存储引擎, 它是原 MyISAM 存储引擎的升级版本
> 2. Percona Server, 基于 InnoDB 存储引擎的基础上, 提升了性能和易管理性, 最后形成了增强版的 XtraDB 引擎, 可以用来更好地发挥服务器硬件上的性能。 
> 3. 网易的 InnoSQL
> 4. 极数云舟的 ArkDB

### 1.2.2 模块介绍

![Alt 'MySQLSystemStructure'](https://raw.githubusercontent.com/PictureRespository/MySQL/main/picture/MySQLSystemStructure.png)

> 1. Connector: 用来支持各种语言和 SQL 的交互, 比如 PHP, Python, Java 的 JDBC 等
> 2. Management Serveices & Utilities: 系统管理和控制工具, 包括备份恢复、MySQL 复制、集群等等
> 3. Connection Pool: 连接池, 管理需要缓冲的资源, 包括用户密码权限线程等
> 4. SQL Interface: 用来接收用户的 SQL 命令, 返回用户需要的查询结果
> 5. Parser: 用来解析 SQL 语句
> 6. Optimizer: 查询优化器
> 7. Cache and Buffer: 查询缓存, 除了行记录的缓存之外, 还有表缓存, Key 缓存, 权限缓存等等
> 8. Pluggable Storage Engines: 插件式存储引擎, 它提供 API 给服务层使用, 跟具体的文件打交道


上面的结构可以简化为下面的分层
![Alt 'MySQLSimpleSystemStructure'](https://raw.githubusercontent.com/PictureRespository/MySQL/main/picture/MySQLSimpleSystemStructure.png)

> 1. 跟客户端对接的连接层
> 2. 真正执行操作的服务层
> 3. 和跟硬件打交道的存储引擎层

#### 1.2.2.1 连接层

客户端要连接到 MySQL 服务器 3306 端口, 必须要跟服务端建立连接, 那么 管理所有的连接, 验证客户端的身份和权限, 这些功能就在连接层完成

### 1.2.2.2 服务层

连接层会把 SQL 语句交给服务层, 这里面又包含一系列的流程: 

比如查询缓存的判断、根据 SQL 调用相应的接口, 对我们的 SQL 语句进行词法和语 法的解析 (比如关键字怎么识别, 别名怎么识别, 语法有没有错误等等) 。  
然后就是优化器, MySQL 底层会根据一定的规则对我们的 SQL 语句进行优化, 最 后再交给执行器去执行

### 1.2.2.3 存储引擎层

存储引擎就是数据真正存放的地方, 在 MySQL 里面支持不同的存储引擎, 再往下就是内存或者磁盘。









## 1.3 更新 SQL 执行过程

在数据库里面, update 操作其实包括了更新, 插入和删除。  
基本流程和查询流程差不多，也就是说，它也要经过解析器、优化器的处理，最后交给执行器, 区别就在于拿到符合条件的数据之后的操作。

### 1.3.1 缓冲池 （Buffer Pool） 
