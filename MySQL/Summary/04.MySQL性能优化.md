# 4 MySQL 性能优化

## 4.1 连接 - 配置优化

客户端连接服务端
> 1. 服务端连接数不够导致应用程序获取不到连接, 报 `MySQL:error 1040: TooMany connections`
> 2. 客户端长期持有连接, 但是空闲不释放, 导致连接不够

**从服务端来说, 可以增加服务端的可用连接数**
> 1. 修改配置参数增加可用连接数, 修改 max_connections 的大小 `show variables like 'max_connections';`
> 2. 及时释放不活动的连接, 交互式和非交互式的客户端的默认超时时间都是 28800 秒, 8 小时, 适当调小 `show global variables like 'wait_timeout';`

**从客户端来说, 可以减少从服务端获取的连接数, 通过连接池实现连接重用**

1. 连接池的选择

> 1. MyBatis 自带的连接池
> 2. 专门的连接池工具: 阿里的 Druid, SpringBoot 2.x 默认的 Hikari


2. 连接池的配置

Druid 连接池的默认的大小为 8, Hikari 连接池的默认的大小为 10。

Hikari 的 Github [文档](https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing)中, 给出了一个 PostgreSQL 数据库建议的设置连接池大小公式为 **机器核数乘以 2 加 1**。  
也就是说, 4 核的机器, 连接池维护 9 个连接就 够了。 这个公式适用于其他的数据库。

在不同的硬件环境下, 操作系统和 MySQL 的参数的配置是不同的, 没有标准的配置。  
MySQL 提供了大量的配置参数, 这些参数大部分都提供了默认值, 这些默认参数可以满足大部分情况的需求, 除非特殊的需求, 否则这些参数交由专业的 DBA 配置。  
至于硬件本身的选择, 比如使用固态硬盘, 搭建磁盘阵列, 选择特定的 CPU 型号这些, 不是开发应该关注的。

## 4.2 缓存-架构优化

### 4.2.1 缓存

在应用系统的并发数非常大的情况下, 如果没有缓存, 会造成两个问题
> 1. 会给数据库带来很大的压力
> 2. 操作数据的速度也会受到影响

这些可以通过引入第三方的缓存服务来解决问题, 比如 Redis 等。运行独立的缓存服务, 属于架构层面的优化。  
为了减少单台数据库服务器的读写压力, 在架构层面我们还可以做哪些优化措施？

### 4.2.2 主从复制

如果单台数据库服务满足不了访问需求, 那我们可以做数据库的集群方案。集群必然存在一个问题: **不同的节点直接数据一致性**。  

使用 MySQL 的复制技术 (replication), 被复制的节点叫做 master, 复制的节点叫做 slave。 slave 本身也可以作为其他节点的数据来源, 这个叫做**级联复制**。  
Master 更新语句会记录到 binlog, 它是一种逻辑日志。  
有了 binlog, slave 会获取 Master 的 binlog 文件, 然后解析里面的 SQL 语句, 在 slave 上面执行一遍, 保持主从的数据一致。  

这里面涉及到 3 个线程
> 1. I/O 线程: 连接到 master 获取 binlog, 并且解析 binlog 写入中继日志 relay log
> 2. log dump 线程: master 用来发送 binlog 给 slave 的 
> 3. SQL 线程: 从库上面的线程, 用来读取 relay log, 把数据写入到数据库

做了主从复制的方案之后, 只需要把数据写入 master 节点, 而读的请求可以分担到 slave 节点, 这种方案叫做**读写分离**。  
读写分离可以一定程度低减轻数据库服务器的访问压力, 但是主从之间存在数据同步的阶段, 那么就存在主从节点之间存在数据不一致的问题

#### 4.2.2.1 MySQL 的主从复制慢的原因

##### 4.2.2.1.1 单线程单线程 

在早期的 MySQL 中, Slave 的 SQL 线程是单线程。master 可以支持 SQL 语句的并行执行, 配置了多少的最大连接数就是最多同时多少个 SQL 并行执行。  
而 slave 的 SQL 却只能单线程排队执行, 在主库并发量很大的情况下, 同步数据肯定会出现延迟。

单线程是为了确保在从库上执行的 SQL 顺序和主库的一致。 比如主库新增了一条数据, 更新了这条数据, 最后删除了这条数据。如果从库并发了执行了, 无法保证 SQL 的执行顺序。

##### 4.2.2.1.2 异步与全同步

在主从复制的过程中, MySQL 默认是**异步复制**的。 对于主节点来说, 写入 binlog, 事务结束, 就返回给客户端了。  
对于 slave 来说, 接收到 binlog, 就完事儿了, master 不关心 slave 的数据有没有写入成功。

为了解决主从数据同步的延迟, 主库可以等待全部从库的事务执行完毕, 才返回给客户端, 这种方式叫做 **全同步复制**。  
这种方式虽然可以保证在读之前, 数据已经同步成功了, 但是会导致事务执行的时间会变长, 它会导致 master 节点性能下降。

##### 4.2.2.1.3 半同步复制
主库在执行完客户端提交的事务后不是立刻返回给客户端, 而是等待至少一个从库接收到 binlog 并写到 relay log 中才返回给客户端。  
master 不会等待很长的时间, 但是返回给客户端的时候, 数据就即将写入成功, 因为 slave 节点只剩下最后一步: 读取 relay log, 写入数据库  

要在数据库里面用半同步复制, 必须安装一个插件, 主库安装 `semisync_master.so`, 从库安装 `semisync_slave.so`, 并进行相应的配置。

相对于异步复制, 半同步复制提高了数据的安全性, 同时它也造成了一定程度的延迟, 它需要等待一个 slave 写入中继日志, 这里多了一个网络交互的过程。  

所以, 半同步复制最好在低延时的网络中使用


##### 4.2.2.1.4 多库并行复制

在 MySQL 5.6 版本里面提供了一个新的技术**多库并行复制**。  

客户端提交了有多条 SQL, 这些 SQL 会分配到不同的数据上执行, 操作各自的数据库, 同样的这些数据库的数据库的从库的 SQL 变相的变成了并发执行了。

但是在大部分的情况下, 都是单库多表的情况, 不符合对应的使用场景。

##### 4.2.2.1.5 异步复制之 GTID 复制

把那些在主库上并行执行的事务, 分为一个组, 并且给他们编号, 这一个组的事务在从库上面也可以并行执行。  
这个编号, 我们把它叫做 GTID (Global Transaction Identifiers) , 这种主从复制的方式, 我们把它叫做基于 GTID 的复制。

可以通过开关 `show global variables like 'gtid_mode';` 开启功能。

### 4.2.3 分库分表

垂直分库: 按照业务将表进行分类, 分布到不同的数据库上面, 每个库可以放在不同的服务器上, 它的核心理念是专库专用
水平分库: 把同一个表的数据按一定规则拆到不同的数据库中, 每个库可以放在不同的服务器上


垂直分表: 将一个表按照字段分成多表, 每个表存储其中一部分字段
水平分表: 在同一个数据库内, 把同一个表的数据按一定规则拆到多个表中

通过主从或者分库分表可以减少单个数据库节点的访问压力和存储压力, 达到提升 数据库性能的目的


### 4.2.4 高可用方案

#### 4.2.4.1 主从复制
传统做法 在主从复制的条件下, 加上 HAProxy + keepalived。

#### 4.2.4.2 NDB Cluster 
基于 NDB 集群存储引擎的 MySQL Cluster, [官网介绍](https://dev.mysql.com/doc/mysql-cluster-excerpt/5.7/en/mysql-cluster-overview.html)

#### 4.2.4.3 Galera
一种多主同步复制的集群方案, [官网介绍](https://galeracluster.com/)

#### 4.2.4.4 MHA/MMM

MMM (Master-Master replication manager for MySQL) , 一种多主的高可用 架构, 是一个日本人开发的, 像美团这样的公司早期也有大量使用 MMM

MHA (MySQL Master High Available) 。

MMM 和 MHA 都是对外提供一个虚拟 IP, 并且监控主节点和从节点, 当主节点发 生故障的时候, 需要把一个从节点提升为主节点, 并且把从节点里面比主节点缺少的数 据补上, 把虚拟 IP 指向新的主节点。

[官网介绍](https://tech.meituan.com/2017/06/29/database-availability-architecture.html)


#### 4.2.4.5 MGR 

MySQL 5.7.17 版本推出的 InnoDB Cluster, 也叫 MySQL Group Replicatioin (MGR) , 这个套件里面包括了 mysql shell 和 mysql-route。

[官网介绍-1](https://dev.mysql.com/doc/refman/5.7/en/group-replication.html)  
[官方介绍-2](https://dev.mysql.com/doc/refman/5.7/en/mysql-cluster.html)


总结:  
高可用 HA 方案需要解决的问题都是当一个 master 节点宕机的时候, 如何提升一个 数据最新的 slave 成为 master。  
如果同时运行多个 master, 又必须要解决 master 之间 数据复制, 以及对于客户端来说连接路由的问题。   
不同的方案, 实施难度不一样, 运维管理的成本也不一样。


## 4.3 优化器 - SQL 语句分析与优化

### 4.3.1 慢查询日志 slow query log

#### 4.3.1.1 打开慢日志开关

因为开启慢查询日志是有代价的（跟 bin log、optimizer-trace 一样），所以它默认是关闭的： `show variables like 'slow_query%';`。   
除了这个开关，还有一个参数，控制执行超过多长时间的 SQL 才记录到慢日志，默认是 10 秒： `show variables like '%slow_query%';`。

修改配置文件 my.cnf  
```
slow_query_log = ON 
long_query_time=2 
slow_query_log_file =/var/lib/mysql/localhost-slow.log
```

除了修改配置文件的方式外, HIA可以动态修改参数(重启后失效):  
```sql
set @@global.slow_query_log=1; -- 1 开启，0 关闭，重启后失效
set @@global.long_query_time=3; -- mysql 默认的慢查询时间是 10 秒，另开一个窗口后才会查到最新值 
show variables like '%long_query%';
show variables like '%slow_query%';
```

#### 4.3.1.2 慢日志分析

##### 4.3.1.2.1 日志内容

```sql
show global status like 'slow_queries'; -- 查看有多少慢查询 
show variables like '%slow_query%'; -- 获取慢日志目录
```

得到路径后, 就可以通过 cat 之类的指令进行查看了

##### 4.3.1.2.2 mysqldumpslow

MySQL 提供了 mysqldumpslow 的工具，在 MySQL 的 bin 目录下, [使用文档](https://dev.mysql.com/doc/refman/5.7/en/mysqldumpslow.html)。

例如查询用时最多的 20 条慢 SQL
```
mysqldumpslow -s t -t 20 -g 'select' 慢SQL的文件全路径
```

查询结果中的
> Count 代表这个 SQL 执行了多少次
> Time 代表执行的时间，括号里面是累计时间
> Lock 表示锁定的时间，括号是累计
> Rows 表示返回的记录数，括号是累计。

### 4.3.2 SHOW PROFILE

SHOW PROFILE 是谷歌高级架构师 Jeremy Cole 贡献给 MySQL 社区的，可以查看SQL 语句执行的时候使用的资源，比如 CPU、IO 的消耗情况。 [使用文档](https://dev.mysql.com/doc/refman/5.7/en/show-profile.html)

在 SQL 中输入 `help profile` 可以查看到详细的帮助文档。

**查看是否开启**

```sql
select @@profiling;
set @@profiling=1;
```

**查看 profile 统计**

```sql
show profiles;
```

| Query_ID | Duration | Query |
| :-:| :-: | :-: |
| 1 | 0.004409 | show status |
| 查询 id | 耗时 | 执行 SQL |

**查看最后一个 SQL 的执行详细信息，从中找出耗时较多的环节**

```sql
show profile;
```

将最后一条 SQL 拆分成了多个阶段，每个阶段耗时统计， 里面出现的 E 表示小数点左移 5 位。

**通过 Id 查询执行详细信息**

```sql
show profile for query {Query_ID}
```

### 4.3.3 其他的命令

**show processlist**

```sql
show processlist;
```
[使用文档](https://dev.mysql.com/doc/refman/5.7/en/show-processlist.html)  
 
用于显示用户运行线程, 得到 Id 后, 可以通过 kill 进行中止线程执行。

查询结果列含义:

| 列  | 含义 |
| :-: | :-: |
| Id |  线程的唯一标志, 可以根据它 kill 线程|
| User | 启动这个线程的用户, 普通用户只能看到自己的线程 |
| Host | 哪个 Ip 端口发起的连接 |
| db | 操作的数据库 |
| Command| 线程的命令, 每个的含义可以看[这里](https://dev.mysql.com/doc/refman/5.7/en/thread-commands.html)  |
| Time| 操作持续时间， 单位秒 |
| State| 线程的状态, 比如查询可能有 coping to tmp talbe 等, 具体的内容可以看[这里](https://dev.mysql.com/doc/refman/5.7/en/general-thread-states.html) |
| Info | SQL 语句的钱 100 个字符, 如果要查看完成的 SQL 语句, 用 SHOW FULL PROCESSLIST|

**show status**

```sql
show global status like 'com_select'; -- 查看 select 次数
```
[使用文档](https://dev.mysql.com/doc/refman/5.7/en/show-status.html)   
用于查看 MySQL 服务器运行状态（重启后会清空），有 session 和 global 两种作用域

**show engine**

```sql
show engine innodb status
```
[使用文档](https://dev.mysql.com/doc/refman/5.7/en/show-engine.html)  

用来显示存储引擎的当前运行信息，包括事务持有的表锁、行锁信息, 事务的锁等待情况, 线程信号量等待, 文件 IO 请求, buffer pool 统计信息

如果需要开业将监控新输入到错误日志文件 erro log 中 (15s 一次), 可以开启输出

```sql
show variables like 'innodb_status_output%'; 
-- 开启输出： 
SET GLOBAL innodb_status_output=ON; 
SET GLOBAL innodb_status_output_locks=ON;

```

### 4.3.4 EXPLAIN 执行计划

官方[链接](https://dev.mysql.com/doc/refman/5.7/en/explain-output.html)

```sql
explain select 查询语句;
```



## 4.4 存储引擎优化