# 2 MySQL 索引原理和使用原则

## 2.1 索引  

维基百科对数据库索引的定义:
数据库索引, 是数据库管理系统 (DBMS) 中一个排序的数据结构, 以协助快速查询, 更新数据库表中的数据。

MongoDB对索引的定义:
索引是特殊的数据结构, 以有序和便于遍历的形式存储数据集合中的一个特定字段或一组字段的值。索引条目的排序支持有效的相等匹配和基于范围的查询操作。

理解:  
数据库表中的数据是以文件的形式存放在磁盘上的, 每一行数据都有他的磁盘地址。如果没有索引, 要从表中的数据检索出一条数据, 只能依次遍历整张表的数据, 直到找到这条数据。
索引是一种特殊的专门用来快速检索的数据结构。所以有了索引后, 只需要在索引里面去检索这条数据,找到数据存放在磁盘的地址后, 就可以找到数据了。

### 2.1.1 索引类型

**根据底层数据结构划分**
> 1. Hash 索引
> 2. B+Tree 索引

**根据索引字段个数划分**
> 1. 单值索引: 单个字段组成的索引
> 2. 复合索引: 多个字段组成的索引, 也叫做组合索引和多值索引

**根据是否在主键上建立的索引划分**  
> 1. 主键索引
> 2. 非主键索引: 也可以叫做辅助索引, 二级索引

**根据数据与索引的存储关联性划分**
> 1. 聚簇索引: 也叫做聚集索引, 索引的存储顺序和数据的存储顺序有关联。比如 InnoDB 中, 叶子节点存储的是既有索引也有数据, 而非叶子节点存储的是索引指针
> 2. 非聚簇索引: 也叫做非聚集索引, 索引的存储顺序和数据的存储顺序没有关联。 比如 MyISAM 中, 索引和数据文件分开存储, Inndob 里的辅助索引也是非聚簇索引

**索引的值是否可以重复划分**
> 1. 唯一索引: 索引的内容不能重复, 主键索引一般是特殊的唯一索引
> 2. 非唯一索引: 也叫做普通索引, 没有任何的限制

**其他的分类**
> 1. 全文索引: 针对比较大的数据的索引。


## 2.2 索引的演变

索引的实现基本是基于一种思想: 二分查找 (这班查找) 实现的。  
在一个已经排过序的数据中, 进行二娥分查找是一个很快的过程, 因为每次查找都能过滤到一半的数据。

### 2.2.1 数据结构实现 - 有序数组

数组的查找效率是非常快的。 特别是在有序数组的等值查询和比较查询效率非常的不错。
但是数组的更新却是一个弊端: 可能要挪动大量的数据 (改变 index) , 所以只适合存储静态的数据

### 2.2.2 数据结构实现 - 链表
链表则可以支持频繁的修改和删除, 但是单链表的话, 查询效率不高, 同时指针还会占用一定的内存

### 2.2.3 数据结构实现 - 二叉查找树 (BST, Binary Search Tree)

二叉查找树 (二叉搜索树, 二叉排序树) 的特点
> 1. 若任意节点的左子树不空, 则左子树上所有结点的值均小于它的根结点的值
> 2. 若任意节点的右子树不空, 则右子树上所有结点的值均大于它的根结点的值
> 3. 任意节点的左、右子树也分别为二叉查找
> 4. 没有键值相等的节点

二叉查找数可以实现快速查找, 又能实现快速插入。  
但是二叉树有一个问题: 它的查找耗时和这棵树的深度有关, 在最坏的情况下, 时间复杂度会退化为 O(n)。

假设现在想二叉查找树中插入 2, 3, 4, 5, 6。这个时候将会得到如下的一棵二叉查找树: 

![Alt 'BinarySearchTreeUnBalanced'](https://raw.githubusercontent.com/PictureRespository/MiddleWare/main/MySQL/BinarySearchTreeUnBalanced.png)

它会变成链表 (也叫做 "斜树") , 这种情况下不能达到加快简书速度的目的, 和顺序查找效率差不多。

造成树倾斜的原因: 左右子树深度差太大, 导致不平衡。

### 2.2.4 数据结构实现 - 平衡二叉树 (AVL, Balanced Binary Search Tree)

平衡二叉树的定义: 左右子树深度差绝对值不能超过 1。
向数中插入数据时, 一旦树出现不平衡, 需要通过左旋或右旋进行调整。

平衡的解决了树失衡的情况, 那么平衡二叉树作为索引怎么查询数据?

**首先作为索引应该存储什么内容**
> 1. 索引的键值。比如在 id 上面创建了一个索引, 在用 where id = 1 的条件查询的时候, 能找到索引里面的 id 的这个键值
> 2. 数据的磁盘地址, 因为索引的作用就是去查找数据的存放的地址
> 3. 必须持有左子节点和右子节点的引用, 这样才能找到下一个节点。比如大于 26 的时候, 走右边, 到下一个树的节点, 继续判断

如果按照上面的内容将其存储到平衡二叉树的节点会出现什么问题? 

如果要回答这个问题, 需要了解一下 InnoDB 的逻辑存储结构

#### 2.2.4.1 InnoDB 逻辑存储结构

MySQL 的存储结构分为 5 级: 表空间, 段, 区, 页, 行。

![Alt 'InnoDbLogicalStorageStructure'](https://raw.githubusercontent.com/PictureRespository/MiddleWare/main/MySQL/InnoDbLogicalStorageStructure.png)
**表空间 Table Space**  

表空间可以看做是 InnoDB 存储引擎逻辑结构的最高层, 所有的数据都存放在表空间中。  
可分为: 系统表空间, 独占表空间, 通用表空间, 临时表空间, Undo 表空间。

**段 Segment**  

表空间是由各个段组成的, 常见的段有数据段, 索引段, 回滚段等。 段是一个逻辑的概念。  
一个 ibd 文件 (独立表空间文件) 里面会由很多个段组成。

创建一个索引会创建两个段
> 1. 索引段: leaf node segment, 管理非叶子节点的数据
> 2. 数据段: non-leaf node segment, 管理叶子节点的数据

一个表的段数, 就是索引的个数乘以 2。

**区 extent**

一个段 (Segment) 又由很多的区 (也可以叫簇) 组成, 每个区的大小是 1MB (64 个连续的页, 一个页 16k) 。

每一个段至少会有一个区, 一个段所管理的空间大小是无限的, 可以一直扩展下去, 但是扩展的最小单位就是区。

**页 Page**

为了高效管理物理空间, 对簇进一步细分, 就得到了页。区是由连续的页 (Page) 组成的空间, 一个区中有 64 个连续的页。 这些页面在物理上和逻辑上都是连续的。

跟大多数数据库一样, InnoDB 也有页的概念 (也可以称为块) , 每个页默认 16KB。 页是 InnoDB 存储引擎磁盘管理的最小单位, 通过 innodb_page_size 设置。   
一个表空间最多拥有 2^32 个页, 默认情况下一个页的大小为 16KB, 也就是说一个表空间最多存储 64TB 的数据。  

注: 文件系统中, 也有页的概念。 操作系统和内存打交道, 最小的单位是页 Page, 文件系统的内存页通常是 4K。
  
往表中插入数据时, 如果一个页面已经写完, 产生一个新的叶页面。如果一个区的所有的页面都被用完, 会从当前页面所在段新分配一个区。  
如果数据不是连续的, 往已经写满的页中插入数据, 会导致叶页面分裂: 
假设 1 行数据 1 k, 一个页有 16 行数据, 这 16 行数据的顺序为 1, 3, 4 到 17, 16 行存满了。 这时候向里面写入 2 的数据, 将要插入到 1, 3 的位置, 这时候这个页就需要分裂了, 才能满足在 1,3 写入数据。

**行 Row**   

InnoDB 存储引擎是面向列的 (row-oriented), 也就是说数据是按行进行存放的, 每个页存放的行记录也是有硬性定义的, 最多允许存放 16KB/2-200, 即 7992 行记录。

Antelope 是 InnoDB 内置的文件格式, 有两种行格式
> 1. REDUNDANT Row Format
> 2. COMPACT Row Format (5.6 默认)

Compact 的存储格式为首部为一个非 NULL 的变长字段长度列表  
Redundant 的存储格式为首部是一个字段长度偏移列表 (每个字段占用的字节长度及其相应的位移) 

在 Antelope 中对于变长字段, 低于 768 字节的, 不会进行 overflow page 存储, 某些情况下会减少结果集 IO。  


Barracuda 是 InnoDB Plugin 支持的文件格式, 除了支持 Antelop 的两种行格式, 还新增了两种行格式
> 1. DYNAMIC Row Format (5.7 默认) 
> 2. COMPRESSED Row Format

Barracuda 在行里的变长字段和 Antelope 的区别是只存 20 个字节, 其它的 overflow page 存储。 需要通过 innodb_file_per_table=1 开启 Barracuda。

Antelope 和 Barracuda 可以通过 innodb_file_format 在配置文件中指定, 而 row_format 则在创建数据表时指定。

```sql
CREATE TABLE tf1 (c1 INT PRIMARY KEY) ROW_FORMAT=COMPRESSED KEY_BLOCK_SIZE=8;
```

在服务端命令行通过
```sql
SHOW TABLE STATUS LIKE '表名' \G;
```
中可以查看当前表的行格式。

#### 2.2.4.2 平衡二叉树存储索引数据

索引的数据, 是放在硬盘上的。查看数据和索引的大小:
```sql
SELECT
	CONCAT( ROUND( SUM( DATA_LENGTH / 1024 / 1024 ), 2 ), 'MB' ) AS data_len,
	CONCAT( ROUND( SUM( INDEX_LENGTH / 1024 / 1024 ), 2 ), 'MB' ) AS index_len 
FROM
	information_schema.TABLES 
WHERE
	table_schema = '数据库名' 
	AND table_name = '表名';
```

当我们用树的结构来存储索引的时候, 访问一个节点就要跟磁盘之间发生一次 IO。InnoDB 操作磁盘的最小的单位是一页, 大小是 16K (16384 字节)。 那么, 一个树的节点就是 16K 的大小。 

如果我们一个节点只存一个**键值+数据+引用**, 例如整形的字段, 可能只用了十几个或者几十个字节, 它远远达不到 16K 的容量, 所以访问一个树节点, 进行一次 IO 的时候, 浪费了大量的空间。  
所以如果每个节点存储的数据太少, 从索引中找到我们需要的数据, 就要访问更多的节点, 意味着跟磁盘交互次数就会过多。

解决方案:
> 1. 每个节点存储更多的数据
> 2. 节点上的关键字的数量越多, 指针数越多, 可以有更多的分叉 (也叫做 "路数")。

分叉数越多, 数的深度会减少, 这个时候树不再是二叉, 而是多叉, 或者叫做多路。

### 2.2.5 数据结构实现 - 多路平衡树 (B Tree, Balanced Tree)

跟 AVL 树一样, B 树在枝节点和叶子节点存储键值, 数据地址, 节点引用。  
同时 B 树的分叉数 (路数) 永远比关键字多 1, 比如有节点中有 2 个关键字, 那么会有 3 个指向下游的节点的指针。

**B Tree 的操作**
假设一棵树的最多路数 (Max Degree) 是 3, 依次插入 1, 2, 3, 在插入 3 的时候, 第一个磁盘块出现了 3 个关键字, 有 4 个指针, 即变成了 4 路。  
这个时候就需要进行分裂, 把中间的数据 2 提上去, 把 1, 3 变成 2 的子节点。 同样的进行了删除节点, 需要进行合并操作。

从中可以知道, 在更新索引的时候, 会有大量的索引的结果调整。所以, 不要在频繁更新的列上建索引, 不要更新主键等。

节点的分裂和合并, 本质就是 InnoDB 页的分裂和合并。

InnoDB 没有选中 B Tree 作为索引的实现的结构的原因:
> 1. 非叶子节点存储的是**键 + 数据**, 搜索有可能在非叶子节点结束。
> 2. 叶子节点不包含任何关键字信息, 指向了 null
> 3. 越靠近根节点的记录查询效率越快

> 1. 每个节点的大小固定为一页 (默认 16k) 的大小, 有限的容量既要存储键, 还有存储数据。如果数据的很多, 那么 1 个节点能存储的索引数会少很多, 那么可能会导致这个树很高, 导致 I/O 的次数提高。
> 2. 越靠近根节点查询效率越快, 而离跟节点越远, 效率越慢, 查询时间很不稳定

### 2.2.5 数据结构实现 - 加强版多路平衡查找树 (B+ Tree)

MySQL 中的 B+ Tree 的特点

(1) 它的关键字的数量和路数相等

(2) B+ Tree 的根节点和非叶子节点中都不会存储数据, 只有叶子节点才存储数据。 搜索到关键字不会直接返回, 回到最后一层的叶子节点, 这里才会找到真正的行数据, 所以每条记录查询的时间基本都是一样的

假设一条记录是 1K, 那么一个叶子节点 (1 页) 可以存储 16 条记录。 那么非叶子节点可以存储多少个指针。

假设索引字段是 bigint 类型, 长度为 8 字节。指针大小在 InnoDB 源码中设置为 6 字节, 这样一个 14 个字节。非叶子节点 (一页) 可以存储 16384/14 = 1170 个这样的大小单元 (键值 + 指针), 代表有 1170 个指针。
树的深度为 2 的时候, 会有 1170 * 1170 个叶子节点, 可以存储 1170 * 1170 * 16 的数据。

在查找数据时一次页的查找代表一次 I/O, 一张 2000 万左右的表, 查询数据最多需要访问 3 次磁盘。  
所以在 InnoDB 中 B+ Tree 的深度一般为 1-3 层, 它就能满足千万级的数据存储。

(3) B+ Tree 的每个叶子节点增加了一个指向相邻叶子节点的指针, 它的最后一个数据指向下一个叶子节点的第一个数据, 形成了一个有序的联表

(4) 它是一个根据左闭右开的区间 [) 来检索数据。

**B+ Tree 比 B Tree 更适合作为索引的实现**
> 1. B+ Tree 是 B Tree 的变种, B Tree 能解决的问题, 它也能解决
> 2. 扫库, 扫表能力更强 (如果要对表进行全表扫描, 只需要遍历叶子节点就可以, 不需要遍历整棵 B+ Tree, 多亏了叶子节点有指向下一个叶子节点的指针)
> 3. B+ Tree 的磁盘读写能力相对于 B Tree 更强, 非叶子节点不保存数据区, 所以一个节点key保存更多的关键字, 一次磁盘加载的关键字更多
> 4. 排序能力更强, 因为叶子节点有下一个数据区的指针, 数据形成了链表
> 5. 效率更加稳定, B+ Tree 永远都是在叶子节点拿到数据, 所以 IO 次数稳定

### 2.2.6 为什么不使用红黑树来实现索引

红黑树也是二叉查找树, 但是不是严格平衡的。
其本身有 5 个约束
> 1. 根节点必须是黑色的
> 2. 节点分为红色或者黑色
> 3. 叶子节点都是黑色的 NULL 节点
> 4. 红色节点的两个子节点都是黑色 (不允许两个相邻的红色节点) 
> 5. 从任意节点出发, 到其每个叶子节点的路径中包含相同数量的黑色节点

基于上面的约束, 可以推导出: 从根节点到叶子节点的最长路径 (红黑相间的路径) 不大于最短路径(全部是黑色节点) 的 2 倍。

**不使用红黑树的原因**
> 1. 只有两路
> 2. 不够平衡

### 2.2.7 InnoDB 索引的另一种实现

在 InnoDB 中还有一张 Hash 实现索引的方式。  
Hash 以 KV 的形式检索数据, 会根据索引字段生成哈希码和指针, 指针指向数据。  

Hash 索引的特点
> 1. 它的时间复杂度是 O(1), 查询速度比较快。因为哈希索引里面的数据不是 按顺序存储的, 所以不能用于排序
> 2. 我们在查询数据的时候要根据键值计算哈希码, 所以它只能支持等值查询 (= IN) , 不支持范围查询 (> < >= <= between and) 
> 3. 如果字段重复值很多的时候, 会出现大量的哈希冲突 (采用拉链法解决) , 效率会降低

InnoDB 只支持显式创建 B+Tree 索引, 对于一些热点数据页, InnoDB 会自动建立自适应 Hash 索引, 也就是在 B+Tree 索引基础上建立 Hash 索引, 这个过程对于客户端是不可控制的, 隐式的。  
这个隐式的建立过程就是 Adaptive Hash Index 自适应哈希索引。这个行为也是通过一个开关控制的 **show variables like 'innodb_adaptive_hash_index';**。

## 2.3 B+ Tree 的落地实现

MySQL 的数据都是文件的形式存放在磁盘中的,在 MySQL 中有这么一个参数 **show VARIABLES LIKE 'datadir';**, 可以找到这个数据目录的地址。
在这个目录下, 每个数据库都有自己的文件夹, 数据库下的表同样的在对应的数据库文件夹下有自己的文件
> 1. InnoDB 的表有 2 个文件, 表名.frm 和 表名.ibd
> 2. MyISAM 的表有 3 个文件, 表名.frm, 表名.MYD 和 表名.MYI

其中 .frm 是 MySQL 里面表结构定义的文件, 每个引起都会生成的。

### 2.3.1 MyISAM

在 MyISAM 中
> 1. .MYD 文件, D 代表了 Data, 是 MyISAM 的数据文件, 存放数据记录, 也就是表中的所有数据
> 2. .MYI 文件, I 代表了 Index, 是 MyISAM 的索引文件, 存放的是表中的索引数据。

MyISAM 的 B+ Tree 里面, 叶子节点存放的是数据文件对应的磁盘地址。索引从索引文件 .MYI 中找到键值后, 会再到数据文件 .MYD 中获取相应的数据记录。

如图:  
![Alt 'FindDataWithIndexFileInMyISAM'](https://raw.githubusercontent.com/PictureRespository/MiddleWare/main/MySQL/FindDataWithIndexFileInMyISAM.png)


这里是主键索引, 如果是辅助索引, 有什么不一样的吗?

在 MyISAM 里面, 辅助索引也在 .MYI 文件里面。  
辅助索引跟主键索引存储和检索数据的方式没有任何区别, 一样是在索引文件里面找到磁盘地址, 然后到数据文件里面获取数据。

### 2.3.2 InnoDB 

在 InnoDB 中只有一个 .ibd 文件。在 InnoDB 中以主键为索引组织数据的存储, 索引文件和数据文件都在同一个 .ibd 文件中。  
在 InnoDB 的注解索引的叶子节点上, 直接存储了表中的数据  

![Alt 'FindDataWithIndexFileInInnoDB'](https://raw.githubusercontent.com/PictureRespository/MiddleWare/main/MySQL/FindDataWithIndexFileInInnoDB.png)

在 InnoDB 中, 他组织数据的方式叫做 (聚集)索引组织表 (clustered index organize table), 索引注解索引是聚集索引, 非主键索引是非聚集索引。

在 InnoDB 中, 注解索引和辅助索引有一个主次关系。  
辅助索引叶子节点存储的是辅助索引和主键值。如果使用辅助索引查询, 会先在辅助索引中找到主键索引, 再根据主键值在主键索引中查询, 最终获取到数据。

**为什么不直接在辅助索引里面存储主键的磁盘地址**

B+ Tree 为了维持平衡, 节点会有分裂和合并的操作, 这个时候键值的地址会发生变化, 索引在辅助索引里面不存储地址。

**一张表没有主键是怎么办**
如果显示地定义了主键 (primary key), 那么 InnoDB 会选择这个主键作为聚集索引。  
如果没有显示定义主键, 则 InnoDB 会选择第一个不包含有 Null 值的唯一索引作为主键索引  
如果没有这样的唯一索引, 则 InnoDB 会选择内置 6 字节的 ROWID 作为隐藏的聚集索引, 它会随着行记录的写入而主键递增。

```mysql
select _rowId name from 表名。
```

## 2.4 索引的使用原则

不是索引越多越好

### 2.4.1 列的离散度

列的离散度的计算公式:
count(distinct(列名)): count(1), 列的全部通知和所有数据行的比例。数据行数相同的情况下, 分子越大, 列的离散度就越高。

简单来说: 列的重复值越多, 离散度就越低, 重复值越少, 离散度就越高。
最简单的例子: 在用户表里面, 给性别列加索引和给姓名加索引, 2 者的收益不同, 前者的离散度较低, 后者较高。

注: 可以通过 **show indexes from 表名;**, 查看表的索引情况。  
其中的 **Cardinality**, 代表基数, 代表了预估的不重复的值的数量。索引的基数和表总行数越接近, 列的离散度就越高。

当然有时候也可以结合场景特殊处理:  
假设有一种信息发送表, 表里面每天都会增加大量数据, 表中有 1 列表示当前消息的状态, 已发送, 待发送等。  

业务场景, 定时器定时的从表中查询出待发送的消息, 进行发送, 每次发送成功后, 就将记录的状态更新为已发送。  
那么这时候给状态加上索引, 因为表中大部分的情况都是已发送的, 未发送的只占里面总量的很少很少, 通过这个索引可以筛选掉一大部分的以发送数据。

### 2.4.2 联合索引最左原则

联合索引在 B+ Tree 中是复合的数据结构, 他按照从左到右的顺序来简历索引树。  
当前有 name 和 phone 的复合索引, 在树中, name 是有序的, phone 是无序的。只有当 name 相等的情况下, phone 才有序。

当查询的时候使用的条件为 `where name= 'A' and phoe = '123';`, B+ Tree 会优先比较 name 来确定下一步应该搜索的方向, 往左还是往右。  
如果 name 相同的情况, 在比较 phone。 如果查询条件没有 name, 就不知道第一步应该查哪个节点, 因为建立搜索树的时候 name 是第一个比较因子, 所以用不到索引。

**什么时候用到联合索引**

查询条件多个的情况下, 同时有 1 到多个列是频繁出现的, 同时选择的那一列的离散度要高。最终在建立索引时, 将其放在最左边。

### 2.4.3 覆盖索引

在辅助索引里面, 不管是单例索引还是复合索引, 如果 select 的数据列值用从索引中就能取得, 不必从数据区中读取, 这时候使用的索引就叫做覆盖索引, 这样就避免了回表。

**回表** 
> 1. 非主键索引, 先通过索引找到主键索引的键值, 
> 2. 再通过主键值到主键索引中找到对应的行
> 3. 从行中找到查询列中其他不在索引里面的字段的值

需要回到数据区, 也就是表中的情况, 就是回表。

#### 2.4.4 索引条件下退 (ICP)

先尝试关闭 ICP 功能:

```sql
-- 关闭 ICP
set optimizer_switch='index_condition_pushdown=off';

-- 查看参数
show variables like 'opimizer_switch';
```

现在有一张雇员表 employees, 里面有 2 个非空的 varchar 的字段 first_name 和 last_name, 在表上建立了一个复合索引 (last_name, first_name)。

现在要查询出所有姓是 wang (last_name) 和名字中最后一个字为 zi 的员工

```sql
select * from employees where last_name = 'wang' and first_name like '%zi';
```

这条 SQL 有两种执行方式: 

(1) 根据联合索引查出所有姓 wang 的二级索引数据, 然后回表, 到主键索引上查询全部符合条件的数据 (3 条数据) 。然后返回给 Server 层, 在 Server 层过滤出名字以 zi 结尾的员工。  
(2) 根据联合索引查出所有姓 wang 的耳机索引数据, 然后从二级索引中筛选出 first_name 以 zi 结果的索引 (1 个索引), 然后在回表, 到主键索引上查询全部复核条件的数据 (1条数据), 返回给 Server 层。

注: **索引的比较是在存储引擎进行的, 数据记录的比较, 是在 Server 层进行的**。

很明显, 第二种方式到主键索引上查询的数据更少。而且当 first_name 的条件不能用于索引过滤时, Server 层不会把 first_name 的条件传递给存储引擎, 所有读取了两条没有必要的记录。

如果这时候满足 last_name = ‘wang’的记录有 10000 条, 就有 9999 条是没必要读取的记录。

通过 explain 分析上面的 SQL, 可以看到结果里面的 `Extra` 列里面的结果为 `Using where`。  
Using where 代表从存储引擎取回的数据不全部满足条件, 需要在 Server 层过滤。  
先用 last_name 条件进行索引范围扫描, 读取数据表记录, 然后进行比较, 检查是否符合 first_name like '%zi' 的条件, 此时 3 条中只有 1 条符合条件。

开启 ICP 功能

```sql
set optimizer_switch='index_condition_pushdown=on';
```

此时再通过 explain 分析上面的 SQL, 可以看到结果里面的 `Extra` 列里面的结果为 `Using index condition`。  
把 first_name like '%zi' 下推给存储引擎后, 只会从数据库表读取所需的 1 条记录。

索引条件下推 (Index Condition Pushdown) , 5.6 以后完善的功能。只适用于二级索引。ICP 的目标是减少访问表的完整行的读数量从而减少 I/O 操作。

## 2.4 索引的使用

**索引的使用**
> 1. 常用在 wher 判断 / order  排序 / join 的 on 字段上建索引
> 2. 索引的数量不要太多 - 浪费空间, 更新变慢
> 3. 区分度第的字段, 例如性别, 不用要建索引 - 离散度太低, 导致扫描行数过多
> 4. 频繁更新的值, 不要作为主键或者索引 - 可能会导致页分裂
> 5. 组合索引把散列度高的 (区分度高) 的值放在前面
> 6. 创建复合索引, 而不是修改单列索引
> 7. 无序的值 (例如身份证, UUID) 尽量不要作为索引
> 8. 当字段值比较长的时候, 可以考虑前缀索引, 截取字段的前面一部分内容建立索引, 至于截取多少, 可以通过散列值判断

**索引失效**
> 1. 在索引列上使用函数, 表达式, 计算
> 2. 字符串不加引号, 出现隐式转换
> 3. like 条件中前面带 %
> 4. 复现查询, not like, not in, !=

## 参考
[MySQL索引分类, 90%的开发都不知道](https://zhuanlan.zhihu.com/p/115746492)
