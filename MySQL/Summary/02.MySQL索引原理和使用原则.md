# 2 MySQL 索引原理和使用原则

## 2.1 索引  

维基百科对数据库索引的定义:
数据库索引, 是数据库管理系统 (DBMS) 中一个排序的数据结构, 以协助快速查询, 更新数据库表中的数据。

MongoDB对索引的定义:
索引是特殊的数据结构, 以有序和便于遍历的形式存储数据集合中的一个特定字段或一组字段的值。索引条目的排序支持有效的相等匹配和基于范围的查询操作。

理解:  
数据库表中的数据是以文件的形式存放在磁盘上的, 每一行数据都有他的磁盘地址。如果没有索引, 要从表中的数据检索出一条数据, 只能依次遍历整张表的数据, 直到找到这条数据。
索引是一种特殊的专门用来快速检索的数据结构。所以有了索引后, 只需要在索引里面去检索这条数据,找到数据存放在磁盘的地址后, 就可以找到数据了。

### 2.1.1 索引类型

**根据底层数据结构划分**
> 1. Hash 索引
> 2. B+Tree 索引

**根据索引字段个数划分**
> 1. 单值索引: 单个字段组成的索引
> 2. 复合索引: 多个字段组成的索引, 也叫做组合索引和多值索引

**根据是否在主键上建立的索引划分**  
> 1. 主键索引
> 2. 非主键索引: 也可以叫做辅助索引, 二级索引

**根据数据与索引的存储关联性划分**
> 1. 聚簇索引: 也叫做聚集索引, 索引的存储顺序和数据的存储顺序有关联。比如 InnoDB 中, 叶子节点存储的是既有索引也有数据, 而非叶子节点存储的是索引指针
> 2. 非聚簇索引: 也叫做非聚集索引, 索引的存储顺序和数据的存储顺序没有关联。 比如 MyISAM 中, 索引和数据文件分开存储, Inndob 里的辅助索引也是非聚簇索引

**索引的值是否可以重复划分**
> 1. 唯一索引: 索引的内容不能重复, 主键索引一般是特殊的唯一索引
> 2. 非唯一索引: 也叫做普通索引, 没有任何的限制

**其他的分类**
> 1. 全文索引: 针对比较大的数据的索引。


## 2.2 索引的演变

索引的实现基本是基于一种思想: 二分查找 (这班查找) 实现的。  
在一个已经排过序的数据中, 进行二娥分查找是一个很快的过程, 因为每次查找都能过滤到一半的数据。

### 2.2.1 数据结构实现 - 有序数组

数组的查找效率是非常快的。 特别是在有序数组的等值查询和比较查询效率非常的不错。
但是数组的更新却是一个弊端: 可能要挪动大量的数据 (改变 index) , 所以只适合存储静态的数据

### 2.2.2 数据结构实现 - 链表
链表则可以支持频繁的修改和删除, 但是单链表的话, 查询效率不高, 同时指针还会占用一定的内存

### 2.2.3 数据结构实现 - 二叉查找树 (BST, Binary Search Tree)

二叉查找树 (二叉搜索树, 二叉排序树) 的特点
> 1. 若任意节点的左子树不空, 则左子树上所有结点的值均小于它的根结点的值
> 2. 若任意节点的右子树不空, 则右子树上所有结点的值均大于它的根结点的值
> 3. 任意节点的左、右子树也分别为二叉查找
> 4. 没有键值相等的节点

二叉查找数可以实现快速查找, 又能实现快速插入。  
但是二叉树有一个问题: 它的查找耗时和这棵树的深度有关, 在最坏的情况下, 时间复杂度会退化为 O(n)。

假设现在想二叉查找树中插入 2, 3, 4, 5, 6。这个时候将会得到如下的一棵二叉查找树: 

![Alt 'BinarySearchTreeUnBalanced'](https://raw.githubusercontent.com/PictureRespository/MySQL/main/picture/BinarySearchTreeUnBalanced.png)

它会变成链表 (也叫做 "斜树") , 这种情况下不能达到加快简书速度的目的, 和顺序查找效率差不多。

造成树倾斜的原因: 左右子树深度差太大, 导致不平衡。

### 2.2.4 数据结构实现 - 平衡二叉树 (AVL, Balanced Binary Search Tree)

平衡二叉树的定义: 左右子树深度差绝对值不能超过 1。
向数中插入数据时, 一旦树出现不平衡, 需要通过左旋或右旋进行调整。


平衡的解决了树失衡的情况, 那么平衡二叉树作为索引怎么查询数据?

**首先作为索引应该存储什么内容**
> 1. 索引的键值。比如在 id 上面创建了一个索引, 在用 where id = 1 的条件查询的时候, 能找到索引里面的 id 的这个键值
> 2. 数据的磁盘地址, 因为索引的作用就是去查找数据的存放的地址
> 3. 必须持有左子节点和右子节点的引用, 这样才能找到下一个节点。比如大于 26 的时候, 走右边, 到下一个树的节点, 继续判断

如果按照上面的内容将其存储到平衡二叉树的节点会出现什么问题? 

如果要回答这个问题, 需要了解一下 InnoDB 的逻辑存储结构

#### 2.2.4.1 InnoDB 逻辑存储结构

MySQL 的存储结构分为 5 级: 表空间, 段, 区, 页, 行。

![Alt 'InnoDbLogicalStorageStructure'](https://raw.githubusercontent.com/PictureRespository/MySQL/main/picture/InnoDbLogicalStorageStructure.png)

**表空间 Table Space**  

表空间可以看做是 InnoDB 存储引擎逻辑结构的最高层, 所有的数据都存放在表空间中。  
可分为: 系统表空间, 独占表空间, 通用表空间, 临时表空间, Undo 表空间。

**段 Segment**  

表空间是由各个段组成的, 常见的段有数据段, 索引段, 回滚段等。 段是一个逻辑的概念。  
一个 ibd 文件 (独立表空间文件) 里面会由很多个段组成。

创建一个索引会创建两个段
> 1. 索引段: leaf node segment, 管理非叶子节点的数据
> 2. 数据段: non-leaf node segment, 管理叶子节点的数据

一个表的段数, 就是索引的个数乘以 2。

**区 extent**

一个段 (Segment) 又由很多的区 (也可以叫簇) 组成, 每个区的大小是 1MB (64 个连续的页, 一个页 16k) 。

每一个段至少会有一个区, 一个段所管理的空间大小是无限的, 可以一直扩展下去, 但是扩展的最小单位就是区。

**页 Page**

为了高效管理物理空间, 对簇进一步细分, 就得到了页。区是由连续的页 (Page) 组成的空间, 一个区中有 64 个连续的页。 这些页面在物理上和逻辑上都是连续的。

跟大多数数据库一样, InnoDB 也有页的概念 (也可以称为块) , 每个页默认 16KB。 页是 InnoDB 存储引擎磁盘管理的最小单位, 通过 innodb_page_size 设置。   
一个表空间最多拥有 2^32 个页, 默认情况下一个页的大小为 16KB, 也就是说一个表空间最多存储 64TB 的数据。  

注: 文件系统中, 也有页的概念。 操作系统和内存打交道, 最小的单位是页 Page, 文件系统的内存页通常是 4K。
  
往表中插入数据时, 如果一个页面已经写完, 产生一个新的叶页面。如果一个区的所有的页面都被用完, 会从当前页面所在段新分配一个区。  
如果数据不是连续的, 往已经写满的页中插入数据, 会导致叶页面分裂: 
假设 1 行数据 1 k, 一个页有 16 行数据, 这 16 行数据的顺序为 1, 3, 4 到 17, 16 行存满了。 这时候向里面写入 2 的数据, 将要插入到 1, 3 的位置, 这时候这个页就需要分裂了, 才能满足在 1,3 写入数据。

**行 Row**   

InnoDB 存储引擎是面向列的 (row-oriented), 也就是说数据是按行进行存放的, 每个页存放的行记录也是有硬性定义的, 最多允许存放 16KB/2-200, 即 7992 行记录。

Antelope 是 InnoDB 内置的文件格式, 有两种行格式
> 1. REDUNDANT Row Format
> 2. COMPACT Row Format (5.6 默认)

Compact 的存储格式为首部为一个非 NULL 的变长字段长度列表  
Redundant 的存储格式为首部是一个字段长度偏移列表（每个字段占用的字节长度及其相应的位移）

在 Antelope 中对于变长字段，低于 768 字节的，不会进行 overflow page 存储, 某些情况下会减少结果集 IO。  


Barracuda 是 InnoDB Plugin 支持的文件格式, 除了支持 Antelop 的两种行格式, 还新增了两种行格式
> 1. DYNAMIC Row Format（5.7 默认）
> 2. COMPRESSED Row Format

Barracuda 在行里的变长字段和 Antelope 的区别是只存 20 个字节， 其它的 overflow page 存储。 需要通过 innodb_file_per_table=1 开启 Barracuda。

Antelope 和 Barracuda 可以通过 innodb_file_format 在配置文件中指定, 而 row_format 则在创建数据表时指定。

```sql
CREATE TABLE tf1 (c1 INT PRIMARY KEY) ROW_FORMAT=COMPRESSED KEY_BLOCK_SIZE=8;
```

在服务端命令行通过
```sql
SHOW TABLE STATUS LIKE '表名' \G;
```
中可以查看当前表的行格式。

#### 2.2.4.2 平衡二叉树存储索引数据

索引的数据，是放在硬盘上的。查看数据和索引的大小:
```sql
SELECT
	CONCAT( ROUND( SUM( DATA_LENGTH / 1024 / 1024 ), 2 ), 'MB' ) AS data_len,
	CONCAT( ROUND( SUM( INDEX_LENGTH / 1024 / 1024 ), 2 ), 'MB' ) AS index_len 
FROM
	information_schema.TABLES 
WHERE
	table_schema = '数据库名' 
	AND table_name = '表名';
```

当我们用树的结构来存储索引的时候, 访问一个节点就要跟磁盘之间发生一次 IO。InnoDB 操作磁盘的最小的单位是一页, 大小是 16K (16384 字节)。 那么，一个树的节点就是 16K 的大小。 


如果我们一个节点只存一个**键值+数据+引用**，例如整形的字段，可能只用了十几个或者几十个字节，它远远达不到 16K 的容量，所以访问一个树节点，进行一次 IO 的时候， 浪费了大量的空间。  
所以如果每个节点存储的数据太少，从索引中找到我们需要的数据，就要访问更多的节点，意味着跟磁盘交互次数就会过多。








## 参考
[MySQL索引分类, 90%的开发都不知道](https://zhuanlan.zhihu.com/p/115746492)