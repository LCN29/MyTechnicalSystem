# MySQL 索引

## 1. what is index
A database index is a **data structure** that improves the speed of operations in a table. Indexes can be created using one or more columns, providing the basis for both **rapid random lookups** and **efficient ordering of access to records**.

数据库索引是一种数据结构，它可以提高表中的操作速度。可以使用一个或多个列创建索引，这为快速随机查找和对记录的高效排序提供了基础。

## 2. the type of Index

**数据结构角度**
>1. B+ 树索引
>2. Hash 索引
>3. R-Tree 索引
>4. FullText 索引
 
**逻辑角度**
>1. 普通(单列)索引
>2. 唯一索引
>3. 主键索引 
>4. 复合(多列/组合)索引
>5. 空间索引

**从物理存储角度**
>1. 聚集索引
>2. 非聚集索引


## 3. detailed introduction of Index

### 3.1 从数据结构角度了解索引

#### 3.1.1 B+ 树索引
因为 B+ 树索引的内容比较多，单开了一遍文章，详情可以看[这里](https://github.com/LCN29/TechnicalSystem/blob/master/MySQL/Index/B%2B%20Tree%20%E7%B4%A2%E5%BC%95.md)


#### 3.1.2 Hash 索引 

Hash 索引是基于哈希表实现的。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希存储在索引中，同时将这个哈希码对应的数据行的指针也一起保存在索引中。  

索引的大概结构：**哈希值 + 数据行指针**。

SQL 执行的过程大概是这样的：根据查询条件的列，计算出 hash 值，然后在索引里面根据这个 hash 值找到对应的行，得到数据行的指针，通过指针到真正的表去查询。

使用 Hash 索引为什么能加快查询
>1. 通过 哈希码 可以快速定位到对应的列在索引中的位置，得到位置就是得到了真正数据行在表中的那一行。
>2. 哈希码 是一个比较小的值，计算量不大
>3. 索引自身只需存储对应的哈希值和哈希值对应的列的指针，结构简单


MySQL 中，只有 **Memory** 存储引擎显示支持 hash 索引。支持的还是非唯一 hash 索引，如果多个值有相同的 hash Code，索引把它们的行指针用链表保存到同一个 hash 表项中。(类似于 Java 中的 HashMap 的链表)

Hash 索引也有它的限制：
>1. 哈希索引只包含哈希值和行指针, 而不存储字段值, 所以不能使用索引中的值来避免读取行。 不过, 访问内存中的行的速度很快, 所以大部分情况下这一点对性能的影响并不明显。 
>2. 哈希索引数据并不是按照索引值顺序存储的, 所以也就无法用于排序。 
>3. 哈希索引也不支持部分索引列匹配查找, 因为哈希索引始终是使用索引列的全部内容来计算哈希值的。 
>4. 哈希索引只支持等值比较查询, 包括=、IN() 等，但是也不支持任何范围查询。
>5. 当出现哈希冲突的时候, 存储引擎必须遍历链表中所有的行指针, 逐行进行比较, 直到找到所有符合条件的行。 
>6. 如果哈希冲突很多的话, 一些索引维护操作的代价也会很高。 比如删除某一行，需要遍历 Hash 链表中的每一行，找到需要删除的。


InnoDB 引擎有一个特殊的功能叫做“自适应哈希索引”。当InnoDB注意到某些索引值被使用得非常频繁时，它会在内存中基于B-Tree索引上再创建一个哈希索引，这样就像B-Tree索引也具有哈希索引的一些优点，比如快速的哈希查找。这是一个完全自动的、内部的行为, 用户无法控制或者配置, 不过如果有必要, 完全可以关闭该功能。 

#### 3.1.3 R-Tree 索引
MyISAM表支持空间索引, 可以用作地理数据存储, 例如 GEOMETRY。 这类索引无须前缀查询。 空间索引会从所有维度来索引数据。 查询时, 可以有效地使用任意维度来组合查询。必须使用 MySQL 的 GIS 相关函数如 MBRCONTAINS() 等来维护数据。MySQL 的 GIS 支持并不完善，所以大部分人都不会使用这个特性。

#### 3.1.4 FullText 索引
全文索引是 MyISAM 的一个特殊索引类型，innodb 的 5.6 以上版本也支持，它查找的是文本中的关键词主要用于全文检索。  

全文索引是一种特殊类型的索引，可以在VARCHAR或者 TEXT类型的列上创建。它查找都是文本中的关键词，而不是直接比较索引中的值。全文搜索和其他几类索引匹配方式完全不一样。它有许多需要注意的细节，如停用词、词干和复数、布尔搜索等。全文索引更类似于搜索引擎做的事情，而不是简单的WHERE条件匹配。


### 3.2 从逻辑角度了解索引

#### 3.2.1 普通(单列)索引
这是最基本的索引类型，而且它没有唯一性之类的限制，可以用表中的普通列直接创建。唯一任务是加快对数据的访问速度。因此，应该只为那些最经常出现在查询条件（WHERE column=）或者排序条件（ORDERBY column）中的数据列创建索引。

#### 3.2.2 唯一索引
这种索引和前面的 “普通索引” 基本相同，但有一个区别：索引列的所有值都只能出现一次，即必须唯一, 但是允许为 null。


#### 3.2.3 主键索引
主键是一种 “唯一索引”，但它必须指定为 "PRIMARY KEY"。建立索引的列不允许重复，不允许空值。

#### 3.2.4 复合(多列/组合)索引
用多个列组合构建的索引，这多个列中的值不允许有空值。

复合索引存在的意义：  
在实际的应用中，进行查询很多时候都是多个条件进行筛选的。  
比如现在有一张用户表，表里有: 用户Id, 姓名，年龄，出生日期。在查询的时候，如果很多时候都是把这 3 个条件都加入筛选条件的话。如何建立索引比较好呢?

>1. 单独每个字段都建立一个索引
有一定的提示查询效果，但是不是最好的。当我们执行查询的时候，MySQL 只能使用一个索引。如果你有三个单列的索引，MySQL会试图选择一个限制最严格的索引。但是，即使是限制最严格的单列索引, 也只能帮我们定位到某一个范围。比如把出生日期缩小范围到 `2010-10-11`。然后在这个范围逐一比较 姓名，年龄。

>2. 将这 3 列组装成 1 个复合索引
在 B+ Tree 索引中，他们组成的索引是这样的 [姓名, 年龄，出生日期]。都维护在非叶子节点上。然后会依次比较 姓名，年龄，出生日期，直到定位到需要的列。 也就是这三个条件都能用上，把范围再次缩小了。

复合索引虽然提供了多条件查询的方便，但是在使用的过程也需要注意，比如最左原则，建立索引的列的选择等。

#### 3.2.5 空间索引
空间索引只能建立在空间数据类型上，这样可以提高系统获取空间数据的效率。MySQL 中的空间数据类型包括 GEOMETRY 和 POINT、LINESTRING 和 POLYGON 等。目前只有 MyISAM 存储引擎支持空间检索，而且索引的字段不能为空值。

### 3.3 从数据结构角度了解索引

#### 3.3.1 聚簇索引和非聚簇索引

聚簇索引就是数据库表中行的数据的物理顺序与键值的逻辑(索引)顺序相同, 同时保证关键字的值相近的行存储的物理位置也相近。（所以字符串类型不宜建立聚簇索引，特别是随机字符串，会使得系统进行大量的移动操作）

在《数据库原理》一书中是这么解释聚簇索引和非聚簇索引的区别的：
聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。

下图形象说明了聚簇索引表 (InnoDB) 和非聚簇索引 (MyISAM) 的区别：
![Alt '聚簇索引和非聚簇索引'](https://s1.ax1x.com/2020/03/23/8Tj3Dg.png)

**聚簇索引表(左图)**：  
表数据是和主键一起存储的，主键索引的叶结点存储行数据(包含了主键值)。

二级索引(辅助索引，除了主键索引外的其他索引类型)的叶结点存储行的主键值。

非叶子节点都是只存储索引关键字, 不存储对应记录的具体内容或内容地址。叶子节点上的数据是主键与具体记录(数据内容)


**非聚簇索引表(右图)**：
表数据和索引是分成两部分存储的，主键索引和二级索引存储上没有任何区别。

所有的节点都是索引，叶子节点存储的是索引 + 索引对应的记录的位置指针。

**[注]: 在 InnoDB 中，只有主键索引才是聚簇索引，其他的索引都是非聚簇索引**

#### 3.3.2 聚簇索引的优点
>1. 范围查询，用聚簇索引也比用非聚簇索引好
>2. 基于主键查询的话，聚簇索引查找目标数据时理论上比非聚簇索引要快，因为非聚簇索引定位到对应主键时还要多一次目标记录寻址,即多一次I/O

#### 3.3.3 聚簇索引的缺点
>1. 更新主键的代价很高，因为将会导致被更新的行移动。所以一般情况下，都是主键不可变
>2. 二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据
>3. 采用聚簇索引插入新值比采用非聚簇索引插入新值的速度要慢很多。 插入之前需要判断主键是否存在。聚簇索引遍历所有的叶子节点，非聚簇索引也判断所有的叶子节点。但是聚簇索引的叶子节点包含了我们的数据，这样就会导致聚簇索引在判定新记录携带的主键是否重复时进行昂贵的I/O代价。
>4. 插入速度严重依赖于插入顺序,按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。如果是随机主键插入的话，可能导致整个索引数的频繁调整。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键。


## 4. Covering Indexes
覆盖索引：指一个查询语句的执行只需要从索引中就可以得到查询记录，而不用从数据表中读取。也可以称之为实现了索引覆盖。

如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做覆盖索引。

从上面的解释中，我们可以知道覆盖索引并不是一种真正的索引，而是一种查询中刚好满足的情况。

只需要读取索引而不用读取数据有以下一些优点：
>1. 索引项通常比记录要小，所以 MySQL 访问更少的数据
>2. 索引都按值的大小顺序存储，相对于随机访问记录，需要更少的 I/O
>3. 大多数据引擎能更好的缓存索引。比如 MyISAM 只缓存索引。InnoDB 只存储了 B+ Tree 的根节点
>4. 覆盖索引对于InnoDB表尤其有用，因为InnoDB使用聚集索引组织数据，如果二级索引中包含查询所需的数据，就不再需要在聚集索引中查找了

对于索引覆盖查询(index-covered query)，使用 EXPLAIN 时，可以在 Extra 一列中看到 “Using index”。

## 5. the benefits of index

>1. 可以让服务器快速地定位到表的指定位置, 大大减少了服务器需要扫描的数据
>2. 可以帮助服务器避免排序和临时表
>3. 可以将随机 I/O 变为顺序 I/O

## 6. how to use index

>1. 不要让索引做一下隐式的转换
>>1. 让索引进行计算  select * from table where index + 1 = 5;
>>2. 字符串的索引，但是查询条件没有加引号 select * from table where str_index = 123; 这里的 123 应该用 ''包起来
>>3. 使用函数进行了转换 select * from table  where date_format(birthday, '%Y%m%d%H%i%s') = '1231212121212';

>2. 前缀(后缀)索引
有时候我们有一个字段很长，但是我们又需要为其建立索引，这时候，我们可以取这个字段的某一部分建立索引，这样虽然可能会出现相同的索引值，但是减少了索引的体积，加快了查询速度。(具体这个索引取原有字段的多少位之类的，需要具体的分析， 创建的方式：add index (字段(需要多少位)))

>3. 复合索引，注意最左原则




## how to create an index
>1. 列值不会经常改变的，因为列值的改变，都会导致索引的重新构建
>2. 列值的选择如果比较少的，比如性别，这种列基本不需要索引
>3. 列值尽可能是 not null 设置
>4. 索引尽量建立在小字段, 索引也是会占空间的
>5. 复合索引的创建需要仔细分析，如果可以的话，通过单字段索引代替



## mysql 中的最多问题
* 一张表最多可以有多少个列
* 一张表多少个索引
* 复合索引最多几列
* varchar最大长度是多少

如果单纯是这样的问题的话，很难有一个精确的答案的。
首先它涉及到 MySQL 的引擎，对应版本默认的一些配置, 选择的字符类型等。

比如 一张表可以建立一个复合索引，索引里面的可以有多少列。

>1. 确定是在某个引擎下
>2. 确定某个 MySQL 版本, 知道默认设置的 key 大小。比如在 MySQL 8.0.18 中，一个索引的长度有一个 Specified key 的限制，默认是 3072 b 的大小。一行的最大长度为 65535 b 等
>3. 索引里面的列的类型, 比如 int 32 位，varchar(XX) xx 位等
>4. 涉及的字符集类型 utf8 需要 3 个字节，utf8mb4 需要 4 个字节

影响的因素很多，所以不太好确定的。







InnoDB为什么推荐使用自增ID作为主键？

答：自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差












# 尽量不用 * 查询
覆盖索引可能会失效









# 
https://www.cnblogs.com/duanxz/p/3799045.html


https://www.yangdx.com/2019/03/23.html

https://juejin.im/post/5cdd701ee51d453a36384939


首先 在 MySQL  的 InnoDB 引擎下

索引可以分为 主键索引 和 辅助索引

在我们这里 id 是主键 和 name 是 辅助索引

主键索引的实现 是 B + Tree 
除了叶子节点外 存放的都是 主键， 叶子节点存放的是列的数据

辅助索引的实现 也是 B + Tree
除了叶子节点外，存放的是列的值， 叶子节点存放的是 对应行的 主键 Id

一般情况下通过非主键索引查询，都是先在辅助索引找到对应的 主键 Id， 通过主键Id再到主键索引对应的 B+ Tree 找到对应列的数据

覆盖索引：查询的内容刚好在 索引中了，不需要到叶子节点去取了。


首先：第一条

explain SELECT `name` from `test_table` WHERE `name` like '%123';

已经存在基于 name 建立的 B+ Tree 索引， 查询的 name 也刚好是 索引值，
那么 MySQL 直接在 B+ Tree 索引里面找就行了，不需要到全表扫描

第二条
explain SELECT `id` from `test_table` WHERE `name` like '%123';

基于 name 建立的 B+ Tree 索引 的叶子节点存放的是主键Id， 查询的也是 id , 直接在 name 这个 B+ tree 里面找就行了，也不用全表扫描。

第三条
explain SELECT `age` from `test_table` WHERE `name` like '%123';
查询的是 age, 就是我们常说的， 不走索引了。




