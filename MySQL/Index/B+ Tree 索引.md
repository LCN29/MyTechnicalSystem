# B+ Tree 索引

## B-Tree
在了解 B+ Tree 索引时, 先从他的结构开始吧。想要了解 B+ Tree 的结构那么就需要从 B-Tree 入手了。

#### B-Tree 的为什么可以作为索引实现的原因
B-Tree 是为磁盘等外存储设备设计的一种平衡查找树。 所以因此在讲 B-Tree 之前先了解下磁盘的相关知识。

1. 系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的， 位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。


2. InnoDB 存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB 存储引擎中默认每个页的大小为 16KB，可通过参数 **innodb_page_size** 将页的大小设置为 4K、8K、16K... 在 MySQL 中可通过如下命令查看页的大小：
```sql
show variables like 'innodb_page_size';
```

3. 而系统一个磁盘块的存储空间往往没有这么大，因此 InnoDB 每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小 16KB。InnoDB 在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘 I/O 次数，提高查询效率。

B-Tree 结构的数据可以让系统高效的找到数据所在的磁盘块。


#### B-Tree 的节点的样子
![Alt ''](https://s1.ax1x.com/2020/03/18/80UbIH.png)

在 MySQL 中是这样子的:  
![Alt ''](https://s1.ax1x.com/2020/03/18/80dKjP.png)  
每个节点中 key 是一个 2 元组，[key, key 对应的数据 data]

#### B-Tree 的样子
![Alt ''](https://s1.ax1x.com/2020/03/18/80amLT.png)

### B-Tree 的一些定义
>1. B-Tree，即 B 树，它是一种平衡多路查找树, 多路说明它的节点可以拥有多个(一般都是 > 2)子节点。
>2. 描述一颗 B 树时需要指定它的阶数，阶数表示了一个结点**最多**有多少个孩子结点，一般用字母 M 表示阶数。
>3. 度(Degree) : 度可以约束节点的 key 和指针的数量，每个非叶子结点由 n-1 个 key 和 n 个指针组成，其中 d<=n<=2d; 每个叶子结点至少包含一个 key 和两个指针, 最多包含 2d-1 个 key 和 2d 个指针，叶结点的指针均为 NULL。
>4. 树的每个叶子节点都在同一层，深度等于树的高度。

#### B-Tree 的特点

对于一棵 m(m>2) 阶的 B-Tree，有以下特点
>1. 每个节点最多有m个子节点
>2. 根节点的子树数目至少有 2 个子节点
>3. 除根节点和叶子节点，其它每个节点至少有 m/2(向上取整) 个子节点
>4. 所有叶子节点都在同一层

>5. 每个节点的 key 的个数满足：[m/2(向上取整) - 1, m - 1]
>6. 统一高度的节点里面的 key 值升序排序

>7. 每个节点的指针个数等于叶子节点的个数，也就是 [m/2(向上取整) , m]
>8. 设 a 是 KEY 的左指针, b 是 key 的右指针，存在 a 指向的节点的所有 key 的值小于 KEY, b 指向的所有 key 的值大于 KEY
>9. 叶子节点的指针都指向 NULL

![Alt 'B-Tree'](https://s1.ax1x.com/2020/03/18/8DKqG8.png)

每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的 key 和三个指向子节点的指针，指针存储的是子节点所在磁盘块的地址。两个 key 划分成的三个范围域对应三个指针指向的子节点的数据的范围域。以根节点为例，key 为 17 和 35，P1 指针指向的子树的数据范围为小于 17，P2 指针指向的子树的数据范围为 [17, 35]，P3 指针指向的子树的数据范围为大于 35。

模拟查找关键字 29 的过程
>1. 根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第 1 次】
>2. 比较key 29 在区间（17,35），找到磁盘块 1 的指针 P2。
>3. 根据 P2 指针找到磁盘块 3，读入内存。【磁盘I/O操作第 2 次】
>4. 比较关键字 29 在区间（26,30），找到磁盘块 3 的指针 P2。
>5. 根据 P2 指针找到磁盘块 8，读入内存。【磁盘I/O操作第 3 次】
>6. 在磁盘块 8 中的关键字列表中找到关键字 29。

分析上面过程，发现需要 3 次磁盘 I/O 操作，和 3 次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而 3 次磁盘 I/O 操作是影响整个 B-Tree 查找效率的决定因素。B-Tree 相对于 AVLTree 缩减了节点个数，使每次磁盘 I/O 取到内存的数据都发挥了作用，从而提高了查询效率。


## B+ Tree
B+Tree 是在 B-Tree 基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用 B+Tree 实现其索引结构。

从 B-Tree 结构图中可以看到每个节点中不仅包含数据的 key 值，还有 data 值。而每一个页的存储空间是有限的，如果 data 数据较大时将会导致每个节点（即一个页）能存储的 key 的数量很小, 当存储的数据量很大时同样会导致 B-Tree 的深度较大，增大查询时的磁盘 I/O 次数, 进而影响查询效率。在 B+Tree 中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储 key 值信息，这样可以大大加大每个节点存储的 key 值数量，降低 B+Tree 的高度。


B+Tree 相对于 B-Tree 有几点不同：
>1. 非叶子节点只存储键值信息
>2. 数据记录都存放在叶子节点中
>3. 所有叶子节点之间形成了双向链表

 
将上一节中的 B-Tree 优化，由于 B+Tree 的非叶子节点只存储键值信息，假设每个磁盘块能存储 4 个键值及指针信息，则变成 B+Tree 后其结构如下图所示：

![Alt ''](https://s1.ax1x.com/2020/03/18/8DdODx.png)

通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点,所有叶子节点（即数据节点）之间是一种双向链式环结构。
其中：指向根节点的指针用于从根节点开始，进行随机查找。 指向最小的叶子节点的指针可以用于对于主键的范围查找和分页查找。

可能上面例子中只有 22 条数据记录，看不出 B+Tree 的优点，下面做一个推算：

InnoDB 存储引擎中页的大小为 16KB, 一般表的主键类型为 INT（占用4个字节）或 BIGINT（占用8个字节），指针类型也一般为 4 或 8 个字节, 也就是说一个页（B+Tree 中的一个节点）中大概存储 16KB/(8B+8B)=1K 个键值, （因为是估值，为方便计算，这里的K取值为〖10〗^3）。也就是说一个深度为3的B+Tree索引可以维护 10^3 * 10^3 * 10^3 = 10 亿条记录。

实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree 的高度一般都在 2 ~ 4 层。MySQL的 InnoDB 存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要 1 ~ 3 次磁盘 I/O 操作。


数据库中的 B+Tree 索引可以分为聚集索引（clustered index）和 辅助索引（secondary index）。上面的 B+Tree 示例图在数据库中的实现即为聚集索引，聚集索引的 B+Tree 中的叶子节点存放的是整张表的行记录数据。辅助索引与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键。当通过辅助索引来查询数据时，InnoDB 存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据。


## B+ Tree 在数据库中的作用

#### B+ Tree 在数据库中的结构
![Alt 'B+ Tree 的结构'](https://s1.ax1x.com/2020/03/20/86IzWD.png)

特点：
>1. 除了叶子节点，每个节点存放的都是 指针 + key
>2. 同一层的节点的 key 从依次递增
>3. key 是数值大于左指针指向的子节点的 key, 而小于右指针指向的子节点的 key (在实际中，key 可能是小于于等于左子节点的 key, 或者小于等于右子节点的 key, 这样最终才能在叶子节点找到这个 key 对应的 数据) 
>4. key 和 key 对应的数据都在叶子节点, 同样, 按照 key 的值从左往右递增
>5. 叶子节点之间是双向链表的结构
>6. 每个节点的大小相等于一个页的大小, 不同引擎对于页的大小不一样，InnoDB 一页 = 16 k
>7. 非叶子节点的指针也是会占大小的，一般是 4/8 个字节 = 32/64 b

#### B+ Tree 为什么可以加速查询
B+ Tree 除了叶子节点外，每个节点存放的都是指向下一级的指针和 key(建立索引列的值)。  
在使用索引查询时存储引擎不需要全表扫描, 而是从根节点, 按照二分查找的方式， 通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点, 达到最后的叶子节点，
在叶子节点最终那么找不到对应的记录，要么找到了需要的记录。

简单的来说就是：避免了全表扫描，二分查找的方式提高了查询速率。

#### 复合索引
在 MySQL 允许将几列组合起来，变成一个复合索引。  
比如：有一张表,
```sql
CREATE TABLE People (
   last_name varchar(50)    not null,
   first_name varchar(50)    not null,
   dob        date           not null,
   gender     enum('m', 'f') not null,
   key(last_name, first_name, dob)
);
```
在这张表里面将 last_name, first_name, dob 三列建成了一个复合索引, 那么他们在索引结构是怎么样的。
![Alt 'B+Tree 复合索引'](https://s1.ax1x.com/2020/03/20/86ONUs.jpg)

从图中，可以知道，节点里面的 key 是我们三列的值, 同时他们的顺序是完全按照声明时的顺序。

看一下最后两个条目, 两个人的姓和名都一样, 则根据他们的出生日期来排列顺序。 也就是 key 的排序是按照，第一列排序，第一列相同，比较第二列，依次类推。

因为这个特点: 在使用复合索引的时候, 需要注意一个**最左原则**
>1. 查询条件里面的列全部都有时：

在查询时，条件里面的列的顺序和建立索引的顺序一样，才能其作用。如这时你的条件为`where first_name = 'AA' and last_name = 'BB' and dob = '1233-12-12'`, 条件没法和索引的顺序匹配上，这时查询不会走索引查询。正确的顺序应该是这样的 `where last_name = 'BB' and first_name = 'AA' and  dob = '1233-12-12'`, 条件和索引匹配得上了。

>2. 查询条件里面只包含的索引的一部分:

那么如果要走索引，那么条件里面必须包含符合索引的第一列，没有是不会走索引的。比如查询条件是 `where first_name = 'AA' and dob = '1233-12-12'`, 这时也是不会走索引的。(即使包含了第一列，这一列需要在第一个，才会走索引)


#### 使用 B+ tree 索引有以下一些限制
>1. 如果不是按照索引的最左列开始查找, 则无法使用索引。 
>2. 不能跳过索引中的列。比如索引为`a,b,c`, 查询时用的了`a,c`，MySQL只能使用索引的第一列。 
>3. 如果查询中有某个列的范围查询, 则其右边所有列都无法使用索引优化查找。 比如索引为`a,b,c`, 查询时用的了`where a = 1 and b like 'cc%' and c =  2`，这个查询 只能使用索引的前两列， 因为这里 LIKE 是一个范围条件


#### 索引失效的一些情况
>1. 复合索引，不符合最左原则
>2. 如果条件中有 or，其中有一个条件带索引也不会使用。 比如用户表有 id 主键，user_id 普通的列，查询 `select * from t_user where id = 1 or user_id = 1`。这样也是不会走索引的，除非 or 的条件的每一列都有索引。
>3. like 查询是以 % 开头
>4. 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来, 否则不使用索引
>5. 有时 MySQL 估计全表扫描比索引查询快，也会出现不使用索引(一般都是索引建立不合适造成的)
>6. 对索引列进行运算 比如 `select * from t_user where id = 1 * 10`
>7. 使用了 not in ,not exist
>8. B+ Tree 索引 is null 不会走, is not null 会走

备注 like '值%' 这种情况, 也不一定会走索引, 比如表中有一列 name, name 的值都为 "aaa-1", "aaa-2" ...

当你的 sql 语句是 `select * from 表名 where name like 'aaa-%'`; 他是全表扫描  

当你的 sql 语句是 `select * from 表名 where name like 'aaa-1%'`; 走索引

#### 为什么选择 B+ Tree 作为索引的实现?

>1. 普通的平衡二叉树, 每个节点只能存放一个索引，随着索引数量的增加，很快树的高度会很高，而 B+ Tree 每个节点可以存放多个索引，这样可以使我们的树的高度矮胖，减少了 I/O 操作

>2. 操作系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的。 InnoDB 每次申请大小是以页为单位的(一般情况下一页的大小是 4k, 但是在 InnoDB 中默认一页是 16K)，也就是会一次性申请若干个磁盘块，以达到一页的大小。而 MySQL 在设计中，把树中的每一个节点的大小设置为一页的大小，那么就有一个节点的大小刚好只需要一次 I/O。B+Tree 除叶子节点外存储的是 指针+ key, 而 B-Tree 存储的是 指针 + key + data，那么在确定大小的情况，B+Tree 理所当然的可以在一次 I/O 总读取更多的索引。这样树的高度可以降低。 I/O 利用率的提升。

>3. B+Tree 是绝对平衡的，既叶子节点到根节点的高度都是一样的。而且数据都是存储在叶子节点。这样基本每次查询，基本经过的节点都是一样的，也就是每次查询消耗的时间基本差不多的。而 B-Tree 的数据是分散在各个节点上的，可能在根节点就找到了数据，也可能艾叶子节点找到数据，时间差比较大(期间涉及节点 I/O 操作)，也就是 B+Tree 查询稳定。

>4. 通常在 B+Tree 上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。在排序时, 找到需要的记录，可以通过链表直接找到其他的。而 B-Tree, 可能还需要去别的节点查找需要的记录。所以 B+Tree 在基于索引的范围查找和排序能力比较强


#### 主键索引和其他索引的区别
在 B+ Tree 中，主键索引的叶子节点存放的是数据。但是其他索引的叶子节点存放的是主键的值。在使用其他索引时，是通过其他索引找到主键索引的值，在通过这个值在主键索引里面找到需要的记录。

为什么这样设计呢? InnoDB 中, 索引和数据是维护在同一个文件里面的。
>1. 如果在主键维护了一份记录，在其他索引也维护一份记录?   那么随着表中的索引的增加，文件会越来越大。同时记录的值改变了，那么每个索引的值都要修改

>2. 其他索引的叶子节点存放指针，这个指针指向的数据的地址?  
因为为了保持 B+Tree 的平衡，在进行增删等操作，都会导致索引结构的改变，这是维护在叶子节点的记录的地址也会改变，这样就需要回到其他索引进行修改，增加了维护难度。

## 参考
[MySQL索引原理](https://blog.csdn.net/u013235478/article/details/50625677)
