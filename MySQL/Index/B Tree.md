# B Tree

## B-Tree 

### B-Tree 的作为可以作为索引实现的原因
B-Tree 是为磁盘等外存储设备设计的一种平衡查找树。 所以因此在讲 B-Tree 之前先了解下磁盘的相关知识。

1. 系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的， 位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。


2. InnoDB 存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB 存储引擎中默认每个页的大小为 16KB，可通过参数 **innodb_page_size** 将页的大小设置为 4K、8K、16K... 在 MySQL 中可通过如下命令查看页的大小：
```sql
show variables like 'innodb_page_size';
```

3. 而系统一个磁盘块的存储空间往往没有这么大，因此 InnoDB 每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小 16KB。InnoDB 在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘 I/O 次数，提高查询效率。

B-Tree 结构的数据可以让系统高效的找到数据所在的磁盘块。



### B-Tree 的节点的样子
![Alt ''](https://s1.ax1x.com/2020/03/18/80UbIH.png)

在 MySQL 中是这样子的:  
![Alt ''](https://s1.ax1x.com/2020/03/18/80dKjP.png)  
每个节点中 key 是一个 2 元组，[key, key 对应的数据 data]

### B-Tree 的样子
![Alt ''](https://s1.ax1x.com/2020/03/18/80amLT.png)

### B-Tree 的一些定义
>1. B-Tree，即 B 树，它是一种平衡多路查找树, 多路说明它的节点可以拥有多个(一般都是 > 2)子节点。
>2. 描述一颗 B 树时需要指定它的阶数，阶数表示了一个结点**最多**有多少个孩子结点，一般用字母 M 表示阶数。
>3. 度(Degree) : 度可以约束节点的 key 和指针的数量，每个非叶子结点由 n-1 个 key 和 n 个指针组成，其中 d<=n<=2d; 每个叶子结点至少包含一个 key 和两个指针, 最多包含 2d-1 个 key 和 2d 个指针，叶结点的指针均为 NULL。
>4. 树的每个叶子节点都在同一层，深度等于树的高度。

### B-Tree 的特点

对于一棵 m(m>2) 阶的 B-Tree，有以下特点
>1. 每个节点最多有m个子节点
>2. 根节点的子树数目至少有 2 个子节点
>3. 除根节点和叶子节点，其它每个节点至少有 m/2(向上取整) 个子节点
>4. 所有叶子节点都在同一层

>5. 每个节点的 key 的个数满足：[m/2(向上取整) - 1, m - 1]
>6. 统一高度的节点里面的 key 值升序排序

>7. 每个节点的指针个数等于叶子节点的个数，也就是 [m/2(向上取整) , m]
>8. 设 a 是 KEY 的左指针, b 是 key 的右指针，存在 a 指向的节点的所有 key 的值小于 KEY, b 指向的所有 key 的值大于 KEY
>9. 叶子节点的指针都指向 NULL

![Alt 'B-Tree'](https://s1.ax1x.com/2020/03/18/8DKqG8.png)

每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的 key 和三个指向子节点的指针，指针存储的是子节点所在磁盘块的地址。两个 key 划分成的三个范围域对应三个指针指向的子节点的数据的范围域。以根节点为例，key 为 17 和 35，P1 指针指向的子树的数据范围为小于 17，P2 指针指向的子树的数据范围为 [17, 35]，P3 指针指向的子树的数据范围为大于 35。

模拟查找关键字 29 的过程
>1. 根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第 1 次】
>2. 比较key 29 在区间（17,35），找到磁盘块 1 的指针 P2。
>3. 根据 P2 指针找到磁盘块 3，读入内存。【磁盘I/O操作第 2 次】
>4. 比较关键字 29 在区间（26,30），找到磁盘块 3 的指针 P2。
>5. 根据 P2 指针找到磁盘块 8，读入内存。【磁盘I/O操作第 3 次】
>6. 在磁盘块 8 中的关键字列表中找到关键字 29。

分析上面过程，发现需要 3 次磁盘 I/O 操作，和 3 次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而 3 次磁盘 I/O 操作是影响整个 B-Tree 查找效率的决定因素。B-Tree 相对于 AVLTree 缩减了节点个数，使每次磁盘 I/O 取到内存的数据都发挥了作用，从而提高了查询效率。


## B+ Tree
B+Tree 是在 B-Tree 基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用 B+Tree 实现其索引结构。

从 B-Tree 结构图中可以看到每个节点中不仅包含数据的 key 值，还有 data 值。而每一个页的存储空间是有限的，如果 data 数据较大时将会导致每个节点（即一个页）能存储的 key 的数量很小, 当存储的数据量很大时同样会导致 B-Tree 的深度较大，增大查询时的磁盘 I/O 次数, 进而影响查询效率。在 B+Tree 中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储 key 值信息，这样可以大大加大每个节点存储的 key 值数量，降低 B+Tree 的高度。


B+Tree 相对于 B-Tree 有几点不同：
>1. 非叶子节点只存储键值信息
>2. 数据记录都存放在叶子节点中
>3. 所有叶子节点之间形成了双向链表

 
将上一节中的 B-Tree 优化，由于 B+Tree 的非叶子节点只存储键值信息，假设每个磁盘块能存储 4 个键值及指针信息，则变成 B+Tree 后其结构如下图所示：

![Alt ''](https://s1.ax1x.com/2020/03/18/8DdODx.png)

通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点,所有叶子节点（即数据节点）之间是一种双向链式环结构。
其中：指向根节点的指针用于从根节点开始，进行随机查找。 指向最小的叶子节点的指针可以用于对于主键的范围查找和分页查找。

可能上面例子中只有 22 条数据记录，看不出 B+Tree 的优点，下面做一个推算：

InnoDB 存储引擎中页的大小为 16KB, 一般表的主键类型为 INT（占用4个字节）或 BIGINT（占用8个字节），指针类型也一般为 4 或 8 个字节, 也就是说一个页（B+Tree 中的一个节点）中大概存储 16KB/(8B+8B)=1K 个键值, （因为是估值，为方便计算，这里的K取值为〖10〗^3）。也就是说一个深度为3的B+Tree索引可以维护 10^3 * 10^3 * 10^3 = 10 亿条记录。

实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree 的高度一般都在 2 ~ 4 层。MySQL的 InnoDB 存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要 1 ~ 3 次磁盘 I/O 操作。


数据库中的 B+Tree 索引可以分为聚集索引（clustered index）和 辅助索引（secondary index）。上面的 B+Tree 示例图在数据库中的实现即为聚集索引，聚集索引的 B+Tree 中的叶子节点存放的是整张表的行记录数据。辅助索引与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键。当通过辅助索引来查询数据时，InnoDB 存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据。


## 声明
本文转载至 [MySQL索引原理](https://blog.csdn.net/u013235478/article/details/50625677)，同时做了一小部分修改。



