# 分库分表



### 垂直拆分

>1. 垂直分表

“大表拆小表”，基于列字段进行的。一般是表中的字段较多，将不常用的， 数据较大，长度较长（比如text类型字段）的拆分到“扩展表“


>2. 垂直分库

一个数据库由很多表的构成，每个表对应着不同的业务，垂直切分是指按照业务将表进行分类，分布到不同的数据库上面，这样也就将数据或者说压力分担到不同的库上面。订单库，用户信息库


### 水平拆分

>1. 水平分表

针对数据量巨大的单张表（比如订单表），按照某种规则，切分到多张表里面去。 但是这些表还是在同一个库中

>2. 水平分库

将单张表的数据切分到多个服务器上去，每个服务器具有相应的库与表



#### 垂直拆分（库的层面）
比如： 订单系统

订单库  客户信息库，供应商信息库等



#### 垂直拆分（表的层面）
个人理解：
表上的垂直拆分
从用户的角度出发：将订单表在做一次水平拆分
主订单信息   附属订单信息


一个物流订单

寄件人的信息，收件人的信息，包裹信息，物品信息，订单状态信息

用户查询订单信息情况

1. 历史查询   分页查询 --> 概要信息  
2. 直接订单号查询      ---> 总信息


查询订单的信息


主订单表信息

| 主键 | 订单号   | 物品   |  价格    |   状态   |   客户Id| 日期


从订单表信息

| 同主订单表信息一样的主键 |  货到付款      | 收件信息| 包裹信息 |


物流物品列表  

| 物品 Id  | 物品信息  |  等等 |  |





水平规则：

分库的规则  userId 的后 4 位 % 2 的 n 次方（n > 1 ）

2 的 n 次方 的原因： 方便后续的扩容，而不需要修改到已有的

1234 % 4 = 2    1234 % 8 = 2   1234 % 16 = 2  
基本可以做到 后序动态扩容数据库的数量时，同一个用户的数据都在同一个 库 里面。


同时没一个库里面分为 32 个表（同样是 2 的 n 次方），同样是 可以分配到同一张表里面 

userId == 4 位， userId % 2 的 n 次方， 8192 是 2 的 n 次方 最大的 4 位数


订单号：
订单号规则：时间戳 + 用户Id的后 4 位 + 3随机数

自带分库分表：4位 UserId  
自带排序 ： 时间戳在前面  
基本无重复的可能  在1毫秒内后4位相同的用户连续下了 2 单，同时还有随机出来是随机数一样。



## 异构索引表
采用异步机制将原表内的每一次创建或更新，都换另一个维度保存一份完整的数据表或索引表，本质上这是互联网公司很多时候都采用的一个解决思路：“拿空间换时间”。

也就是应用在创建或更新一条按照订单ID为分库分表键的订单数据时，也会再保存一份按照买家ID为分库分表键的订单索引数据

订单信息表

订单索引表 ==> 用户 Id ，订单Id

通过用户Id 找到所有的订单 Id，返回应用，
应用在通过 订单 Id 在查询一遍
中间件会精确地将此SQL请求发送到后端包含in列表值中订单ID的数据库，而不会出现全表扫描的情况


为什么不是将订单的完整数据按照买家ID维度进行一次分库保存，这样就只需要进行一次按买家ID维度进行数据库的访问就获取到订单的信息。

一般来说，应用可能会按照多个维度创建多个异构索引表，所以采用这样数据全复制的方法会带来大量的数据冗余，从而增加不少数据库存储成本

有时会出现主表 join 从表，如果单纯的拷贝，也是需要把从表拷过去，


这时会出现分布式事务， 涉及2个以上的数据库




问题：
如果有些买家是交易量非常大的（这样的群体不在少数），会出现数据不平均的现象


参考
https://www.sunjs.com/article/detail/5b2efceaf91f421196f1ab5ff58c4bcc.html

https://tech.meituan.com/2016/11/18/dianping-order-db-sharding.html


















