# JVM

## 1. 内存模型
### 方法区的实现
###  常量池, 运行时常量池, 字符串常量池

## 2. 对象的内存模式

### Java 对象的内存结果

### 指针压缩

**在 64 位的机器上使用 32 位的引用的同时, 使用超过 4g 的内存**

1 个字节一个地址, 32 位系统的 2^32 个地址, 2^32 * 8个字节 = 4G,

在 32 位系统, 指针的大小只要 4 个字节就能包含所有的地址了, 也就是 4*8=32 位, 每位 0/1 2 种情况, 也就是 2^32 个位置
在 64 位系统, 则需要 8 个字节

在 64 位系统中, 一个指针的大小是 32 位的 2 倍,
64 位系统中, 堆更大的内存, 却也带来了其他性能问题, 对象占用的内存变大, 降低 CPU 缓存命中率等

为了能够利用 64 位系统的大内存的前提, 又能使用到 32 位系统的的小内存引用指针, 就有了指针压缩。

实现前提: 
Java 中实例对象的内存大小都是 8 的倍数, 一个数是 8 的倍数的话, 那么其二进制的表示的后面三位必定是 3 个 000 (8->1000, 16->10000)
JVM 知道每个 Java 对象的大小都是 8 的倍数, 正常存储的话, 每个的指针最后的 3 为必定都是 0, 那么这最后的 3 位完全没必要存了。
32 位空出来的 3 位, 完全可以用来存储多 3 位, 既将一个 35 位的指针用 32 位的形式存储在 JVM 中。
最终达到了用 32 位的位置表达 35 位指针的范围, 最终的能囊括的范围为 0 到 2^35 * 8 位 的内存大小, 既 32G 的大小。

### 对象的创建方式

1. 直接通过 new
2. 反射  Class.newInstance Constructor.newInstance
3. 通过 clone 方法
4. 反序列化
5. Unsafe.allocateInstance 

### 对象的创建过程

1. 检查类的加载
2. 分配内存
- 内存分配方式 (指针碰撞/空闲列表)
- 内存分配是的安全问题 (CAS + 失败重试, Thread Local Allocation Buffer，TLAB)
3. 空间初始化
4. 其他必要的设置
5. 执行 <init> 方法
- `<init>` 方法是当前类的代码块和构造函数的合并内容
- `<clinit>` 则是类的静态代码块的内容

执行顺序
Parent 的静态变量赋值
Parent 的静态代码块执行
Son 的静态变量赋值
Son 的静态代码块执行
Parent 的实例变量赋值
Parent 的代码块执行
Parent 的构造函数执行
Son 的实例变量赋值
Son 的代码块执行
Son 的构造函数执行

### Java 对象的访问
> 1. 句柄 
栈中的引用执行了句柄池, 句柄池的句柄一个指向堆中的数据, 一个指向了方法区的 Class
> 2. 直接指针, 栈中的指针, 指向了堆中的实例, 实例中有个 Class Pointer 指向方法区的 Class

## 对象回收
> 1. 引用计数算法 (Reference Counting)
> 2. 可达性分析算法 (Reachability Analysis)

引用计数算法

在对象中添加一个引用计数器, 每当有一个地方引用它时, 计数器值就加一。
当引用失效时, 计数器值就减一。任何时刻计数器为零的对象就是不可能再被使用的, 可以判定为可以回收的对象。

实现简单，判定的效率也很高, 但是复杂情景下, 不使用， a 持有 b, b 持有 a, a和b 都不需要了, 但是引用数都为 1

可达性分析算法

固定可作为 GC Roots 的对象有
1. 本地方法栈, 虚拟机栈中引用的对象
2. 在方法区中类静态属性引用的对象
3. 在方法区中常量引用的对象
4. Java 虚拟机内部的引用, 如基本数据类型对应的 Class 对象
5. 被同步锁持有的对象

步骤
1. 根节点枚举, 这一步骤时都是必须暂停用户线程的, 在分析过程, 根节点集合的对象引用关系不会发生变化
2. 引用链查询标记
- 三色标记法
可能出现的情况
  - 多标了, 浮动垃圾, 下次回收
  - 漏标了, 

1. 灰色对象断开了白色对象的直接或间接引用  -->  原始快照
当灰色对象要删除指向白色对象的引用关系时, 就将这个要删除的引用记录下来, 在并发扫描结束之后, 再将这些记录过的引用关系,
标记为灰色, 然后以这些灰色对象为根, 重新扫描一次标记为灰色, 然后以这些灰色对象为根, 重新扫描一次
   

2. 黑色对象重新引用了该白色对象           --> 增量更新
   当黑色对象插入新的指向白色对象的引用关系时, 就将这个新插入的引用记录下来, 等并发扫描结束之后, 再将这些记录过的 引用关系为根, 重新扫描一次

finalize
每个对象的 finalize 方法只会被执行一次

CMS
初始标记
并发标记
重新标记
并发清除


栈帧
> 1. 局部变量表  用于存放方法参数和方法内部定义的局部变量
> 2. 操作数栈   数, 还是存储的是字节码操作需要的数
> 3. 动态链接   一个指向运行时常量池中该栈帧所属方法的引用, 持有这个引用是为了支持方法调用过程中的动态连接
> 4. 返回地址  在方法退出之后, 都必须返回到最初方法被调用时的位置, 程序才能继续执行


