# 2 Redis - 事务

## 2.1 简单了解

Redis 事务可以在一个单独的步骤中执行一组命令, 其本身提供了 2 个重要的支持
> 1. 事务是一个单独的隔离操作：事务中的所有命令都会序列化, 按顺序地执行。事务在执行的过程中, 不会被其他客户端发送来的命令请求所打断。
> 2. 事务是一个原子操作：事务中的命令要么全部被执行, 要么全部都不执行


备注:  
**EXEC** 命令会将事务中的所有命令都执行。 所以, 如果一个客户端和服务端之间的连接断了, 那么事务中的所有命令都不会被执行。  

当使用 **AOF** 方式做持久化的时候, Redis 会使用单个 **write(2)** 命令将事务写入到磁盘中。
然而, 如果 Redis 崩溃或者被管理员的杀死的话, 那么可能只有部分事务命令会被成功写入到磁盘中。  
如果 Redis 在重新启动时发现 AOF 文件出了这样的问题, 那么它会退出，并汇报一个错误。
可以通过 **redis-check-aof** 工具修复这一问题, 它会移除 AOF 文件中不完整事务的信息，确保服务器可以顺利启动。

在 Redis 2.2 后, Redis 提供了**乐观锁（optimistic lock）和 CAS （check-and-set）操作**。

## 2.2 涉及事务的命令

涉及 Redis 事务的 4 个命令：**MULTI (开启事务)**, **EXEC (执行事务)**, **DISCARD (取消事务)**, **WATCH (监视)**


例子: 用户 A 存款 1000, 用户 B 存款 100, 现在 A 向 B 转账 100。

```sh

> set A 1000
OK
> set A 100
OK
> multi
OK
> decrby A  100
QUEUED
> incrby B 100
QUEUED
> exec
> (integer) 900
> (integer) 200

```

如上:   
MULTL 用于开启一个事务，返回值总是 **OK**。事务不能嵌套，多个 multi 命令效果一样。  
MULTI 执行之后, 客户端可以继续向服务器发送任意多条命令, 这些命令不会立即被执行, 而是被放到一个队列中, 当 EXEC 命令被调用时, 所有队列中的命令才会被执行 (同样可以通过调用 **DISCARD**, 客户端可以清空事务队列, 并放弃执行事务)。

调用 EXEC, 将会将队列中的事务全部执行, 返回值是一个数组, 数组中的内容为事务中每条执行的执行返回结果。

在事务中, 发送的每条命令不会立即被执行, 这是会返回一个 **QUEUED** 的返回值。

### 2.2.1 watch - 实现 CAS 操作

例子

| client A    |  client B|
| :-:   | :-: |
| set balance 1000|  |
| watch balance |   |
| multi |   | 
| incrby balance 100 | |
|    |  decrby balance 100|
| exec (此处的返回值为 nil, 执行失败) |   |

watch 命令为 Redis 事务提供 CAS 乐观锁行为 (Check and Set / Compare and Swap)。在多线程下, 在事务执行时, 会跟原来的值做比较, 只有在未被修改的情况下，才更新成新的值。

watch 支持监听多个 key, 在事务开启后, 只要有一个被修改过, 那么整个事务都会回滚。

可以通过 **unwatch** 取消对某个 key 的监听, 但是只能在事务开启之前使用, 事务中不起作用。

watch 使用中的一些注意点  
> 1. watch 一个带有超时时间的 key, 如果这个 key 过期了, 事务仍然可以起作用
> 2. 对 key 的监视从 watch 执行之后开始生效, 直到调用 exec 为止, 无论执行结果如何。
> 3. 当客户端断开连接时, 该客户端对键的监视也会被取消

## 2.3 事务中的错误

在使用事务时可能会遇上以下两种错误
> 1. 事务在执行 EXEC 之前, 入队的命令可能会出错, 比如: 参数错误。 或者应用本身的错误, 比如: 内存不够等。
> 2. EXEC 执行失败之后, 报错。 如前期输入的错误命令行, 执行失败等

第一种情况, 可以根据入队时的返回结果, 是否为 **QUEUED**, 如果不是的话, 客户端手动失败。  
在 Redis 2.6.5 后, 服务器会对命令入队失败的情况进行记录, 并在客户端调用 **EXEC** 命令时，拒绝执行并自动放弃这个事务。

第二种情况, 会依次执行事务中的命令, 如果执行了若干条后出现了一条异常的命令, 这条异常的命令会被忽略, 然后继续执行剩下的命令。

## 2.4 为什么 Redis 不支持回滚
> 1. Redis 命令只会因为错误的语法而失败 (并且这些问题不能在入队时发现), 或是命令用在了错误类型的键上面。这也就是说, 从实用性的角度来说, 失败的命令是由编程错误造成的, 而这些错误应该在开发的过程中被发现, 而不应该出现在生产环境中。
> 2. 因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。


## 2.5 参考
[事务（transaction）](http://redisdoc.com/topic/transaction.html)