# MySQL Index


## 1. 索引是什么
A database index is a **data structure** that improves the speed of operations in a table. Indexes can be created using one or more columns, providing the basis for both **rapid random lookups** and **efficient ordering of access to records**.

数据库索引是一种数据结构，它可以提高表中的操作速度。可以使用一个或多个列创建索引，这为快速随机查找和对记录的高效排序提供了基础。

## 2. 索引的类型

**数据结构:** (1) B-Tree 索引 (2) Hash 索引 (3) R-Tree 索引  (4) FullText 索引
 
**逻辑角度:** (1) 普通(单列)索引 (2) 唯一索引 (3) 主键索引  (4) 复合(多列/组合)索引 (5) 空间索引

**物理存储:** (1) 聚集索引  (2) 非聚集索引

## 3. 索引的分析

### 3.1 从数据结构角度了解索引

#### 3.1.1 B-Tree 索引
因为 B+ 树索引的内容比较多，单开了一遍文章，详情可以看[这里](https://github.com/LCN29/TechnicalSystem/blob/master/MySQL/Index/B%2B%20Tree%20%E7%B4%A2%E5%BC%95.md)

#### 3.1.2 Hash 索引 
Hash 索引是基于哈希表实现的。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希存储在索引中，同时将这个哈希码对应的数据行的指针也一起保存在索引中。  

索引的大概结构：**哈希值 + 数据行指针**。

SQL 执行的过程大概是这样的：根据查询条件的列，计算出 hash 值，然后在索引里面根据这个 hash 值找到对应的行，得到数据行的指针，通过指针到真正的表去查询。

使用 Hash 索引为什么能加快查询
>1. 通过 哈希码 可以快速定位到对应的列在索引中的位置，得到位置就是得到了真正数据行在表中的那一行。
>2. 哈希码 是一个比较小的值，计算量不大
>3. 索引自身只需存储对应的哈希值和哈希值对应的列的指针，结构简单

MySQL 中，只有 **Memory** 存储引擎显示支持 hash 索引。支持的还是非唯一 hash 索引，如果多个值有相同的 hash Code，索引把它们的行指针用链表保存到同一个 hash 表项中。(类似于 Java 中的 HashMap 的链表)

Hash 索引也有它的限制：
>1. 哈希索引只包含哈希值和行指针, 而不存储字段值, 所以不能使用索引中的值来避免读取行。 不过, 访问内存中的行的速度很快, 所以大部分情况下这一点对性能的影响并不明显。 
>2. 哈希索引数据并不是按照索引值顺序存储的, 所以也就无法用于排序。 
>3. 哈希索引也不支持部分索引列匹配查找, 因为哈希索引始终是使用索引列的全部内容来计算哈希值的。 
>4. 哈希索引只支持等值比较查询, 包括=、IN() 等，但是也不支持任何范围查询。
>5. 当出现哈希冲突的时候, 存储引擎必须遍历链表中所有的行指针, 逐行进行比较, 直到找到所有符合条件的行。 
>6. 如果哈希冲突很多的话, 一些索引维护操作的代价也会很高。 比如删除某一行，需要遍历 Hash 链表中的每一行，找到需要删除的

InnoDB 引擎有一个特殊的功能叫做“自适应哈希索引”。当 InnoDB 注意到某些索引值被使用得非常频繁时，它会在内存中基于 B-Tree 索引上再创建一个哈希索引，这样就像 B-Tree 索引也具有哈希索引的一些优点，比如快速的哈希查找。这是一个完全自动的、内部的行为, 用户无法控制或者配置, 不过如果有必要, 完全可以关闭该功能。 


#### 3.1.3 R-Tree 索引
MyISAM 表支持空间索引, 可以用作地理数据存储, 例如 GEOMETRY。 这类索引无须前缀查询。 空间索引会从所有维度来索引数据。 查询时, 可以有效地使用任意维度来组合查询。必须使用 MySQL 的 GIS 相关函数如 MBRCONTAINS() 等来维护数据。MySQL 的 GIS 支持并不完善，所以大部分人都不会使用这个特性。

#### 3.1.4 FullText 索引
全文索引是 MyISAM 的一个特殊索引类型，Innodb 的 5.6 以上版本也支持，它查找的是文本中的关键词主要用于全文检索。  

全文索引是一种特殊类型的索引，可以在 VARCHAR 或者 TEXT 类型的列上创建。它查找都是文本中的关键词，而不是直接比较索引中的值。全文搜索和其他几类索引匹配方式完全不一样。它有许多需要注意的细节，如停用词、词干和复数、布尔搜索等。全文索引更类似于搜索引擎做的事情，而不是简单的 WHERE 条件匹配。


### 3.2 从逻辑角度了解索引

#### 3.2.1 普通(单列)索引
这是最基本的索引类型，而且它没有唯一性之类的限制，可以用表中的普通列直接创建。唯一任务是加快对数据的访问速度。因此，应该只为那些最经常出现在查询条件（WHERE column=）或者排序条件（ORDERBY column）中的数据列创建索引。

#### 3.2.2 唯一索引
这种索引和前面的 “普通索引” 基本相同，但有一个区别：索引列的所有值都只能出现一次，即必须唯一, 但是允许为 null。

#### 3.2.3 主键索引
主键是一种 “唯一索引”，但它必须指定为 "PRIMARY KEY"。建立索引的列不允许重复，不允许空值。

#### 3.2.4 复合(多列/组合)索引
用多个列组合构建的索引，这多个列中的值不允许有空值。

复合索引存在的意义：  
在实际的应用中，进行查询很多时候都是多个条件进行筛选的。  
比如现在有一张用户表，表里有: 用户Id, 姓名，年龄，出生日期。在查询的时候，如果很多时候都是把这 3 个条件都加入筛选条件的话。如何建立索引比较好呢?

>1. 单独每个字段都建立一个索引
有一定的提示查询效果，但是不是最好的。当我们执行查询的时候，MySQL 只能使用一个索引。如果你有三个单列的索引，MySQL会试图选择一个限制最严格的索引。但是，即使是限制最严格的单列索引, 也只能帮我们定位到某一个范围。比如把出生日期缩小范围到 `2010-10-11`。然后在这个范围逐一比较 姓名，年龄。

>2. 将这 3 列组装成 1 个复合索引
在 B+ Tree 索引中，他们组成的索引是这样的 [姓名, 年龄，出生日期]。都维护在非叶子节点上。然后会依次比较 姓名，年龄，出生日期，直到定位到需要的列。 也就是这三个条件都能用上，把范围再次缩小了。

复合索引虽然提供了多条件查询的方便，但是在使用的过程也需要注意，比如最左原则，建立索引的列的选择, 顺序等。

#### 3.2.5 空间索引
空间索引只能建立在空间数据类型上，这样可以提高系统获取空间数据的效率。MySQL 中的空间数据类型包括 GEOMETRY 和 POINT、LINESTRING 和 POLYGON 等。目前只有 MyISAM 存储引擎支持空间检索，而且索引的字段不能为空值。

### 3.3 从数据结构角度了解索引

聚簇索引就是一种数据的存储方式。  
聚簇索引就是数据库表中行的数据的物理顺序与键值的逻辑(索引)顺序相同, 同时保证关键字的值相近的行存储的物理位置也相近。

在《数据库原理》一书中是这么解释聚簇索引和非聚簇索引的区别的：
聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。

下图形象说明了聚簇索引表 (InnoDB) 和非聚簇索引 (MyISAM) 的区别：
![Alt '聚簇索引和非聚簇索引'](https://s1.ax1x.com/2020/03/23/8Tj3Dg.png)

**聚簇索引表(左图)**：  
表数据是和主键一起存储的，主键索引的叶结点存储行数据(包含了主键值)。

二级索引(辅助索引，除了主键索引外的其他索引类型)的叶结点存储行的主键值。

非叶子节点都是只存储索引关键字, 不存储对应记录的具体内容或内容地址。叶子节点上的数据是主键与具体记录(数据内容)


**非聚簇索引表(右图)**：
表数据和索引是分成两部分存储的，主键索引和二级索引存储上没有任何区别。

所有的节点都是索引，叶子节点存储的是索引 + 索引对应的记录的位置指针。

#### 3.3.2 聚簇索引的优点
>1. 数据访问更快。 聚簇索引将索引和数据保存在同一个B-Tree中, 因此从聚簇索引中获取数据通常比在非聚簇索引中查找要快 (这里可以理解为通过主键查询, 非聚簇索引定位到对应主键时还要多一次目标记录寻址, 即多一次 I/O)
>2. 使用覆盖索引扫描的查询可以直接使用页节点中的索引值
>3. 可以把相关数据保存在一起, 查询是减少 I/O。如把一个用户的所有邮箱聚簇在同一用户 Id 下，直接通过 Id 就能取到所有的邮箱。如果不使用，可能每个邮箱都需要一次 I/O 

#### 3.3.3 聚簇索引的缺点
>1. 更新主键的代价很高，因为将会导致被更新的行移动。所以一般情况下，都是主键不可变
>2. 二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据
>3. 采用聚簇索引插入新值比采用非聚簇索引插入新值的速度要慢很多。 插入之前需要判断主键是否存在。聚簇索引遍历所有的叶子节点，非聚簇索引也判断所有的叶子节点。但是聚簇索引的叶子节点包含了我们的数据，这样就会导致聚簇索引在判定新记录携带的主键是否重复时进行昂贵的I/O代价。
>4. 插入速度严重依赖于插入顺序,按照主键的顺序插入是最快的方式，否则将会出现"页分裂"，严重影响性能。如果是随机主键插入的话，可能导致整个索引数的频繁调整。因此，对于InnoDB表，我们一般都会定义一个自增的 ID 列为主键。

**[页分裂]:** 当行的主键值要求必须将这一行插入到某个已满的页中时, 存储引擎会将该页分裂成两个页面来容纳该行, 这就是一次页分裂操作。 页分裂会导致表占用更多的磁盘空间。 

**[顺序插入问题]:** 按照自增主键顺序插入的方式, 可能存在争用。主键的上界会成为“热点”。因为要插入的都发生在这里。所有并发会导致间隙锁的竞争。如果还一个“热点”就是 auto_increment 锁机制。这时候就需要考虑重新设计表或者应用。

#### 3.3.4 聚簇索引在 InnoDB 的使用
>1. InnoDB 引擎是默认使用主键来实现聚簇索引的，所以如果一张表没有主键，它会选择一个唯一的非空索引代替。 如果没有这样的索引, InnoDB 会隐式定义一个主键来作为聚簇索引。 
>2. 在 InnoDB 中，只有主键索引才是聚簇索引，其他的索引都是非聚簇索引, 同时一张表里面只允许一个聚簇索引

## 4. 覆盖索引
覆盖索引：指一个查询语句的执行只需要从索引中就可以得到查询记录，而不用从数据表中读取。也可以称之为实现了索引覆盖。

如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做覆盖索引。

从上面的解释中，我们可以知道覆盖索引并不是一种真正的索引，而是一种查询中刚好满足的情况。

只需要读取索引而不用读取数据有以下一些优点：
>1. 索引项通常比记录要小，所以 MySQL 访问更少的数据
>2. 索引都按值的大小顺序存储，相对于随机访问记录，需要更少的 I/O
>3. 大多数据引擎能更好的缓存索引。比如 MyISAM 只缓存索引。InnoDB 只存储了 B+ Tree 的根节点
>4. 覆盖索引对于 InnoDB 表尤其有用，因为 InnoDB 使用聚集索引组织数据，如果二级索引中包含查询所需的数据，就不再需要在聚集索引中查找了

对于索引覆盖查询(index-covered query)，使用 EXPLAIN 时，可以在 Extra 一列中看到 “Using index”。


## 5. 索引的好处
>1. 可以让服务器快速地定位到表的指定位置, 大大减少了服务器需要扫描的数据
>2. 可以帮助服务器避免排序和临时表
>3. 可以将随机 I/O 变为顺序 I/O

## 6. 高效索引的策略
(1) 不要让索引做一下隐式的转换
>1. 让索引进行计算  select * from table where index + 1 = 5;
>2. 字符串的索引，但是查询条件没有加引号 select * from table where str_index = 123; 这里的 123 应该用 ''包起来
>3. 使用函数进行了转换 select * from table  where date_format(birthday, '%Y%m%d%') = '20200321';

(2) 前缀(后缀)索引
有时候我们有一个字段很长，但是我们又需要为其建立索引，这时候，我们可以取这个字段的某一部分建立索引，这样虽然可能会出现相同的索引值，但是减少了索引的体积，加快了查询速度。(具体这个索引取原有字段的多少长度之类的，需要具体的分析， 创建的方式：add index (字段(需要多少位)))

(3) 伪 Hash 索引
同样的一个字段很长，但是涉及到频繁的查询，那么可以在原来的表结构上加上一列，用来存储这个长字段的计算后的 hash 值。查询的时候, 先将这个字段 hash 处理后，在查询。同时因为存在 hash 冲突的情况，所以在查询条件的后面还是需要加上准确的值。  
`select * from table where url_crc = crc32(条件) and url = 条件;`

使用的一些注意事项：用来计算 hash 的函数尽可能的在保证结果不会很长的情况下，尽可能的冲突小。这个 hash 函数可以自己实现等

(4) 聚簇索引  

(5) 覆盖索引

(6) 利用索引扫描来排序  
在 MySQL 中生成有序结果的方式有 2 种
>1. 直接通过排序操作
>2. 按索引顺序扫描

按索引扫描本身是很快的。因为只需要从一条索引记录移动到紧接着的下一条记录。 但如果索引不能覆盖查询所需的全部列, 那就不得不每扫描一条索引记录就都回表查询一次对应的行。 这基本上都是随机 I/O, 因此按索引顺序读取数据的速度通常要比顺序地全表扫描慢。 所以有可能的话，尽可能让同一个索引满足排序和查找行的功能，既这个索引能满足覆盖索引。

同时通过索引扫描还有一些要求
>1. 首先当然是符合最左原则，也就是 order by 后面的字段需要符合最左原则
>2. 在符合最左原则的基础上，所有的列的排序方向要一致，既要么都升序，要么都降序
>3. 联表查询时，只有 order by 后面的字段都是第一张表才会排序
>4. where 的条件和 order by 的条件一起满足最左原则，也是可以做索引的。比如，有索引(A, B, C), 查询的语句为 `select * from table where A = 'XXX' order by B, c Desc;` 虽然 order by 后面的条件不满足最左原则，但是和前面的 where 条件一起满足了。

## 7. 创建索引的建议
>1. 列值不会经常改变的，因为列值的改变，都会导致索引的重新构建
>2. 列值的选择如果比较少的，比如性别，这种列基本不需要索引
>3. 列值尽可能是 not null 设置
>4. 索引尽量建立在小字段, 索引也是会占空间的
>5. 复合索引的创建需要仔细分析，如果可以的话，通过单字段索引代替, 否则索引列的选择，列的顺序都是需要考虑的

## 8. mysql 中的最多问题
* 一张表最多可以有多少个列
* 一张表多少个索引
* 复合索引最多几列
* varchar最大长度是多少

如果单纯是这样的问题的话，很难有一个精确的答案的。
首先它涉及到 MySQL 的引擎，对应版本默认的一些配置, 选择的字符类型等。

比如 一张表可以建立一个复合索引，索引里面的可以有多少列。

>1. 确定是在某个引擎下
>2. 确定某个 MySQL 版本, 知道默认设置的 key 大小。比如在 MySQL 8.0.18 中，一个索引的长度有一个 Specified key 的限制，默认是 3072 b 的大小。一行的最大长度为 65535 b 等
>3. 索引里面的列的类型, 比如 int 32 位，varchar(XX) xx 位等
>4. 涉及的字符集类型 utf8 需要 3 个字节，utf8mb4 需要 4 个字节

影响的因素很多，所以不太好确定的。


## 9. 参考
[mysql索引之一：索引基础（B-Tree索引、哈希索引、聚簇索引、全文(Full-text)索引区别）（唯一索引、最左前缀索引、前缀索引、多列索引](https://www.cnblogs.com/duanxz/p/3799045.html)

《高性能 MySQL》