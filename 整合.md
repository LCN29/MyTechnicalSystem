

## 1 设计模式

### 1.1 装饰器模式和组合模式的区别

装饰者模式可以用来透明地把对象包装在**具有同样接口的另一个对象中**。这样一来，可以在调用原始对象的方法的过程中, 增加一下行为。

组合模式是一种结构型模式，用于把众多子对象组织为一个整体，在与大批对象打交道时可以将他们当作一个对象来对待，并将它们组织为层次性的树。  
通常它并不修改方法调用，而只是将其沿组合对象与子对象的链向下传递，直到到达并落实在叶对象上。

装饰者模式也是一种结构型模式，但它并非用于组织对象，而是用于在不修改现有对象或从其派生子类的前提下为其增添职责，目的就在于对方法进行修改。

二者却有着不同的焦点。组合对象并不修改方法调用，其着眼在点于组织子对象。
而装饰者模式存在的唯一目的就是修改方法调用而不是组织子对象，因为子对象只有一个。


### 1.2 23 种设计模式

创建型模式
> 1. 工厂方法模式
> 2. 抽象工厂模式
> 3. 单例模式
> 4. 建造者模式
> 5. 原型模式

结构型模式
> 1. 适配器模式
> 2. 装饰器模式
> 3. 代理模式
> 4. 外观模式
> 5. 桥接模式
> 6. 组合模式
> 7. 享元模式

行为型模式
> 1. 策略模式
> 2. 模板方法模式
> 3. 观察者模式
> 4. 迭代器模式
> 5. 责任链模式
> 6. 命令模式
> 7. 备忘录模式
> 8. 状态模式
> 9. 访问者模式
> 10. 中介者模式
> 11. 解释器模式



## 2 Spring

### 2.1 JDK 动态代理和 CGLIB 代理有什么区别

JDK 的动态代理是 java.lang.reflect.* 包提供的方式，它必须要借助接口才可以实现（这里需要注意，如果只有实现类是无法完成代理的）, 基于反射的机制实现，生成一个实现同样接口的一个代理类，然后通过重写方法的方式，实现对代码的增强

CGLIB 动态代理不需要提供接口，只要一个非抽象类就能实现动态代理，底层原理是基于 ASM 第三方框架，通过修改字节码生成一个子类，然后重写父类的方法，实现对代码的增强。

使用参考[JDK动态代理和CGLIB动态代理的异同](https://blog.csdn.net/long_long_later/article/details/106364407)

**静态代理**: 类似于装饰模式, 手动的的声明类来代理真正的实现类。

### 2.2 Spring 中使用到的设计模式

#### 2.2.1 单例模式

IOC 默认创建的 bean 的模式

#### 2.2.2 代理模式

AOP 默认的代理模式: JDK Proxy +  Cglib 

Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。

#### 2.2.3 工厂方法模式

```xml
<bean  factory-method="initMethod" id="factory" class = "com.can.Facotry"/>
```

**简单工厂模式**
重点：这个不属于 23 种设计模式之一。  
又叫做静态工厂方法, 实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类, spring 中的 BeanFactory 就是简单工厂模式的体现。

和正常的工厂方法模式不同点： 简单工厂的对象产生的方法一般可以根据入参产生同一个接口的不同对象, 而工厂方法模式一般都是只会产生一种对象。


#### 2.2.4 观察者模式

**事件角色**

ApplicationEvent: 充当事件的角色, 这是一个抽象类。

ContextStartedEvent：ApplicationContext 启动后触发的事件;
ContextStoppedEvent：ApplicationContext 停止后触发的事件;
ContextRefreshedEvent：ApplicationContext 初始化或刷新完成后触发的事件;
ContextClosedEvent：ApplicationContext 关闭后触发的事件。


**事件监听者角色**

ApplicationListener: 充当了事件监听者角色，它是一个接口，里面只定义了一个 onApplicationEvent 方法, 用来接收到事件进行处理。

**事件发布者角色**

ApplicationEventPublisher: 事件的发布者，它也是一个接口, 里面定义了一个 publishEvent 方法, 用来发布事件。  
通过 AbstractApplicationContext 这个抽象实现类, 可以简单了解到实际是通过 ApplicationEventMulticaster 来进行广播事件的。

#### 2.2.5 装饰器模式

Spring 中用到的包装器模式在类名上有两种表现：一种是类名中含有 Wrapper，另一种是类名中含有 Decorator

实质:
> 1. 动态地给一个对象添加一些额外的职责
> 2. 就增加功能来说，Decorator 模式相比生成子类更为灵活

ClientHttpRequestDecorator

TransactionAwareCacheDecorator 类相当于装饰器模式中的抽象装饰角色，主要用来处理事务缓存。

MVC 中的装饰器模式：HttpHeadResponseDecorator 类，相当于装饰器模式中的具体装饰角色。

Spring Session 通过 SessionRepositoryRequestWrapper 继承 ServletRequestWrapper，扩展了 Request，并在 SessionRepositoryFilter   
通过调用过滤链 filterChain.doFilter(strategyRequest, strategyResponse); 将装饰的 Request 传入下一流程。

#### 2.2.6 适配器模式

适配器模式主要包含以下主要角色
> 1. 适配者（Adaptee）类: 需要做转换的实际逻辑类
> 2. 目标（Target）接口：当前调用所期待的接口，它可以是抽象类或接口
> 3. 适配器（Adapter）类：它是一个转换器, 通过继承或引用适配者的对象, 把适配者接口转换成目标接口, 让客户按目标接口的格式访问适配者。

适配器模式分为类结构型模式和对象结构型模式两种, 前者类之间的耦合度比后者高, 且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。


**类适配器模式**

```java

interface Target {
    String request(String num);
}

class Adaptee {

    public int showNum(int num) {
        return num + 1;
    }
}

class ClassAdapter extends Adaptee implements Target {

    public String request(String num) {
        int result = showNum(Integer.valueOf(num));
        return String.valueOf(result);
    }
}

public class ClassAdapterTest {

    public static void main(String[] args) {

        System.out.println("类适配器模式测试：");
        Target target = new ClassAdapter();

        String temp = target.request("123");
        System.out.println("类适配器模式测试结果：" + temp);
    }
}
```


**对象适配器模式**

```java
class ObjectAdapter implements Target {

    private Adaptee adaptee;

    public ObjectAdapter(Adaptee adaptee) {
        this.adaptee = adaptee;
    }

    public String request(String num) {
        int result = adaptee.showNum(Integer.valueOf(num));
        return String.valueOf(result);
    }
}


public class ObjectAdapterTest {

    public static void main(String[] args) {

        System.out.println("对象适配器模式测试：");
        Adaptee adaptee = new Adaptee();
        Target target = new ObjectAdapter(adaptee);

        String temp = target.request("123");
        System.out.println("对象适配器模式测试结果：" + temp);

    }
}
```

[好玩Spring之适配器模式在Spring中的应用](https://blog.csdn.net/yuan882696yan/article/details/105602359)


#### 2.2.7 模板方法模式

定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。 模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤的实现方式。

AbstractApplicationContext.refresh() 方法


jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式










