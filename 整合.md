

## 1 设计模式

### 1.1 装饰器模式和组合模式的区别

装饰者模式可以用来透明地把对象包装在**具有同样接口的另一个对象中**。这样一来，可以在调用原始对象的方法的过程中, 增加一下行为。

组合模式是一种结构型模式，用于把众多子对象组织为一个整体，在与大批对象打交道时可以将他们当作一个对象来对待，并将它们组织为层次性的树。  
通常它并不修改方法调用，而只是将其沿组合对象与子对象的链向下传递，直到到达并落实在叶对象上。

装饰者模式也是一种结构型模式，但它并非用于组织对象，而是用于在不修改现有对象或从其派生子类的前提下为其增添职责，目的就在于对方法进行修改。

二者却有着不同的焦点。组合对象并不修改方法调用，其着眼在点于组织子对象。
而装饰者模式存在的唯一目的就是修改方法调用而不是组织子对象，因为子对象只有一个。


### 1.2 23 种设计模式

创建型模式
> 1. 工厂方法模式
> 2. 抽象工厂模式
> 3. 单例模式
> 4. 建造者模式
> 5. 原型模式

结构型模式
> 1. 适配器模式
> 2. 装饰器模式
> 3. 代理模式
> 4. 外观模式
> 5. 桥接模式
> 6. 组合模式
> 7. 享元模式

行为型模式
> 1. 策略模式
> 2. 模板方法模式
> 3. 观察者模式
> 4. 迭代器模式
> 5. 责任链模式
> 6. 命令模式
> 7. 备忘录模式
> 8. 状态模式
> 9. 访问者模式
> 10. 中介者模式
> 11. 解释器模式



## 2 Spring

### 2.1 JDK 动态代理和 CGLIB 代理有什么区别

JDK 的动态代理是 java.lang.reflect.* 包提供的方式，它必须要借助接口才可以实现（这里需要注意，如果只有实现类是无法完成代理的）, 基于反射的机制实现，生成一个实现同样接口的一个代理类，然后通过重写方法的方式，实现对代码的增强

CGLIB 动态代理不需要提供接口，只要一个非抽象类就能实现动态代理，底层原理是基于 ASM 第三方框架，通过修改字节码生成一个子类，然后重写父类的方法，实现对代码的增强。

使用参考[JDK动态代理和CGLIB动态代理的异同](https://blog.csdn.net/long_long_later/article/details/106364407)

**静态代理**: 类似于装饰模式, 手动的的声明类来代理真正的实现类。

### 2.2 Spring 中使用到的设计模式

#### 2.2.1 单例模式

IOC 默认创建的 bean 的模式

#### 2.2.2 代理模式

AOP 默认的代理模式: JDK Proxy +  Cglib 

Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。

#### 2.2.3 工厂方法模式

```xml
<bean  factory-method="initMethod" id="factory" class = "com.can.Facotry"/>
```

**简单工厂模式**
重点：这个不属于 23 种设计模式之一。  
又叫做静态工厂方法, 实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类, spring 中的 BeanFactory 就是简单工厂模式的体现。

和正常的工厂方法模式不同点： 简单工厂的对象产生的方法一般可以根据入参产生同一个接口的不同对象, 而工厂方法模式一般都是只会产生一种对象。


#### 2.2.4 观察者模式

**事件角色**

ApplicationEvent: 充当事件的角色, 这是一个抽象类。

ContextStartedEvent：ApplicationContext 启动后触发的事件;
ContextStoppedEvent：ApplicationContext 停止后触发的事件;
ContextRefreshedEvent：ApplicationContext 初始化或刷新完成后触发的事件;
ContextClosedEvent：ApplicationContext 关闭后触发的事件。


**事件监听者角色**

ApplicationListener: 充当了事件监听者角色，它是一个接口，里面只定义了一个 onApplicationEvent 方法, 用来接收到事件进行处理。

**事件发布者角色**

ApplicationEventPublisher: 事件的发布者，它也是一个接口, 里面定义了一个 publishEvent 方法, 用来发布事件。  
通过 AbstractApplicationContext 这个抽象实现类, 可以简单了解到实际是通过 ApplicationEventMulticaster 来进行广播事件的。

#### 2.2.5 装饰器模式

Spring 中用到的包装器模式在类名上有两种表现：一种是类名中含有 Wrapper，另一种是类名中含有 Decorator

实质:
> 1. 动态地给一个对象添加一些额外的职责
> 2. 就增加功能来说，Decorator 模式相比生成子类更为灵活

ClientHttpRequestDecorator

TransactionAwareCacheDecorator 类相当于装饰器模式中的抽象装饰角色，主要用来处理事务缓存。

MVC 中的装饰器模式：HttpHeadResponseDecorator 类，相当于装饰器模式中的具体装饰角色。

Spring Session 通过 SessionRepositoryRequestWrapper 继承 ServletRequestWrapper，扩展了 Request，并在 SessionRepositoryFilter   
通过调用过滤链 filterChain.doFilter(strategyRequest, strategyResponse); 将装饰的 Request 传入下一流程。

#### 2.2.6 适配器模式

适配器模式主要包含以下主要角色
> 1. 适配者（Adaptee）类: 需要做转换的实际逻辑类
> 2. 目标（Target）接口：当前调用所期待的接口，它可以是抽象类或接口
> 3. 适配器（Adapter）类：它是一个转换器, 通过继承或引用适配者的对象, 把适配者接口转换成目标接口, 让客户按目标接口的格式访问适配者。

适配器模式分为类结构型模式和对象结构型模式两种, 前者类之间的耦合度比后者高, 且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。


**类适配器模式**

```java

interface Target {
    String request(String num);
}

class Adaptee {

    public int showNum(int num) {
        return num + 1;
    }
}

class ClassAdapter extends Adaptee implements Target {

    public String request(String num) {
        int result = showNum(Integer.valueOf(num));
        return String.valueOf(result);
    }
}

public class ClassAdapterTest {

    public static void main(String[] args) {

        System.out.println("类适配器模式测试：");
        Target target = new ClassAdapter();

        String temp = target.request("123");
        System.out.println("类适配器模式测试结果：" + temp);
    }
}
```


**对象适配器模式**

```java
class ObjectAdapter implements Target {

    private Adaptee adaptee;

    public ObjectAdapter(Adaptee adaptee) {
        this.adaptee = adaptee;
    }

    public String request(String num) {
        int result = adaptee.showNum(Integer.valueOf(num));
        return String.valueOf(result);
    }
}


public class ObjectAdapterTest {

    public static void main(String[] args) {

        System.out.println("对象适配器模式测试：");
        Adaptee adaptee = new Adaptee();
        Target target = new ObjectAdapter(adaptee);

        String temp = target.request("123");
        System.out.println("对象适配器模式测试结果：" + temp);

    }
}
```

[好玩Spring之适配器模式在Spring中的应用](https://blog.csdn.net/yuan882696yan/article/details/105602359)


#### 2.2.7 模板方法模式

定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。 模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤的实现方式。

AbstractApplicationContext.refresh() 方法


jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式




### 2.3 循环依赖解决

Spring 中循环依赖可以区分为 3 种

1. 构造函数的循环依赖
2. 单例 bean 的属性循环依赖
3. 非单例 bean 的属性循环依赖

Spring 的循环依赖只能解决第 2 种情况, 其他 2 种的话, 无法解决。


单例 bean 的属性循环依赖的解决关键: 三级缓存

```java
public class DefaultSingletonBeanRegistry extends SimpleAliasRegistry implements SingletonBeanRegistry {

    /**
     * 一级缓存: 用于存放完全初始化好的 bean
     * key: beanName value: bean
     */
    private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);

    /**
     * 二级缓存: 存放原始的 bean 对象(尚未填充属性), 用于解决循环依赖
     * key: beanName  value: 为填充属性的 bean
     */
    private final Map<String, Object> earlySingletonObjects = new ConcurrentHashMap<>(16);

    /**
     * 三级缓存: 存放 bean 工厂对象，用于解决循环依赖
     * key： beanName, value: 可以获取到当前 bean 对象的 ObjectFactory 函数
     */
    private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>(16);

    /**
     * 正在创建的 beanName 集合
     */
    private final Set<String> singletonsCurrentlyInCreation = Collections.newSetFromMap(new ConcurrentHashMap<>(16));

    /**
     * 已经注册的 beanName
     */
    private final Set<String> registeredSingletons = new LinkedHashSet<>(256);
}
```

涉及到 Bean 的实例化的 4 个关键方法

> 1. getSingleton
> 2. doCreateBean
> 3. populateBean
> 4. addSingleton


假设现在有

```java
public class A {
    private B b;
}

public class B {
    private A a;
}
```


创建 class A 的 实例

> 1. 通过 getSingleton 去各级缓存中查找, 获取不到
> 2. A 实例未创建, 调用 doCreateBean 创建 A 的实例, 入参有 ObjectFactory, 这时 A 还未创建, 调用 ObjectFactory.getObject 方法获取实例, getObject实际是调用 createBean 进行 bean 的创建
> 3. 要创建的 bean 为单例, 入参的允许自动解决循环依赖为 true, 同时正在创建的 bean name 集合包含当前的 beanName, 向三级缓存中添加返回这个还没初始化的 bean, key 为 beanName, value 为 ObjectFactory, 实现逻辑为做了一点处理后, 返回 bean
> 4. 经过二, 三步得到了实例 A, 但是这时候 A 的属性还未初始化, 调用 populateBean 进行属性的填充, 通过 getSingleton 获取 B 的实例, 在各个缓存中获取不到, 开始创建类 B 的实例
> 5. 进行二, 三步, 这时得到了实例 B, 同样调用 populateBean 进行属性的填充
> 6. 通过 getSingleton 获取 A 的实例时, 这次在第三层缓存中获取到了能得到 A 的 ObjectFactory 函数, 调用其 getObject 得到了A 的实例, 这时候 A 还未初始化, 把获取到的 A 添加到二级缓存, 从三级缓存中移除 A 
> 7. 调用 addSingletion 把实例 B 放到一级缓存, 从二三级缓存中删除 B

> 8. 这里又回到实例 A 的 populateBean 方法, 这时候获取到 B 的实例了, A 初始化完成, 调用 addSingletion 把实例 A 放到一级缓存, 从二三级缓存中删除 A



```java
protected Object getSingleton(String beanName, boolean allowEarlyReference) {

    // 一级缓存获取
    Object singletonObject = this.singletonObjects.get(beanName);

    if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {

        // 二级缓存获取
        singletonObject = this.earlySingletonObjects.get(beanName);

        if (singletonObject == null && allowEarlyReference) {

            // 对一级缓存加锁
            synchronized (this.singletonObjects) {
                // 再次检查

                // 从一级缓存获取
                singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) {
                    
                    // 从二级缓存获取
                    singletonObject = this.earlySingletonObjects.get(beanName);

                    if (singletonObject == null) {
                        // 从三级缓存获取
                        ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
                        if (singletonFactory != null) {
                            // 调用 ObjectFactory 获取对象
                            singletonObject = singletonFactory.getObject();
                            // 添加到二级缓存
							this.earlySingletonObjects.put(beanName, singletonObject);
							// 移除三级缓存
                            this.singletonFactories.remove(beanName);
                        }

                    }
                }

            }
        }

    }

    return singletonObject;
}
```


### 2.4 三级缓存

这实际上涉及到 AOP，如果创建的 Bean 是有代理的，那么注入的就应该是代理 Bean，而不是原始的 Bean。但是 Spring 一开始并不知道 Bean 是否会有循环依赖。
通常情况下（没有循环依赖的情况下），Spring 都会在完成填充属性，并且执行完初始化方法之后再为其创建代理。
但是，如果出现了循环依赖的话，Spring 就不得不为其提前创建代理对象，否则注入的就是一个原始对象，而不是代理对象。

因此，这里就涉及到应该在哪里提前创建代理对象。 ObjectFactory.getObject 实际调用的是下面的方法

```java
protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) {
    Object exposedObject = bean;
    if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
        for (BeanPostProcessor bp : getBeanPostProcessors()) {
            if (bp instanceof SmartInstantiationAwareBeanPostProcessor) {
                SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;
                // 如果需要代理，这里会返回代理对象；否则返回原始对象
                exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);
            }
        }
    }
    return exposedObject;
}
```

在 Spring 中 SmartInstantiationAwareBeanPostProcessor 只有 2 个实现类
>1. InstantiationAwareBeanPostProcessorAdapter: 一个适配器, 实现了 SmartInstantiationAwareBeanPostProcessor 所有方法, 但是返回的都是默认值, 没有任何实现
>2. AbstractAutoProxyCreator

```java

public abstract class AbstractAutoProxyCreator extends ProxyProcessorSupport implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware {
    @Override
    public Object getEarlyBeanReference(Object bean, String beanName) {
        Object cacheKey = getCacheKey(bean.getClass(), beanName);
        // 记录已被代理的对象, 放入 2 层缓存
        this.earlyProxyReferences.put(cacheKey, bean);
        return wrapIfNecessary(bean, beanName, cacheKey);
    }
}
```


#### 2.4.1 放弃第三层缓存

将 addSingletonFactory() 方法进行改造

```java
protected void addSingletonFactory(String beanName, ObjectFactory<?> singletonFactory) {
    Assert.notNull(singletonFactory, "Singleton factory must not be null");
    synchronized (this.singletonObjects) {
        // 判断一级缓存中不存在此对象
        if (!this.singletonObjects.containsKey(beanName)) { 
            // 直接从工厂中获取 Bean
            object o = singletonFactory.getObject(); 
            // 添加至二级缓存中
            this.earlySingletonObjects.put(beanName, o); 
            // 已经创建的 beanName 集合
            this.registeredSingletons.add(beanName);
        }
    }
}
```

这样的话，每次实例化完 Bean 之后就直接去创建代理对象，并添加到二级缓存中, 功能也是正常的。

但是这样会导致实例的代理对象的创建时间提前:
在三级缓存下：一般都是 bean 创建完成, 然后 bean 对象初始化后, 最后才进行代理。   
而在二级缓存下, 这是 bean 创建完成, 进行代理, bean 初始化。

但是这样违背了 Spring 设计原则: 在 Bean 初始化完成之后才为其创建代理

#### 2.4.2 放弃第二层缓存

在 getSingleton() 方法中从第一层缓存获取不到, 同时当前的 beanName 在创建中, 会从二级缓存中获取, 获取到了, 返回。 我们可以知道二级缓存是创建成功, 但是未初始化的对象。

那么是否可以把第二层缓存舍弃, 变为

1. 需要获取的对象每次都直接从第三层缓存获取
2. 从第三层缓存获取到的对象, 直接放到第一层


* 第一种情况分析
假设当前有 3 个类, A 依赖于 B 和 C, B 依赖于 A 和 C, C 依赖于 A 和 B。在没有第二层缓存。
> 1. 创建 A 的时候, 将 A 对应的 ObjectFactory 放到第三层缓存, 填充属性, 发现需要 B
> 2. 创建 B 的时候, 将 B 对应的 ObjectFactory 放到第三层缓存, 填充属性, 从第三层缓存中获取到了 A, 填充 C 属性, 发现没有  C 属性
> 3. 创建 C 的时候, 从第三层缓存中获取到了 A 和 B, 但是到了这里 A 对应的 ObjectFactory 的 getObject 方法会执行了 2 次

这时候 ObjectFactory 的 getobject 被执行了多次, 如果在有代理的情况下, 内部的逻辑都需要在执行多一次。但是在有第二层缓存下, 可以避免里面的逻辑多次执行。  
而且 ObjectFactory 的 getobject 在有代理的情况下, 存在调用多次, 返回的是不同的对象

总上, 引入了第二层缓存


* 第二种情况分析

在 getSingleton 获取的 bean, 可能是未初始化的。所以将未初始化的对象支接放入到第一次缓存, 是可行的。
个人认为之所以不怎么做，应该是为了保证一次缓存的是完整的对象, 完全可以使用的, 而未完全的对象用另一个地方进行存放。

未初始的 bean 是没法直接使用的 (存在 NPE 问题), 所以 Spring 需要保证在启动的过程中，所有中间产生的 未初始的 bean 最终都会变成初始化的 bean
如果 未初始的 bean 和已初始的 bean 都混在一级缓存中, 那么为了区分他们，势必会增加一些而外的标记和逻辑处理，这就会导致对象的创建过程变得复杂化了
将未初始的 bean与已初始的 bean 分开存放, 两级缓存各司其职, 能够简化对象的创建过程, 更简单, 直观。



### 2.5 Spring Bean 生命周期

实例化 Instantiation
属性赋值 Populate
初始化 Initialization
销毁 Destruction

Processon 有流程图

### 2.6 BeanFactory 简介以及它和 FactoryBean 的区别

BeanFactory 是一个接口, 主要是规范了 IOC 容器的大部分的行为, 比如获取指定的 bean, IOC 容器中是否包含了某个 beanName 对应的 bean 等。
而 FactoryBean 同样也是一个接口, 为 IOC 容器中 Bean 的实现提供了更加灵活的方式, 通过实现其 getObject() 方法, 动态地通过代码的形式提供 bean 的创建方式。

BeanFactory 是一个 Factory，也就是 IOC 容器或对象工厂, 在 Spring 中, 所有的 Bean 都是由 BeanFactory (也就是 IOC 容器) 来进行管理的。  
而 FactoryBean 是一个比较特殊的 Bean, 是一个能生产或者修饰对象生成的工厂 Bean, 它的实现与设计模式中的工厂模式和修饰器模式类似。










## 3 Java 并发

### 同步锁

```java
public class LockRecord {
    Object lock;
    MarkWord displaceMarkWord;
}
```

## 4 JVM

Java 实例的创建

> 1 加载类的检查, 不存在进行类加载
> 2 分配内存
>> 2.1 内存分配方式: 指针碰撞 + 空闲列表
>> 2.2 内存分配是的安全问题: CAS 加上失败重试 + 本地线程分配缓冲 (Thread Local Allocation Buffer，TLAB)
> 3 空间初始化, 虚拟机需要将分配到的内存空间都初始化为零值 (不包括对象头), 如果使用了 TLAB 的话, 这一项工作也可以提前至 TLAB 分配时顺便进行
> 4 其他必要的设置, 对象头
> 5 执行< init >方法, <clinit> 和 <init> 2 个方法 (由 new 指令后面是否跟随 invokespecial 指令决定)
>> 5.1 直接赋值，代码块, 构造函数，实例和静态各种的执行顺序
>> 5.2 先执行父级, 再执行子级


Java 实例对象的访问定位

句柄和直接指针

