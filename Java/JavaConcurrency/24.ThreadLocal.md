# 24 ThreadLocal 

## 24.1 简介

在多线程编程中通常解决线程安全的问题我们会利用 synchronzed 或者 lock 控制线程对临界区资源的同步顺序从而解决线程安全的问题，  
但是这种加锁的方式会让未获取到锁的线程进行阻塞等待，很显然这种方式的时间效率并不是很好。**线程安全问题的核心在于多个线程会对同一个临界区共享资源进行操作**。  
那么，如果每个线程都使用自己的 “共享资源”，各自使用各自的，又互相不影响到彼此即让多个线程间达到隔离的状态，
这样就不会出现线程安全的问题。事实上，这就是一种**空间换时间**的方案，每个线程都会都拥有自己的 “共享资源” 无疑内存会大很多,   
但是由于不需要同步也就减少了线程可能存在的阻塞等待的情况从而提高的时间效率。

虽然 ThreadLocal 并不在 java.util.concurrent 包中而在 java.lang 包中，但我更倾向于把它当作是一种并发容器( 虽然真正存放数据的是 ThreadLocalMap) 进行归类。  
从 ThreadLocal 这个类名可以顾名思义的进行理解，表示线程的 "本地变量"，即每个线程都拥有该变量副本，达到人手一份的效果，各用各的这样就可以避免共享资源的竞争。

## 24.2 ThreadLocal 的实现原理

要想学习到 ThreadLocal 的实现原理，就必须了解它的几个核心方法，包括怎样存怎样取等等，下面我们一个个来看。


### 24.2.1 设值到 ThreadLocal - set() 方法

```java
public class ThreadLocal<T> {

    public void set(T value) {

        // 获取当前的线程
        Thread t = Thread.currentThread();
        // 通过当前线程实例获取到 ThreadLocalMap 对象
        ThreadLocalMap map = getMap(t);

        if (map != null)
            // 如果 map 不为 null, 则以当前 threadLocl 实例为 key, 值为 value 进行存入
            map.set(this, value);
        else
            // map 为 null, 则新建 ThreadLocalMap 并存入 value
            createMap(t, value);
    }

    /**
     * 返回指定线程自身的 ThreadLocalMap 对象
     */
    ThreadLocalMap getMap(Thread t) {
        return t.threadLocals;
    }

    /**
     * 为指定的线程创建一个 ThreadLocalMap 对象
     */
    void createMap(Thread t, T firstValue) {
        t.threadLocals = new ThreadLocalMap(this, firstValue);
    }

}
```

从上面的代码，我们可以知道  
ThreadLocal 实际的数据是存在每个线程自身的 ThreadLocalMap 对象中。

```java
public class Thread {
    // 每个线程内部都有一个 ThreadLocalMap 属性
    ThreadLocal.ThreadLocalMap threadLocals = null;
}
```

ThreadLocal 的在使用, 我们可以在类 A 中使用 TheadLocal 存储 String, 在类 B 中用 TheadLocal 存储 Integer。
同一个线程同时使用到了类 A 和类 B, 那么线程身上的 TheadLocalMap threadLocals 需要支持同时存储 2 个数据以上, 那么 ThreadLocalMap   
应该是什么样的一个数据结构呢?  
答案是**数组**, 最终实现出来的结果类似于 HashMap, value 是我们存入的内容, 而 key 就是每个类上的 ThreadLocal 的实例。
通过这个 TheadLocal 得到一个 hash 值通过这个 hash 值计算得到其在数组中的哪个位置。  
这时候如果有另外一个 TheadLocal 实例, 计算出来的 hash 不一样了, 那么这个 TheadLocal 的内容存在数组的另外一个位置。

TheadLocalMap 的理解可以简单的先按照上面的方式, 后面会具体的分析。


向 ThreadLocal 放数据，也就是 set 过程
> 1. 获取当前线程的所维护的 threadLocalMap
> 2. 若 threadLocalMap 不为 null, 则以当前的 ThreadLocal 实例为 key, 值为 value 的键值对存入 threadLocalMap
> 3. 若 threadLocalMap 为 null 的话，就为当前的线程新建一个 ThreadLocalMap, 然后在以当前的 ThreadLocal 实例为 key，值为 value 的键值对存入即可

### 24.2.2 从 ThreadLocal 中取值 - get() 方法

```java
public class ThreadLocal<T> {

    public T get() {

        // 1. 获取当前的线程
        Thread t = Thread.currentThread();

        // 2. 获取当前线程的 ThreadLocalMap
        ThreadLocalMap map = getMap(t);

        // 3. 当前线程的 ThreadLocalMap 不为空
        if (map != null) {

            // 获取 map 中 key 为 当前实例的 Entry
            ThreadLocalMap.Entry e = map.getEntry(this);
        
            // 获取到了需要的 Entry
            if (e != null) {
                T result = (T)e.value;
                return result;
            }
        }

        //若 map 为 null 或者 entry 为 null 的话通过该方法初始化，并返回该方法返回的 value
        return setInitialValue();
    }

    /**
     * 为当前的线程设置一个 value 为 null 的 ThreadLocalMap 
     */ 
    private T setInitialValue() {

        // 获取一个 null 的 value
        T value = initialValue();

        Thread t = Thread.currentThread();

        // 获取当前线程的 TheadLocalMap
        ThreadLocalMap map = getMap(t);
        // 不为 null, 设值
        if (map != null)
            map.set(this, value);
        else
            // 为 null, 创建一个
            createMap(t, value);
        return value;
    }

    /**
     * 默认返回一个 null
     */
    protected T initialValue() {
        return null;
    }

}
```


从 ThreadLocal 取数据，也就是 get 的过程  
> 1. 获取当前线程的所维护的 threadLocalMap
> 2. 若 threadLocalMap 不为 null, 通过 threadLocalMap 中获取 Entry, Entry 不为 null, 就是找到需要的值了，返回
> 3. threadLocalMap 为 null, 或者从 threadLocalMap 获取到的 Entry 为空，声明一个初始的 value 默认为 null, 走一遍 set 的逻辑
> 4. 返回声明的初始 value 


### 24.2.3 从 ThreadLocal 中删除数据 - remove() 方法

```java
public class ThreadLocal<T> {

    public void remove() {
        // 获取当前线程的 TheadLocalMap 
        ThreadLocalMap m = getMap(Thread.currentThread());
        if (m != null)
            // 从 map 中删除以当前 threadLocal 实例为 key 的键值对
            // ThreadLocalMap 的 remove 后面在讲
            m.remove(this);
    }
}
```

remove 的方法很简单的，就是从从当前线程获取到 ThreadLocalMap, 不为 null 的话，调用 ThreadLocalMap 的 remove 进行移除数据

## 24.3 ThreadLocalMap 的实现原理

从上面的分析我们已经知道，数据其实都放在了 ThreadLocalMap 中，ThreadLocal 的 get，set 和 remove 方法实际上具体是通过 ThreadLocalMap 
的 getEntry, set 和 remove 方法实现的。如果想真正全方位的弄懂 ThreadLocal, 就是在了解 TheadLocalMap。

### 24.3.1 ThreadLocalMap 中的 Entry

ThreadLocalMap 是 ThreadLocal 一个静态内部类，和大多数容器一样内部维护了一个数组，同样的 ThreadLocalMap 内部维护了一个 Entry 类型的 table 数组

```java
static class Entry extends WeakReference<ThreadLocal<?>> {

    Object value;

    Entry(ThreadLocal<?> k, Object v) {
        super(k);
        value = v;
    }
}

```

Entry 是一个以 ThreadLocal 为 key,  value 为 Object类型 的键值对。 有点类似于 HashMap, T key, Object value。 key 的变量声明在父级中。   
Entry 继承了 WeakReference, 同时在构造函数中将当前的 ThreadLocal 作为参数传递给了父级, 在父级中, 会将对应的 TheadLocal 封装为一个弱引用。  
而不像我们平时直接在 Entry 中多声明一个 T key, 然后将 TheadLocal<?> k 赋值给 key, 这种做法是强引用, key 和当前的 Entry 是共生的, 一起存在一次消亡。  
而使用弱引用进行包装可以达到: 在 GC 时, 在 Entry 存在的情况下, k 能被回收。  

Java 中的 4 种引用可以看下面的附录, 有简单的介绍。


Thead, TheadLocal, TheadLocalMap 三者的关系如下:  
![Alt 'ThreadAndThreadLocalAndThreadLocalMapRelation'](https://raw.githubusercontent.com/PictureRespository/Java/main/JavaConcurrency/ThreadAndThreadLocalAndThreadLocalMapRelation.png)

实线表示强引用，虚线表示弱引用。

每个线程实例中可以通过 Thead.threadLocals 获取到 ThreadLocalMap, 而 ThreadLocalMap 实际上就是一个以 ThreadLocal 实例为 key，任意对象为 value 的 Entry 数组。  

当我们为 ThreadLocal 变量赋值时，就是给对应的线程的 ThreadLocalMap 中放入一个当前 ThreadLocal 实例为 key，值为 value 的 Entry。

需要注意的是 **Entry 中的 key 是弱引用**, 当 ThreadLocal 外部强引用被置为 null (ThreadLocalInstance = null) 时, 那么系统 GC 的时候，  
根据可达性分析，这个 ThreadLocal 实例就没有任何一条链路能够引用到它，这个 ThreadLocal 势必会被回收。 这样一来，ThreadLocalMap 中就会出现   
key 为 null 的 Entry, 就没有办法访问这些 key 为 null 的 Entry 的 value。如果当前线程再迟迟不结束的话, 这些 key 为 null 的 Entry 的   
value 就会一直存在一条强引用链: Thread Ref -> Thread -> ThreadLocalMap -> Entry -> value 永远无法回收，造成内存泄漏。  
当然, 如果当前 Thread 运行结束, ThreadLocal, ThreadLocalMap, Entry 没有引用链可达，在垃圾回收的时候都会被系统进行回收。  
在实际开发中, 会使用线程池去维护线程的创建和复用，比如固定大小的线程池，线程为了复用是不会主动结束的。所以, ThreadLocal 的内存泄漏问题, 是应该值得我们思考和注意的问题。


### 24.3.2 ThreadLocalMap 的创建

**创建方式一** 

```java
static class ThreadLocalMap {

    // 存放数据的数组
    private Entry[] table;

    // 数组当前的元素个数
    private int size = 0;

    // 数组中的元素个数达到了这个就会扩容, 而不是数组满了才扩容
    private int threshold;

    ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {

        // INITIAL_CAPACITY = 16;
        table = new Entry[INITIAL_CAPACITY];

        // 调用 ThreadLocal 的 threadLocalHashCode 的 threadLocalHashCode 属性值, 然后 & (16 - 1) 
        // 得到这个 firstKey 应该存在数组的哪个位置
        int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);

        // 在数组对应的位置存入 Entry
        table[i] = new Entry(firstKey, firstValue);
        // 当前容量设置为 1 
        size = 1;
        // setTheshold 里面只有一行代码 threshold = len * 2 / 3;
        // 也就是设置阈值 = 长度 * 2/3
        setThreshold(INITIAL_CAPACITY);
    }

}

```

**创建方式二**

```java
static class ThreadLocalMap {

    private ThreadLocalMap(ThreadLocalMap parentMap) {

        // 取到入参 ThreadLocalMap 的数组
        Entry[] parentTable = parentMap.table;

        // 入参 ThreadLocalMap 的数组的长度, 这里的长度不用做任何处理，因为这里的长度必定为 2 的 n 次方
        int len = parentTable.length;

        // 设置阈值 = len * 2/3
        setThreshold(len);

        // 设置新的数组    
        table = new Entry[len];

        // 遍历入参的 ThreadLocalMap 的数组
        for (int j = 0; j < len; j++) {
            // 获取到 table 数组的第 j 个位置
            Entry e = parentTable[j];
            if (e != null) {
                // 对应的位置有数据
                
                // 从 e 中获取对应的 key  即 ThreadLocal 实例
                ThreadLocal<Object> key = (ThreadLocal<Object>) e.get();

                if (key != null) {
                    // 调用 ThreadLocal 的 childValue 方法
                    // 在 ThreadLocal 中这个方法的默认实现为 throw new UnsupportedOperationException(); 抛出一个异常
                    // 也就是这里的 key 必须是 TheadLocal 的子类, 同时重写了 childValue 方法, 否则会报错
                    Object value = key.childValue(e.value);

                    // 把 key 和 value 封装为 Entry
                    Entry c = new Entry(key, value);
                    // 定位到放在数组的位置
                    int h = key.threadLocalHashCode & (len - 1);
                    // 对应的位置不为空，查询后面的一个位置，到了尾部，回到头部继续往后找
                    while (table[h] != null)
                        h = nextIndex(h, len);
                    // 对应的位置 设置为当前的 Entry
                    table[h] = c;
                    // 个数加 1
                    size++;
                }

            }

        }
    }

    /**
     * 位置的定位
     */
    private static int nextIndex(int i, int len) {
        // 当前的位置 + 1 小于当前的长度, 取 + 1 的位置，否则取 0, 既头部的位置
        return ((i + 1 < len) ? i + 1 : 0);
    }

}

```

从上面的方法中可以看出一个有趣的点:  
> 1. HashMap 在处理 hash 碰撞时使用的是: 拉链法
> 2. ThreaLocalMap 在处理 hash 碰撞时使用的是: 开放定址法 (一旦产生了冲突, 就按某种规则去寻找另一空地址) 中的**线性探测法**。

具体的开放地址法如何解决 hash 冲突的可以看一下这篇文章: [冲突处理方法----开放定址法](https://blog.csdn.net/happyjacob/article/details/84886323)

### 24.3.3 ThreadLocalMap 中决定 Entry 的 hashCode 的计算

在 ThreadLocalMap 中 key 对应的 Entry 在 Entry[] table 的位置的计算方式为 **key.threadLocalHashCode & (len - 1)**。 
决定位置的元素有 2 个
> 1. 当前 Entry[] table 数组的长度
> 2. key 对应的 ThreaLocal 中的 threadLocalHashCode 的值

Entry[] table 的长度很容易知道, 但是 threadLocalHashCode 是如何计算的呢

```java
public class ThreadLocal<T> {

    private final int threadLocalHashCode = nextHashCode();
    
    private static AtomicInteger nextHashCode = new AtomicInteger();
    
    // 这个值为 1640531527
    private static final int HASH_INCREMENT = 0x61c88647;
    
    private static int nextHashCode() {
        return nextHashCode.getAndAdd(HASH_INCREMENT);
    }
}
```

先说结论:  

每个 ThreadLocal 实例的 threadLocalHashCode 在 ThreadLocal 实例创建出来后就不会再变了, 这个 ThreadLocal 实例后面在使用中, threadLocalHashCode 固定的。  
每个 ThreadLocal 实例的 threadLocalHashCode 都是不同的。


> 1. nextHashCode 这个变量在 ThreadLocal 中被 static 修饰了，说明所有的 ThreadLocal 的实例共用 1 个 AtomicInteger 的属性
> 2. 当我们声明第 1 个 ThreadLocal，调用唯一的 nextHashCode， 得到了当前的 threadLocalHashCode 值, 值为 0, 同时让唯一的 AtomicInteger 的值增加 1640531527
> 3. 声明第 2 个 ThreadLocal, 又调用了唯一的 nextHashCode, 得到了当前的 threadLocalHashCode 值, 值为 1640531527, 然后又让 AtomicInteger 的值增加 1640531527
> 4. 这样每创建一个 ThreadLocal 的 nextHashCode 都是不一样的。不要忽略了 int 值的取值范围, 导致值的变化
> 5. 为什么每个 ThreadLocal 之间的的 nextHashCode 的差值为 1640531527 ? 这个和斐波那契散列有关, 它可以使 hashcode 均匀的分布在大小 2 的 N 次方的数组里。至于为什么, 涉及到数学相关的知识，pass !

通过上面的分析基本知道了 ThreadLocal 的大体实现了吧
> 1. 每次声明了一个 ThreadLocal 实例, 这时候这个实例会得到一个固定的 hashCode, 存储在 threadLocalHashCode 变量中
> 2. 每个线程中都有一个变量 threadLocals 类型为 ThreadLocalMap
> 3. ThreadLocalMap 本质是一个 Entry 的数组, Entry 对象中存储了 key, value, key 默认一个 ThreadLocal 的实例, value 就是通过 ThreadLocal 存储到 Thread 的内容
> 4. 当我们调用 ThreadLocal 的实例, 将内容存储到当前的 Thread 本质是存在 Thread 中的 threadLocals 属性, 也就是 Entry[] 数组中

调用 ThreadLocal 的实例, 存放数据的步骤大体如下
> 1. 创建一个 ThreadLocal 的实例, 实例的得到一个接近唯一的 hashCode, 存储在自身的 threadLocalHashCode 变量
> 2. 获取当前的线程维护的 threadLocals 变量, ThreadLocalMap 类型, 也就是 Entry[] 的数组, 如果为空, 进行初始化
> 3. 将当前的 ThreadLocal 实例作为 key, 需要存储的内容做为 value, 封装为一个 Entry 实例
> 4. 通过当前的 ThreadLocal 实例的 threadLocalHashCode 和当前 Entry[] 数组的长度计算出, 这个 ThreadLocal 存储在数组中的哪一个位置, 把封装好的 Entry 实例放到数组中
> 5. 这时候又声明了一个新的 ThreadLocal 的实例, 又是另一个 threadLocalHashCode
> 6. 往这个新的 ThreadLocal 的实例存值, 同样是封装为 Entry,
> 7. 当前线程的 threadLocals 变量不为空, 不会初始化, 也就是新的 ThreadLocal 和旧的 ThreadLocal 用着同一个 threadLocals 变量, 也就是同一个 Entry[] 数组
> 8. 但是新的 ThreadLocal 的实例的 threadLocalHashCode 不一样, 计算出来的位置也会不一样, 这样放到同一个 Entry[] 数组的不同位置
> 9. 也就是说使用 ThreadLocal 存储数据时, 数据是存储在当前线程的数组中的

### 24.3.4 ThreadLocalMap 的 set() 方法

```java
static class ThreadLocalMap {
    
    private void set(ThreadLocal<?> key, Object value) {

        // 获取到当前存数据的数组引用
        Entry[] tab = table;
        // 数组长度
        int len = tab.length;
    
        // 当前 ThreadLocal 的 threadLocalHasCode & (数组的长度 - 1), 得到当前应该存在数组的哪个位置
        int i = key.threadLocalHashCode & (len-1);

        // 取到对应位置的元素,  但 i 位置的 不为 null
        for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) {

            // 这时候的 e 一定不会是 null

            // 从 Entry e 中获取 key
            ThreadLocal<?> k = e.get();

            // 对应的 k == 输入的 key, 替换新值，结束
            if (k == key) {
                e.value = value;
                return;
            }

            // 对应的位置的 k 为 null, 将当前的 value 设置到 ThreadLocalMap 的数组
            // Entry 不为 null, 但是 Entry 的 key 为 null, 情况是存在的, 因为 Entry 中的 key 是一个弱引用, 能被 GC 直接回收
            // 这时候可以把当前的 Entry 放到这个位置
            if (k == null) {

                // 将当前的 value 放到数组里面, 进行 table 数组的重新整理，即对数组中, 无效的 Entity (key 为 null) 进行移除
                // 然后对数组中的 key 是 hash 冲突过的 (当前所在的位置和计算出来的位置不一样, hash 冲突过)，重新走一遍位置定位
                // 这样经过了无效 Entry 删除后, 重新计算位置, 可能将其重新放到正确的位置
                replaceStaleEntry(key, value, i);
                return;
            }

            // 到了这里, 会执行 for 后面的 e = tab[i = nextIndex(i, len)], e != null, 又有进入到这个循环
            // 等于 null 的话，跳出循环, 执行下面的逻辑
        }

        // i 位置为 null, 创建一个新的 Entry 放到数组的 i 位置
        tab[i] = new Entry(key, value);
        // 容量加 1
        int sz = ++size;

        // 插入后再次清除一些 key 为 null 的 "脏" entry, 如果大于阈值还是需要扩容
        // 个人认为 这里的 sz >= threshold 可以改为 size >= threashold 因为经过 cleanSomeSlots 有可能 size 变小，这时候应该可以不用进行扩容的
        if (!cleanSomeSlots(i, sz) && sz >= threshold)
            // 扩容
            rehash();
    }

}

```

**replaceStaleEntry() 方法**

```java

static class ThreadLocalMap {

    /**
     * 移除数组中的部分无效 Entry, 然后对范围内的 Entry 重新地位 
     * 
     * @param key ThreadLocal 实例 的 key
     * @param value     需要存储的值
     * @param staleSlot key 当前打算放到这个位置, 同时这个位置的 Entry 的 key 为 null
     */
    private void replaceStaleEntry(ThreadLocal<?> key, Object value, int staleSlot) {

        Entry[] tab = table;
        int len = tab.length;
        Entry e;

        // 下面的所有的遍历, 基本都是
        // 1. 向前遍历, 遍历到数组的头部后, 会继续从数组的尾部开始继续往前遍历
        // 2. 向后遍历, 遍历到数组的尾部后, 会继续从数组的头部开始继续向后遍历
        // 所以把存储数据的 table 数组看成一个头尾相接的环, 可以容易理解

        // staleSlot 位置的 Entry key 为 null
        // 后面会被更新为
        int slotToExpunge = staleSlot;

        // 从当前的 staleSlot 位置向前(如果到了头部, 则从尾部继续往前找), 直到遇到第一个位置 Entry 为空才停止
        
        // prevIndex 的逻辑就一句话: ((i - 1 >= 0) ? i - 1 : len - 1); 
        // 位置 i - 1 >=0, 没到数组的头部, 向前一位,
        // 位置 i - 1 <0, i 已经是数组的头部了, 那么从 len - 1, len 为数组长度， len - 1 就是数组的尾部

        // 这个循环直到 (e = tab[i]) == null 才结束, 就是对应的位置为空, 没有数据

        // 往前找的过程中，slotToExpunge 会不断重置, 更新为当前位置的 Entry 不为空, 但是 Entry 的 key 为 null 的节点位置
        for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len))
            // 对应对象的 key 为 null, 变更 slotToExpunge, 
            if (e.get() == null)
                slotToExpunge = i;


        // 从 staleSlot 开始向后找(如果到了尾部了，从头部继续找)，直到遇到第一个位置没有数据的才结束

        // nextIndex 的逻辑就一句话: ((i + 1 < len) ? i + 1 : 0);
        // 位置 i + 1 < len, 没到数组的尾部部, 向后一位,
        // 位置 i + 1 >= len, i 已经是数组的尾部了, 从数组的第 0 位, 也就是头部开始

        // 这个循环直到 (e = tab[i]) == null 才结束, 就是对应的位置为空, 没有数据

        for (int i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) {        

            // 在这里面的 e 不为 null

            // 获取 entity 的 key, 也就是 ThreadLocal
            ThreadLocal<?> k = e.get();

            // 和我们要存储位置的 key 一样
            if (k == key) {
                // 对应 entity 的 value 更新
                e.value = value;
                // 将 i 和一开始无效的位置 staleSlot 替换
                tab[i] = tab[staleSlot];

                // 如果上面的向前查找过程中没有更新 slotToExpunge 的值，则更新 slotToExpunge 为当前值 i, staleSlot 的值是存在的
                if (slotToExpunge == staleSlot)
                    slotToExpunge = i;
                
                // 对当前数组里面的无效的 entity 移除，同时对位置不是直接算出来的 entity, 重新算位
                cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);
                return;     
            }

            // key 为 null 并且当前的 slotToExpunge 还是等于 staleSlot(也就是上面向前找的时候，没有找到符合条件的), 更新 slotToExpunge 为当前的 i(这时候的 entity 为无效 entity)
            if (k == null && slotToExpunge == staleSlot)
                slotToExpunge = i;
            }  
        }

        // 把 staleSlot 位置设置为当前的 key 和 value 组合的 Entity
        tab[staleSlot].value = null;
        tab[staleSlot] = new Entry(key, value);

        // 如果 slotToExpunge 和 staleSlot 表示有数据可以清除, 调用 cleanSomeSlots 进行清除
        if (slotToExpunge != staleSlot)
            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);  
    }



    /*
     * 从入参的位置开始，向后遍历到第一个位置为空的位置，将这段距离中的无效 entity 移除，有效 entity 的位置不等于直接计算出来的，重新分配位置
     * @param staleSlot 开始移除的位置
     * @return 
     */
    private int expungeStaleEntry(int staleSlot) {
        Entry[] tab = table;
        int len = tab.length;

        // expunge entry at staleSlot
        tab[staleSlot].value = null;
        tab[staleSlot] = null;
        size--;

        // Rehash until we encounter null
        Entry e;
        int i;
        for (i = nextIndex(staleSlot, len);
                (e = tab[i]) != null;
                i = nextIndex(i, len)) {
            ThreadLocal<?> k = e.get();
            if (k == null) {
                e.value = null;
                tab[i] = null;
                size--;
            } else {
                int h = k.threadLocalHashCode & (len - 1);
                if (h != i) {
                    tab[i] = null;

                    // Unlike Knuth 6.4 Algorithm R, we must scan until
                    // null because multiple entries could have been stale.
                    while (tab[h] != null)
                        h = nextIndex(h, len);
                    tab[h] = e;
                }
            }
        }
        return i;
    }

    /**
     * 从 i 位置开始，对无效的 entity 进移除和对算出来的位置不一致的重新计算, 
     * 部分清除, 控制遍历的次数在 log2(数组的长度) 次数,
     *
     * @param i 数组中为空的位置
     * @param n 数组的长度
     */
    private boolean cleanSomeSlots(int i, int n) {
        boolean removed = false;
        Entry[] tab = table;
        int len = tab.length;
        do {
            i = nextIndex(i, len);
            Entry e = tab[i];
            if (e != null && e.get() == null) {
                n = len;
                removed = true;
                i = expungeStaleEntry(i);
            }
        } while ( (n >>>= 1) != 0);
        return removed;
    }
}
```