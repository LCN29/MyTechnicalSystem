# 24 ThreadLocal 

## 24.1 简介

在多线程编程中通常解决线程安全的问题我们会利用 synchronzed 或者 lock 控制线程对临界区资源的同步顺序从而解决线程安全的问题，  
但是这种加锁的方式会让未获取到锁的线程进行阻塞等待，很显然这种方式的时间效率并不是很好。**线程安全问题的核心在于多个线程会对同一个临界区共享资源进行操作**。  
那么，如果每个线程都使用自己的 “共享资源”，各自使用各自的，又互相不影响到彼此即让多个线程间达到隔离的状态，
这样就不会出现线程安全的问题。事实上，这就是一种**空间换时间**的方案，每个线程都会都拥有自己的 “共享资源” 无疑内存会大很多,   
但是由于不需要同步也就减少了线程可能存在的阻塞等待的情况从而提高的时间效率。

虽然 ThreadLocal 并不在 java.util.concurrent 包中而在 java.lang 包中，但我更倾向于把它当作是一种并发容器( 虽然真正存放数据的是 ThreadLocalMap) 进行归类。  
从 ThreadLocal 这个类名可以顾名思义的进行理解，表示线程的 "本地变量"，即每个线程都拥有该变量副本，达到人手一份的效果，各用各的这样就可以避免共享资源的竞争。

## 24.2 ThreadLocal 的实现原理

要想学习到 ThreadLocal 的实现原理，就必须了解它的几个核心方法，包括怎样存怎样取等等，下面我们一个个来看。


### 24.2.1 设值到 ThreadLocal - set() 方法

```java
public class ThreadLocal<T> {

    public void set(T value) {

        // 获取当前的线程
        Thread t = Thread.currentThread();
        // 通过当前线程实例获取到 ThreadLocalMap 对象
        ThreadLocalMap map = getMap(t);

        if (map != null)
            // 如果 map 不为 null, 则以当前 threadLocl 实例为 key, 值为 value 进行存入
            map.set(this, value);
        else
            // map 为 null, 则新建 ThreadLocalMap 并存入 value
            createMap(t, value);
    }

    /**
     * 返回指定线程自身的 ThreadLocalMap 对象
     */
    ThreadLocalMap getMap(Thread t) {
        return t.threadLocals;
    }

    /**
     * 为指定的线程创建一个 ThreadLocalMap 对象
     */
    void createMap(Thread t, T firstValue) {
        t.threadLocals = new ThreadLocalMap(this, firstValue);
    }

}
```

从上面的代码，我们可以知道  
ThreadLocal 实际的数据是存在每个线程自身的 ThreadLocalMap 对象中。

```java
public class Thread {
    // 每个线程内部都有一个 ThreadLocalMap 属性
    ThreadLocal.ThreadLocalMap threadLocals = null;
}
```

ThreadLocal 的在使用, 我们可以在类 A 中使用 TheadLocal 存储 String, 在类 B 中用 TheadLocal 存储 Integer。
同一个线程同时使用到了类 A 和类 B, 那么线程身上的 TheadLocalMap threadLocals 需要支持同时存储 2 个数据以上, 那么 ThreadLocalMap   
应该是什么样的一个数据结构呢?  
答案是**数组**, 最终实现出来的结果类似于 HashMap, value 是我们存入的内容, 而 key 就是每个类上的 ThreadLocal 的实例。
通过这个 TheadLocal 得到一个 hash 值通过这个 hash 值计算得到其在数组中的哪个位置。  
这时候如果有另外一个 TheadLocal 实例, 计算出来的 hash 不一样了, 那么这个 TheadLocal 的内容存在数组的另外一个位置。

TheadLocalMap 的理解可以简单的先按照上面的方式, 后面会具体的分析。


向 ThreadLocal 放数据，也就是 set 过程
> 1. 获取当前线程的所维护的 threadLocalMap
> 2. 若 threadLocalMap 不为 null, 则以当前的 ThreadLocal 实例为 key, 值为 value 的键值对存入 threadLocalMap
> 3. 若 threadLocalMap 为 null 的话，就为当前的线程新建一个 ThreadLocalMap, 然后在以当前的 ThreadLocal 实例为 key，值为 value 的键值对存入即可

### 24.2.2 从 ThreadLocal 中取值 - get() 方法

```java
public class ThreadLocal<T> {

    public T get() {

        // 1. 获取当前的线程
        Thread t = Thread.currentThread();

        // 2. 获取当前线程的 ThreadLocalMap
        ThreadLocalMap map = getMap(t);

        // 3. 当前线程的 ThreadLocalMap 不为空
        if (map != null) {

            // 获取 map 中 key 为 当前实例的 Entry
            ThreadLocalMap.Entry e = map.getEntry(this);
        
            // 获取到了需要的 Entry
            if (e != null) {
                T result = (T)e.value;
                return result;
            }
        }

        //若 map 为 null 或者 entry 为 null 的话通过该方法初始化，并返回该方法返回的 value
        return setInitialValue();
    }

    /**
     * 为当前的线程设置一个 value 为 null 的 ThreadLocalMap 
     */ 
    private T setInitialValue() {

        // 获取一个 null 的 value
        T value = initialValue();

        Thread t = Thread.currentThread();

        // 获取当前线程的 TheadLocalMap
        ThreadLocalMap map = getMap(t);
        // 不为 null, 设值
        if (map != null)
            map.set(this, value);
        else
            // 为 null, 创建一个
            createMap(t, value);
        return value;
    }

    /**
     * 默认返回一个 null
     */
    protected T initialValue() {
        return null;
    }

}
```


从 ThreadLocal 取数据，也就是 get 的过程  
> 1. 获取当前线程的所维护的 threadLocalMap
> 2. 若 threadLocalMap 不为 null, 通过 threadLocalMap 中获取 Entry, Entry 不为 null, 就是找到需要的值了，返回
> 3. threadLocalMap 为 null, 或者从 threadLocalMap 获取到的 Entry 为空，声明一个初始的 value 默认为 null, 走一遍 set 的逻辑
> 4. 返回声明的初始 value 


### 24.2.3 从 ThreadLocal 中删除数据 - remove() 方法

```java
public class ThreadLocal<T> {

    public void remove() {
        // 获取当前线程的 TheadLocalMap 
        ThreadLocalMap m = getMap(Thread.currentThread());
        if (m != null)
            // 从 map 中删除以当前 threadLocal 实例为 key 的键值对
            // ThreadLocalMap 的 remove 后面在讲
            m.remove(this);
    }
}
```

remove 的方法很简单的，就是从从当前线程获取到 ThreadLocalMap, 不为 null 的话，调用 ThreadLocalMap 的 remove 进行移除数据

## 24.3 ThreadLocalMap 的实现原理

从上面的分析我们已经知道，数据其实都放在了 ThreadLocalMap 中，ThreadLocal 的 get，set 和 remove 方法实际上具体是通过 ThreadLocalMap 
的 getEntry, set 和 remove 方法实现的。如果想真正全方位的弄懂 ThreadLocal, 就是在了解 TheadLocalMap。

### 24.3.1 ThreadLocalMap 中的 Entry

ThreadLocalMap 是 ThreadLocal 一个静态内部类，和大多数容器一样内部维护了一个数组，同样的 ThreadLocalMap 内部维护了一个 Entry 类型的 table 数组

```java
static class ThreadLocalMap {

    Object value;

    Entry(ThreadLocal<?> k, Object v) {
        super(k);
        value = v;
    }
}

```

Entry 是一个以 ThreadLocal 为 key, Object 为 value 的键值对。  
同时注意，这里的 **ThreadLocal** 是一个弱引用。 因为 Entry 继承了 WeakReference，在 Entry 的构造方法中，
调用了 super(k) 方法就会将 ThreadLocal 实例包装成一个 WeakReference。


