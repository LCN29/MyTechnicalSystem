# 22 Exchanger

## 22.1 简介
Exchanger 是一个用于线程间协作的工具类, 用于两个线程间能够交换。它提供了一个交换的同步点, 在这个同步点两个线程能够交换数据。  
具体交换数据是通过 exchange 方法来实现的, 如果一个线程先执行 exchange 方法, 那么它会阻塞等待另一个线程也执行 exchange 方法, 这个时候两个线程就都达到了同步点, 两个线程就可以交换数据。

## 22.2 CountDownLatch 的方法

Exchanger 除了一个无参的构造方法外, 主要方法也很简单  
> 1. V exchange(V x) throws InterruptedException: 当一个线程执行该方法的时候, 会等待另一个线程也执行该方法, 因此两个线程就都达到了同步点,  将数据交换给另一个线程, 同时返回获取的数据
> 2. V exchange(V x,  long timeout,  TimeUnit unit) throws InterruptedException,  TimeoutException: 同上一个方法功能基本一样, 只不过这个方法同步等待的时候, 增加了超时时间


Exchanger 理解起来很容易, 这里用一个简单的例子来看下它的具体使用。  
我们来模拟这样一个情景, 在青春洋溢的中学时代, 下课期间, 男生经常会给走廊里为自己喜欢的女孩子送情书, 相信大家都做过这样的事情吧。   
男孩会先到女孩教室门口, 然后等女孩出来, 教室那里就是一个同步点, 然后彼此交换信物, 也就是彼此交换了数据。现在, 就来模拟这个情景。 

```java

public class ExchangerDemo {

    private static Exchanger<String> exchanger = new Exchanger();

	public static void main(String[] args) {

	    //代表男生和女生
	    ExecutorService service = Executors.newFixedThreadPool(2);

	    service.execute(() -> {
	        try {
	            //男生对女生说的话
                // 这时候线程会被阻塞, 直到得到返回结果
	            String girl = exchanger.exchange("我其实暗恋你很久了......");
	            System.out.println("女孩儿说：" + girl);
	        } catch (InterruptedException e) {
	            e.printStackTrace();
	        }
	    });
	    service.execute(() -> {
	        try {
	            System.out.println("女生慢慢的从教室里走出来......");
	            TimeUnit.SECONDS.sleep(3);
	            //男生对女生说的话
	            String boy = exchanger.exchange("我也很喜欢你......");
	            System.out.println("男孩儿说：" + boy);
	        } catch (InterruptedException e) {
	            e.printStackTrace();
	        }
	    });
	}
}
```

输出结果：
```log
女生慢慢的从教室里走出来......
男孩儿说：我其实暗恋你很久了......
女孩儿说：我也很喜欢你......
```

## 22.3 Exchanger 的源码实现

Exchanger 有单槽位和多槽位之分，
> 1. 单个槽位在同一时刻只能用于两个线程交换数据，这样在竞争比较激烈的时候，会影响到性能，
> 2. 多个槽位就是多个线程可以同时进行两个的数据交换，彼此之间不受影响，这样可以很好的提高吞吐量。

### 22.3.1 Exchanger 的内部类

```java

public class Exchanger<V> {

    @sun.misc.Contended 
    static final class Node {
        int index;
        int bound;
        int collides;
        int hash;

        // 当前线程调用 exchagne 方法打算传递给其他线程的内容
        Object item;

        // 从其他线程获取到的传递内容
        volatile Object match;

        // 当前节点中挂起的线程
        volatile Thread parked;
    }

    static final class Participant extends ThreadLocal<Node> {
        
        // 每个线程 ThreadLocalMap 中存储的内容
        public Node initialValue() { 
            return new Node(); 
        }
    }
}
```

### 22.3.3 Exchagner 的属性

```java
public class Exchanger<V> {

    private static final int ASHIFT = 5;

    // 等于 255, 二进制表示就是 00000000 00000000 00000000 11111111
    private static final int MMASK = 0xff;

    // 等于 256, 二进制表示就是 00000000 00000000 00000001 00000000
    private static final int SEQ = MMASK + 1;

    // 当前机器中, Java 虚拟机的可用的处理器数量, 简单理解为可用核心数, 我的机器的值为 16 
    private static final int NCPU = Runtime.getRuntime().availableProcessors();

    // NCPU >=  510 (MMASK << 1, 也就是乘以 2, 值为 510) ? 255 : NCPU/2;
    static final int FULL = (NCPU >= (MMASK << 1)) ? MMASK : NCPU >>> 1;

    // 等于 1024, 默认自旋的最大次数
    private static final int SPINS = 1 << 10;

    // 线程 A 调用 exchange 方法, 传递给其他线程的内容为 null 时, 会修改为一个默认值 NULL_ITEM
    private static final Object NULL_ITEM = new Object();

    // 线程 A 调用带超时时间的 exchange 方法, 超时了还是没有得到其他线程给的值, 这时候默认会返回一个默认值 TIMED_OUT
    private static final Object TIMED_OUT = new Object();

    // 就是自定义的 ThreadLocal, 在构造方法中声明
    private final Participant participant;

    private volatile Node[] arena;

    private volatile Node slot;

    private volatile int bound;
}
```

### 22.3.2 Exchanger 的单位槽的 exchange 方法

```java

public class Exchanger<V> {


    public V exchange(V x) throws InterruptedException {

        Object v;
        Node[] a;

        // 需要交给另一个线程的信息为 null 的话，使用内部的一个 Object 作为替代
        Object item = (x == null) ? NULL_ITEM : x;

        if (((a = arena) != null || (v = slotExchange(item, false, 0L)) == null) && ((Thread.interrupted() || (v = arenaExchange(item, false, 0L)) == null)))
            throw new InterruptedException();
            
        return (v == NULL_ITEM) ? null : (V)v;    
    }
}
```


### 22.3.3 Exchanger 的 slotExchange 方法

```java

public class Exchanger<V> {

    private final Object slotExchange(Object item, boolean timed, long ns) {

        // 获取当前线程身上的 Node 节点
        Node p = participant.get();

        Thread t = Thread.currentThread();
        // 线程的中断标识为 true, 返回 null
        if (t.isInterrupted()) 
            return null;

        for (Node q;;) {
        
            // 槽位节点 solt 不为 null, 则说明已经有线程在这里等待交换数据了
            if ((q = slot) != null) {
                
                // 通过 cas 将当前对象的 slot 的值从 q 更新为 null
                if (SLOT.compareAndSet(this, q, null)) {
                    // 更新成功
                    // 获取槽位节点的传递内容
                    Object v = q.item;

                    // 当前线程传递给其他线程的内容
                    q.match = item;

                    // 当前节点中挂起的线程
                    Thread w = q.parked;
                    if (w != null)
                        // 唤醒挂起的线程
                        LockSupport.unpark(w);
                    // 返回槽位节点的传递值    
                    return v;
                }

                // 当前的核心数 > 1 并且  同时通过 cas 将 bound 从 0 设置为 256 
                if (NCPU > 1 && bound == 0 && BOUND.compareAndSet(this, 0, SEQ))
                    // 声明 arena 为一个  (Full + 2) * 64 的 Node 数组
                    arena = new Node[(FULL + 2) << ASHIFT];
            } else if (arena != null)
                // 多槽位不为空，需要执行多槽位交换, 直接返回 null
                return null;
            else {
                // 多槽位为空, 同时槽位节点也为空
                // 从线程自身获取到的节点 p 的 item (当前线程打算传递给其他线程的内容) 为当前的 item 值
                p.item = item;
                // 通过 cas 将当前的槽位节点从 null 设置为当前线程身上的节点
                if (SLOT.compareAndSet(this, null, p))
                    // 设置成功了, 结束死循环
                    break;
                // 设置失败, 先将线程自身获取到的节点 p 的 item 设置为 null, 重新跑一次循环    
                p.item = null;
            }    
        }    

        // 获取当前 p 节点身上的 hash 值, 默认值为 0
        int h = p.hash;
        // 是否设置了超时时候, 是的话, 过期时间 = 当前的纳秒 + 设置的超时时间的纳秒值, 否则超时时间为 0 
        long end = timed ? System.nanoTime() + ns : 0L;
        // 计算最大的自旋次数 = 核心数 > 1 吗, 是的话, 最大自旋次数为 1024, 否则为 1 次
        int spins = (NCPU > 1) ? SPINS : 1;
        Object v;

        // 只有从线程自身获取到的节点 p 里面的 从其他线程获取到的传递内容 为空, 就一直循环
        while ((v = p.match) == null) {
            
            // 自旋次数大于 0 
            if (spins > 0) {
                // 计算默认值, 第一次线程自身的 Node 节点的 h 为 0, 经过下面 3 步后还是为 0 
                h ^= h << 1; 
                h ^= h >>> 3; 
                h ^= h << 10;
                // 计算后的 h 还是为 0
                if (h == 0)
                    // h = 1024 | 当前线程的 id
                    h = SPINS | (int)t.getId();

                else if (h < 0 && (--spins & ((SPINS >>> 1) - 1)) == 0)
                    // (SPINS >>> 1) - 1 = (1024 / 2) - 1 = 511, 二进制 00000000 00000000 00000001 11111111
                    // 计算后的 h < 0  并且 spins - 1 后 & 511 等于 0,  
                    // 既每自旋 512 次, 同时 h < 0, 线程执行让步
                    Thread.yield();
            }
            // 槽位节点不等于线程自身的节点
            else if (slot != p)
                // 自旋次数重置为 1024
                spins = SPINS;
            
            // 1. 线程中断标识位 false
            // 2. 节点数组为 null
            // 3. 没有设置超时时间 或者 距离超时时间还 > 0   
            // 三个条件都满足  
            else if (!t.isInterrupted() && arena == null && (!timed || (ns = end - System.nanoTime()) > 0L)) {    
                // 线程自身的节点的挂起线程等于当前线程
                p.parked = t;
                // 如果槽位节点 等于当前的线程节点
                if (slot == p) {
                    // 超时时间 = 0
                    if (ns == 0L)
                        // 挂起当前线程
                        LockSupport.park(this);
                    else
                        // 带超时时间的挂起线程
                        LockSupport.parkNanos(this, ns);
                }
                p.parked = null;
            } else if (SLOT.compareAndSet(this, p, null)) {
                // 通过 cas 设置槽位节点 slot 从 p 设置为 null 成功了
                // v = 设置了超时时间 + 距离超时时间 <= 0 + 线程中断标识为 false, 返回默认值 TIMED_OUT, 否则返回 null
                v = timed && ns <= 0L && !t.isInterrupted() ? TIMED_OUT : null;
                // 跳出循环
                break;
            }
        }

        // 设置 p 节点的 match 属性为 null
        MATCH.setRelease(p, null);
        // 设置 p 节点的 item 属性为 null
        p.item = null;
        // 设置 p 节点的 hash 值 = 最新的 hash
        p.hash = h;
        // 返回从其他线程获取到的传递内容
        return v;
    }
}
```

### 22.3.4 Exchanger 的 arenaExchange 方法

```java
public class Exchanger<V> {

    private final Object arenaExchange(Object item, boolean timed, long ns) {
        Node[] a = arena;
        int alen = a.length;
        Node p = participant.get();
        for (int i = p.index;;) {                      // access slot at i
            int b, m, c;
            int j = (i << ASHIFT) + ((1 << ASHIFT) - 1);
            if (j < 0 || j >= alen)
                j = alen - 1;
            Node q = (Node)AA.getAcquire(a, j);
            if (q != null && AA.compareAndSet(a, j, q, null)) {
                Object v = q.item;                     // release
                q.match = item;
                Thread w = q.parked;
                if (w != null)
                    LockSupport.unpark(w);
                return v;
            }
            else if (i <= (m = (b = bound) & MMASK) && q == null) {
                p.item = item;                         // offer
                if (AA.compareAndSet(a, j, null, p)) {
                    long end = (timed && m == 0) ? System.nanoTime() + ns : 0L;
                    Thread t = Thread.currentThread(); // wait
                    for (int h = p.hash, spins = SPINS;;) {
                        Object v = p.match;
                        if (v != null) {
                            MATCH.setRelease(p, null);
                            p.item = null;             // clear for next use
                            p.hash = h;
                            return v;
                        }
                        else if (spins > 0) {
                            h ^= h << 1; h ^= h >>> 3; h ^= h << 10; // xorshift
                            if (h == 0)                // initialize hash
                                h = SPINS | (int)t.getId();
                            else if (h < 0 &&          // approx 50% true
                                     (--spins & ((SPINS >>> 1) - 1)) == 0)
                                Thread.yield();        // two yields per wait
                        }
                        else if (AA.getAcquire(a, j) != p)
                            spins = SPINS;       // releaser hasn't set match yet
                        else if (!t.isInterrupted() && m == 0 &&
                                 (!timed ||
                                  (ns = end - System.nanoTime()) > 0L)) {
                            p.parked = t;              // minimize window
                            if (AA.getAcquire(a, j) == p) {
                                if (ns == 0L)
                                    LockSupport.park(this);
                                else
                                    LockSupport.parkNanos(this, ns);
                            }
                            p.parked = null;
                        }
                        else if (AA.getAcquire(a, j) == p &&
                                 AA.compareAndSet(a, j, p, null)) {
                            if (m != 0)                // try to shrink
                                BOUND.compareAndSet(this, b, b + SEQ - 1);
                            p.item = null;
                            p.hash = h;
                            i = p.index >>>= 1;        // descend
                            if (Thread.interrupted())
                                return null;
                            if (timed && m == 0 && ns <= 0L)
                                return TIMED_OUT;
                            break;                     // expired; restart
                        }
                    }
                }
                else
                    p.item = null;                     // clear offer
            }
            else {
                if (p.bound != b) {                    // stale; reset
                    p.bound = b;
                    p.collides = 0;
                    i = (i != m || m == 0) ? m : m - 1;
                }
                else if ((c = p.collides) < m || m == FULL ||
                         !BOUND.compareAndSet(this, b, b + SEQ + 1)) {
                    p.collides = c + 1;
                    i = (i == 0) ? m : i - 1;          // cyclically traverse
                }
                else
                    i = m + 1;                         // grow
                p.index = i;
            }
        }
    }
}
```


## 22.4 参考
[大白话说Java并发工具类-Semaphore, Exchanger](https://github.com/CL0610/Java-concurrency/blob/master/26.%E5%A4%A7%E7%99%BD%E8%AF%9D%E8%AF%B4java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB-Semaphore%EF%BC%8CExchanger/%E5%A4%A7%E7%99%BD%E8%AF%9D%E8%AF%B4java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB-Semaphore%EF%BC%8CExchanger.md)

