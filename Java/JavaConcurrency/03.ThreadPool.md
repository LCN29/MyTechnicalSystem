# 3 ThreadPool

## 3.1 为什么使用线程池

在实际使用中, 线程是很占用系统资源的, 如果对线程管理不善很容易导致系统问题。  
因此, 在大多数并发框架中都会使用线程池来管理线程, 使用线程池管理线程主要有如下好处: 

> 1. 降低资源消耗。通过复用已存在的线程和降低线程关闭的次数来尽可能降低系统性能损耗
> 2. 提升系统响应速度。通过复用线程, 省去创建线程的过程, 因此整体上提升了系统的响应速度
> 3. 提高线程的可管理性。线程是稀缺资源, 如果无限制的创建, 不仅会消耗系统资源, 还会降低系统的稳定性, 因此, 需要使用线程池来管理线程。


## 3.2 线程池添加任务的流程

![Alt 'ThreadPoolAndTaskProcesses'](https://raw.githubusercontent.com/PictureRespository/Java/main/JavaConcurrency/ThreadPoolAndTaskProcesses.png)

上面是向线程池中添加任务的流程图:

> 1. 判断**线程池的线程个数是否大于核心线程池个数**, 如果不是, 则新创建一个线程执行刚提交的任务, 否则进入第 2 步
> 2. 判断当前阻塞队列是否已满, 如果未满, 则将提交的任务放置在阻塞队列中，否则进入第 3 步
> 3. 判断**线程池的线程个数是否大于最大线程个数**, 如果没有, 则创建一个新的线程来执行任务, 否则进入第 4 步
> 4. 按照配置的拒绝策略 (没有配置有默认值) 进行处理

## 3.3 创建线程池

### 3.3.1 创建线程池的几个重要参数

从上面的流程图可以知道向线程池添加任务的流程, 从中可以提取出几个关键的参数

> 1. 核心线程个数
> 2. 最大线程个数
> 3. 阻塞队列
> 4. 拒绝策略

线程池中的线程数个数是逐渐增长的，不是一开始就创建好的。  
线程个数先从 0 增长到核心线程个数, 核心个数的线程一旦达到了就不会增加了。  
后续如果核心线程不够处理任务了, 线程数还会继续增加, 一直达到最大线程个数。  
和核心线程数不同的是, 不是核心线程的这些线程在空闲的时候, 会销毁的。

所以在创建线程池除了需要指定上面的 4 个参数, 还有指定另外 3 个
> 1. 线程空闲多长时间进行销毁
> 2. 线程空闲多长时间的单位: 秒, 分钟等
> 3. 线程工厂, 用于线程池中创建线程

### 3.3.2 线程池的定义

![Alt 'ThreadPoolUML'](https://raw.githubusercontent.com/PictureRespository/Java/main/JavaConcurrency/ThreadPoolUML.png)

从 Java 线程池 Executor 框架体系可以看出 ThreadPoolExecutor 是线程池的定义。

### 3.3.2 ThreadPoolExecutor 的构造函数

```java
public class ThreadPoolExecutor extends AbstractExecutorService {

    // 指定 核心线程数 最大线程数 存活时间 存活时间单位 阻塞队列
    public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue) {
        //调用自身 7 个参数的构造函数, 默认工厂 Executors.DefaultThreadFactory 默认拒绝策略 AbortPolicy
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);
    }

    // 指定 核心线程数 最大线程数 存活时间 存活时间单位 阻塞队列 线程工厂
    public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) {
        //调用自身 7 个参数的构造函数, 默认拒绝策略 AbortPolicy
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, defaultHandler);
    }

    // 指定 核心线程数 最大线程数 存活时间 存活时间单位 阻塞队列 拒绝策略
    public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, RejectedExecutionHandler handler) {
        //调用自身 7 个参数的构造函数, 默认工厂 Executors.DefaultThreadFactory 
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), handler);
    }

    // 指定 核心线程数 最大线程数 存活时间 存活时间单位 阻塞队列 线程工厂 拒绝策略
    public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) {
        
        // 核心线程， 最大线程 存活时间 必须大于 0, 最大线程数必须大于等于核心线程数
        if (corePoolSize < 0 || maximumPoolSize <= 0 || maximumPoolSize < corePoolSize || keepAliveTime < 0)
            throw new IllegalArgumentException();

        // 阻塞队列 线程工厂 拒绝策略 不能为空
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException(); 

        this.acc = System.getSecurityManager() == null ? null : AccessController.getContext();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
}
```

**corePoolSize**  
核心线程个数。 当提交一个任务时, 如果当前核心线程池的线程个数没有达到corePoolSize, 则会创建新的线程来执行所提交的任务, 即使当前核心线程池有空闲的线程。  
如果当前核心线程的个数已经达到了 corePoolSize, 则不再重新创建线程。 

如果调用了 
> 1. prestartCoreThread() 立即创建出一个核心线程
> 2. prestartAllCoreThreads() 所有的核心线程都会被创建

**maximumPoolSize**  
线程池能创建线程的最大个数。 如果当阻塞队列已满时, 并且当前线程池线程个数没有超过 maximumPoolSize 的话, 就会创建新的线程来执行任务。

**keepAliveTime**   
空闲线程存活时间。如果当前线程池的线程个数已经超过了 corePoolSize, 并且线程空闲时间超过了 keepAliveTime 的话, 就会将这些空闲的非核心线程销毁, 这样可以尽可能降低系统资源消耗。

线程池中维护了一个变量 **allowCoreThreadTimeOut**,  这个字段决定了能回收的线程是否包含核心线程。
allowCoreThreadTimeOut, 默认为 false, 表示线程回收只针对非核心线程数。  
allowCoreThreadTimeOut, 为 true, 则核心线程超过了空闲时间， 也会被回收, 但是这种做法违背了线程池的理念: 线程复用。

可以通过 线程池的 **allowsCoreThreadTimeOut()** 方法进行设置。

**unit**  
时间单位。为 keepAliveTime 指定时间单位。

**workQueue**  
阻塞队列。用于保存任务的阻塞队列, 可以使用 ArrayBlockingQueue,  LinkedBlockingQueue,  SynchronousQueue,  PriorityBlockingQueue 等。

**threadFactory**  
创建线程的工程类。可以通过指定线程工厂为每个创建出来的线程设置更有意义的名字, 如果出现并发问题, 也方便查找问题原因。

**handler**  
拒绝策略。 当线程池的阻塞队列已满和指定的线程都已经开启, 说明当前线程池已经处于饱和状态了, 那么就需要采用一种策略来处理这种情况。  

### 3.3.3 阻塞队列

创建 ThreadPoolExecutor 时需要指定一个阻塞队列。官方推荐的有 3 个

**1. SynchronousQueue** 同步队列, 内部没有任何容量的阻塞队列, 任何一次插入操作的元素都要等待另一边执行删除/读取操作，否则进行插入操作的线程就要一直等待。

**2. LinkedBlockingQueue** 基于链表结构实现的无界限 (理论上的无界限, 最大值为 Integer.MAX_VALUE) 的队列。 因为队列是无限的, 不会达到上限, 所以不会触发线程达到最大线程数的情况, 所以的线程都是核心线程。  
这种队列可以提高线程池吞吐量，但代价是牺牲内存空间，甚至会导致内存溢出。 LinkedBlockingQueue 可以在声明的时候指定容量, 指定了容量的话, 就会变成一个有限队列

**3. ArrayBlockingQueue** 基于数组实现的有限队列。 这种有界队列有利于防止资源耗尽，但可能更难调整和控制

Java 还提供了另外 4 种队列可以选择

**1. PriorityBlockingQueue** 支持优先级排序的无界阻塞队列。存储在里面的元素要么实现了 Comparable 接口或者在内部指定了比较器 Comparator, 才能对里面的元素进行比较。PriorityBlockingQueue 只保证优先级最高的元素始终排在队列的头部,  
但是不保证优先级一样的元素的顺序, 也不保证除了优先级最高的元素以外的元素，都能处于正确排序的位置

**2. DelayQueue** 基于二叉堆实现的延迟队列, 时间没到任务取不出来。同时具备：无界队列、阻塞队列、优先队列的特征。存储在里面的元素需要实现 Delayed 接口。

**3. LinkedBlockingDeque** 双端队列。基于链表实现，既可以从尾部插入/取出元素，还可以从头部插入元素/取出元素

**4. LinkedTransferQueue** 由链表结构组成的无界阻塞队列。这个队列比较特别的时，采用一种预占模式。消费者线程取元素时，如果队列不为空, 直接获取。为空, 生成一个节点（节点元素为 null）入队, 消费者线程被等待在这个节点上, 后面生产者线程入队时发现有一个元素为null的节点，生产者线程就不入队了，直接就将元素填充到该节点, 并唤醒该节点等待的线程，被唤醒的消费者线程取走元素。


### 3.3.3 拒绝策略

**AbortPolicy** 
直接拒绝所提交的任务, 并抛出 RejectedExecutionException 异常  

**CallerRunsPolicy** 
只用调用者所在的线程来执行任务

**DiscardPolicy**  
不处理直接丢弃掉任务

**DiscardOldestPolicy**  
丢弃掉阻塞队列中存放时间最久的任务, 执行当前任务

## 3.3 线程池状态 

线程池有 5 种状态

```java

public static final int SIZE = 32;

// Integer.SIZE = 32, count_bits = 32 - 3 = 29
private static final int COUNT_BITS = Integer.SIZE - 3;

// 当创建线程池后, 初始时, 线程池处于 RUNNING 状态
// -536870912, 二进制 11100000000000000000000000000000
private static final int RUNNING    = -1 << COUNT_BITS;

// 如果调用了 shutdown() 方法, 则线程池处于 SHUTDOWN 状态, 此时线程池不能够接受新的任务, 它会等待所有任务执行完毕
// 0,  二进制  0000000000000000000000000000000
private static final int SHUTDOWN   =  0 << COUNT_BITS;

// 如果调用了shutdownNow() 方法，则线程池处于 STOP 状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务
// 536870912, 二进制 0100000000000000000000000000000
private static final int STOP       =  1 << COUNT_BITS;

// 线程池中的所有任务都已终止, 则会变为, 都是从 stop / shutdown 转为 tidying
// 1073741824, 二进制 1000000000000000000000000000000
private static final int TIDYING    =  2 << COUNT_BITS;

// 线程池彻底终止
// 1610612736, 二进制 1100000000000000000000000000000
private static final int TERMINATED =  3 << COUNT_BITS;

```

## 3.3 线程池的使用

### 3.3.1 自定义线程池 ThreadPoolExecutor

```java

// 自定义线程工厂类
public static class MyThreadFactory implements ThreadFactory {

    private final AtomicInteger threadNumber = new AtomicInteger(1);

    @Override
    public Thread newThread(Runnable r) {
        return new Thread("My-Thread" + threadNumber.getAndIncrement());
    }


    int corePoolSize = 5;
    int maximumPoolSize = 10;
    long keepAliveTime = 1000L;
    BlockingQueue<Runnable> workQueue = new ArrayBlockingQueue(20);

    // 创建线程池
    ThreadPoolExecutor threadPool = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.SECONDS, workQueue, new MyThreadFactory(), new AbortPolicy());
    // 自定义 Runable 任务
    Runnable task = () -> System.out.println("Finish");
    // 提交任务
    threadPool.execute(task);
    // 关闭线程池
	threadPool.shutdown(); 

}
```


### 3.3.2 官方提供的线程池工具类 Executors

#### 3.3.2.1 FixedThreadPool

线程数固定的线程池。 其特点是**最大线程数等于核心线程数**, **keepAliveTime 时间为 0**