# 12 volatile

synchronized 是阻塞式同步, 在线程竞争激烈的情况下会升级为重量级锁, 而 volatile 则是 Java 虚拟机提供的最轻量级的同步机制。   
在 Java 内存模型中, 各个线程会将共享变量从主内存中拷贝到工作内存，然后执行引擎会基于工作内存中的数据进行操作处理。    

线程在工作内存进行操作后何时会写到主内存中? 这个时机对普通变量是没有规定的。 而针对 volatile 修饰的变量在 Java 虚拟机有特殊的约定: 线程对 volatile 变量的修改会立刻被其他线程所感知, 即立即刷新到主内容, 不会出现数据脏读的现象，
从而保证数据的 "可见性"。

## 12.1 volatile 实现原理

```java
public class Demo {

    private volatile String name;

    private void setName(String name) {
        this.name = name;
    }
}
```

在生成汇编代码时会在 volatile 修饰的共享变量进行写操作的时候会多出 Lock 前缀的指令, 这个指令的作用有:
> 1. 将当前处理器缓存行的数据写回系统内存
> 2. 这个写回内存的操作会使得其他 CPU 里缓存了该内存地址的数据无效

为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存 (L1, L2 或其他) 后再进行操作, 但操作完不知道何时会写到内存。  
对声明了 volatile 的变量进行写操作, JVM 就会向处理器发送一条 Lock 前缀的指令, 将这个变量所在缓存行的数据写回到系统内存。  
写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。所以, 在多处理器下，为了保证各个处理器的缓存是一致的，就会实现**缓存一致性协议**。
**每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了**， 当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，  
当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里, 经过分析我们可以得出如下结论：  
> 1. Lock 前缀的指令会引起处理器缓存写回内存
> 2. 一个处理器的缓存回写到内存会导致其他处理器的缓存失效
> 3. 当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值

## 12.2 volatile 的 Happens-Before 关系  

volatile 变量可以通过**缓存一致性协议**保证每个线程都能获得最新值，即满足数据的 "可见性"。那么 volatile 和 JMM 的关系可以通过  Happens-Before 关系中的 **volatile变量规则 (对一个 volatile 变量的写操作 Happens-Before 后续每一个针对该变量的读操作)** 进行分析。

```java
public class VolatileExample {

    private int a = 0;

    private volatile boolean flag = false;

    public void writer(){
        // 1
        a = 1;         
        // 2
        flag = true;
    }

    public void reader(){
        // 3
        if(flag){
            // 4
            int i = a;
        }

    }

}
```

![Alt 'VolatileAndHappensBeforeRelation'](https://raw.githubusercontent.com/PictureRespository/Java/main/JavaConcurrency/VolatileAndHappensBeforeRelation.png)


线程 A 先执行 writer 方法, 然后线程 B 执行 reader 方法。图中每一个箭头两个节点就代表一个 Happens-Before 关系。  
黑色的代表根据程序顺序规则推导出来的,    
红色的是根据 volatile 变量的写 Happens-Before 于任意后续对 volatile 变量的读，得到的,    
而蓝色的就是根据传递性规则推导出来的。

这里的 2 Happen-Before 3，同样根据 Happens-Before 规则定义：如果 A Happens-Before B, 则 A 的执行结果对 B 可见，并且 A 的执行顺序先于 B 的执行顺序，  
我们可以知道操作 2 执行结果对操作 3 来说是可见的, 也就是说当线程 A 将 volatile 变量 flag 更改为 true 后线程 B 就能够迅速感知。  

## 12.3 volatile 的内存语义

以上面的代码为例，假设线程 A 先执行 writer 方法，线程 B 随后执行 reader 方法，初始时线程的本地内存中 flag 和 a 都是初始状态，下图是线程 A 执行 volatile 写后的状态图



当 volatile 变量写后，线程中本地内存中共享变量就会置为失效的状态，因此线程 B 再需要读取从主内存中去读取该变量的最新值。下图就展示了线程 B 读取同一个 volatile 变量的内存变化示意图



从横向来看，线程 A 和线程 B 之间进行了一次通信，线程 A 在写 volatile 变量时，实际上就像是给 B 发送了一个消息告诉线程 B 现在的值都是旧的了，然后线程 B 读这个 volatile 变量时就像是接收了线程 A 刚刚发送的消息, 直接到主内存获取新的值。
