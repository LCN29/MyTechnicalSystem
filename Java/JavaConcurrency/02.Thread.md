# 2 Thread

线程是操作系统调度的最小单元，也叫轻量级进程。它被包含在进程之中，是进程中的实际运作单位。同一进程可以创建多个线程，每个线程都有自己独立的一块内存空间, 并且能够访问共享的内存变量。

## 2.1 线程的分类

在 Java 中, 线程可以分为 2 种
> 1. 守护线程: 守护线程是为用户线程服务的线程, 在后台默默地完成一些系统性的服务, 如垃圾回收等
> 2. 用户线程: 真正完成业务的工作线程

在一个应用程序中, 如果用户线程全部结束了, 意味着程序需要完成的业务操作已经结束, 系统可以退出了。  
所以当系统只剩下守护进程的时候, Java 虚拟机会自动退出。  
反之, 如果程序中的用户进程还在执行中， Java 虚拟机会等待器执行完成才结束。  

## 2.2 线程的创建

### 2.2.1 继承 Thread 类，重写 run 方法

```java
public void createThread() {

    Thread thread = new Thread(new Runnable(){

        @Override
        public void run() {
            System.out.println("Thread is running " + Thread.currentThread().getName());
        }

    }
    // 启动线程
    thread.start();
}
```

### 2.2.2 实现 Runnable 接口

```java
public void createThread() {

    Thread thread = new Thread(new Runnable(){

        @Override
        public void run() {
            System.out.println("Thread is running " + Thread.currentThread().getName());
        }
    });

    thread.start();
}
```

可以通过源码知道，Thread 是 Runnable 接口的实现类，调用 Thread.run / start 方法，最终是调用传进去的 Runnable 实现类的 run 方法。

### 2.2.3 实现 Callable 接口, 配合 ExecutorService 使用

```java
public void createThread() {
    
    Callable<String> callable = new Callable<>() {
        @Override
        public String call() throws Exception {
            System.out.println("Thread is running " + Thread.currentThread().getName());
            Thread.sleep(3000L);
            return "finish";
        }
    };

    ExecutorService executorService = Executors.newSingleThreadExecutor();

    // 提交任务到线程池, Future 是对执行结果的封装
    Future<String> future = executorService.submit(callable);

    try {

        // 尝试获取执行结果
        // 注意：Future.get 方法是一个阻塞方法。如果对应的线程这时候还没有执行完成, 调用这个方法，会阻塞当前线程
        String result = future.get();
        System.out.println("Thread's result:" + result);

    } catch(Exception e) {
        e.printStackTrace();
    } finally {
        // 关闭线程池
        executorService.shutdown();
    }    
}
```

Callable 接口的功能和 Runnable 类似, 不同的是 Callable 有返回值和可以抛出异常, 可以通过返回值得到执行结果, 也可以通过捕获异常进行容错处理等。  

注: 通过 Callable 一般情况下会立即返回一个 Future, 在执行完成后将结果才放到这个对象里面。
主线程可以调用 Futrue 的 get 方法获取执行返回值, 如果线程未执行完成, Futrue 内还未有返回结果的话, 此时调用 get 方法, 会导致线程阻塞。
