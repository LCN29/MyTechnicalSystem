# 4 JMM

JMM 全称：Java Memory Model, Java 内存模式。它是一种虚拟机规范，用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现 Java 程序在各种平台下都能达到一致的并发效果。  
主要规定了以下两点
> 1. 一个线程**如何以及何时**可以看到其他线程修改过后的共享变量的值，即线程之间**共享变量的可见性**
> 2. 如何在需要的时候对共享变量进行同步

在并发编程中，所要处理的两个关键问题就是这两条标准的体现：**线程之间如何通信**以及**线程之间如何同步**。  

## 4.1 线程通信
通信是指线程之间以何种机制来交换信息。在命令式的编程中，线程之间的通信机制有两种：**共享内存**和**消息传递**。

在共享内存并发的模型里，线程之间共享程序的公共状态，线程之间通过读 - 写内存中的公共状态来隐式进行通信。  
在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显示进行通信，在 Java 中典型的消息传递方式就是 wait() 和 notify()。

Java 的并发采用的就是 **共享内存模型**, Java 线程之间的通信总是隐式进行的，整个通信过程对程序员是完全透明的。这里提到的共享内存模型指的就是 Java 内存模型 (简称 JMM )。

## 4.2 线程同步
同步是指程序用于控制不同线程之间操作发生相对顺序的机制。  

在共享内存并发模型里，同步是显式进行的。程序必须显式指定某个方法或某段代码需要在线程之间互斥执行。
在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。

## 4.3 JMM 抽象结构模型  

JMM 定义了线程和主内存之间的抽象关系：  
线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存 (Local Memory), 本地内存中存储了该线程已 读/写 共享变量的副本。  
本地内存是 JMM 的一个抽象概念, 并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。

![Alt 'JMMAbstractModel'](https://raw.githubusercontent.com/PictureRespository/Java/main/JavaConcurrency/JMMAbstractModel.png)

从上图来看，线程 A 与线程 B 之间如要通信的话, 必须要经历下面 2 个步骤
> 1. 线程 A 把本地内存 A 中更新过的共享变量刷新到主内存中去
> 2. 线程 B 到主内存中去读取线程 A 更新的共享变量

## 4.4 JVM 对 Java 内存模型的实现

![Alt 'JVMMemoryArea'](https://raw.githubusercontent.com/PictureRespository/Java/main/JavaConcurrency/JVMMemoryArea.png)

JVM 在执行 Java 程序的过程中会把它所管理的内存划分为若干不同的数据区域，这些区域都有各自的用途以及创建和销毁的时间。

主要包含 2 类：
> 1. 线程共享区域：方法区（Method Area）和 堆（Heap）
> 2. 线程私有区域：虚拟机栈（VM Stack），本地方法栈（Native Method Stack），程序计数器（PC Register）

**虚拟机栈**   
每一个运行在 Java 虚拟机上的线程都拥有自己的线程栈。每个方法在执行的时候都会创建一个栈帧用于存储局部变量表、操作数栈、动态链表、方法出口信息等。  
每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。  
虚拟机栈的生命周期与线程相同。


**本地方法栈**  
本地方法栈与虚拟机栈的作用相似，不同之处在于虚拟机栈为虚拟机执行的 Java 方法服务，而本地方法栈则为虚拟机使用到的 Native 方法服务

**程序计数器**   
程序计数器保存着每一条线程下一次执行指令位置

**堆**   
用来保存程序中所创建的所有对象、数组元素等

**方法区**   
方法区是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

### 4.4.1 数据存储总结
> 1. 一个本地变量是原始类型, 它会被完全存储到栈区
> 2. 一个本地变量是引用类型, 这个本地引用会被存储到栈中，但是对象本身仍然存储在堆区
> 3. 一个对象的成员方法，方法中包含局部变量，存储在栈区
> 4. 一个对象的成员变量，不管它是原始类型还是包装类型，都存储到堆区
> 5. static 类型的变量以及类本身相关信息都会随着类本身存储在方法区

## 4.5 JMM 带来的问题

### 4.5.1 可见性问题

![Alt 'ShardVariableVisibilityProblem'](https://raw.githubusercontent.com/PictureRespository/Java/main/JavaConcurrency/ShardVariableVisibilityProblem.png)

如上图，3 个 共享变量 count, 2 个为副本。  
启动 2 个线程分别对共享变量操作, 假设原本共享变量 count 为 0。
> 1. 线程 A 从主内存将这个共享变量 count 加载到自己的本地内存, 值为 0
> 2. 线程 B 执行同样的加载操作, 值为 0
> 3. 线程 A 对这个共享变量 count + 1, count 的值变为 1, 没有将这个值同步到主内存
> 4. 线程 B 这时候同样需要对这个共享变量 count + 1, 但是这时候 B 中的 count 还是 0, 没有感知到 A 对其做的修改


在多线程的环境下，如果某个线程首次读取共享变量，则首先到主内存中获取该变量，然后存入工作内存中，以后只需要在工作内存中读取该变量即可。  
同样如果对该变量执行了修改的操作，则先将新值写入工作内存中，然后再刷新至主内存中, 这个刷新时间虽然很短但并不确定。

### 4.5.2 竞争问题

![Alt 'SharedVariableCompetitionProblem'](https://raw.githubusercontent.com/PictureRespository/Java/main/JavaConcurrency/SharedVariableCompetitionProblem.png)

如上图:  
如果这两个加 1 操作是串行的，最终主内存中的 count 的值应该是 3。  
然而图中两个加 1 操作是并行的，当它们值更新到工作内存的副本后，会争相刷新主内存。在这里，不管是线程 1 还是线程 2 先刷新计算结果到主内存，最终主内存中的值只能是 2。

### 4.5.3 重排序

可见性和竞争都是有共享内存和工作内存带来的。在并发中, 除了这 2 个地方会引起问题外, 在编译器中还存在重排序问题: 在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。  
这些系统内部的优化大部分都是有效的, 但是有时在并发编程中, 则会带来某些问题。