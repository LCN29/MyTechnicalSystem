
# 01. Java 文件到 JVM 的过程

## 1.1 Java 文件到 class 文件

我们编写的 Java 源代码需要借助 Javac 编译器, 才能编译成 JVM 能识别的字节码文件, 流程如图所示

![Alt 'Java 源代码编译为字节码文件的过程'](https://s3.ax1x.com/2021/01/23/s7ilCT.md.jpg)


Javac 是一种编译器，能**将一种语言规范转化成另外一种语言规范，通常编译器都是将便于人理解的语言规范转化成机器容易理解的语言规范**，如 C/C++ 或者汇编语言都是将源代码直接编译成目标机器码，这个目标机器代码是 CPU 直接执行的指令集合。这些指令集合也就是底层的一种语言规范。

Javac 的编译器也是将 Java这 种对人非常友好的编程语言编译成对对所有机器都非常友好的一种语言。这种语言不是针对某种机器或某个平台。**怎么消除不同种类，不同平台之间的差异这个任务就有 JVM 来完成**，而 Javac 的任务就是将 Java 源代码语言转化为 JVM 能够识别的一种语言，然后由 JVM 将 JVM 语言再转化成当前这个机器能够识别的机器语言。

Javac 的任务就是将 Java 源代码编译成 Java 字节码，也就是JVM能够识别的二进制代码，从表面看是将 .java 文件转化为 .class 文件。而实际上是将 Java 源代码转化成一连串二进制数字，这些二进制数字是有格式的，只有 JVM 能够真确的识别他们到底代表什么意思。

编译器把一种语言规范转化为另一种语言规范的这个过程需要哪些步骤？回答这个问题需要参照《编译原理》，总结过程如下:

1）词法分析：读取源代码，一个字节一个字节的读进来，找出这些词法中我们定义的语言关键词如：if、else、while 等，识别哪些 if 是合法的哪些是不合法的。这个步骤就是词法分析过程。

词法分析的结果：就是从源代码中找出了一些规范化的 token 流，就像人类语言中，给你一句话你要分辨出哪些是一个词语，哪些是标点符号，哪些是动词，哪些是名词。

2）语法分析：就是对词法分析中得到的 token 流进行语法分析，这一步就是检查这些关键词组合在一起是不是符合 Java 语言规范。如 if 的后面是不是紧跟着一个布尔型判断表达式。

语法分析的结果：就是形成一个符合 Java 语言规定的抽象语法树，抽象语法树是一个结构化的语法表达形式，它的作用是把语言的主要词法用一个结构化的形式组织在一起。这棵语法树可以被后面按照新的规则再重新组织。

 3）语义分析：语法分析完成之后也就不存在语法问题了，语义分析的主要工作就是把一些难懂的，复杂的语法转化成更简单的语法。就如难懂的文言文转化为大家都懂的百话文，或者是注释一下一些不懂的成语。

语义分析结果：就是将复杂的语法转化为简单的语法，对应到 Java 就是将 foreach 转化为 for 循环，还有一些注释等。最后生成一棵抽象的语法树，这棵语法树也就更接近目标语言的语法规则。

4）字节码生成：将会根据经过注释的抽象语法树生成字节码，也就是将一个数据结构转化为另外一个数据结构。就像将所有的中文词语翻译成英文单词后按照英文语法组装成英文语句。代码生成器的结果就是生成符合 Java 虚拟机规范的字节码。这个过程中的需要的组件如下图所示

![Alt '字节码生成过程'](https://s3.ax1x.com/2021/01/23/s7VfgK.md.png)

从上面的描述中我们知道编译就是将一种语言通过分析分解，再按照一定的方式先形成一个简单的框架（将 Java 源文件的字节流转化为对应的 token 流）然后在通过详细的分析按照一定的规定在这个框架里添加东西使这个token流形成更加结构化的语法树（就是将前面生成的token流中的一个个单词组装成一句话），但是这棵树离我们的目标— Java 字节码还有点差距，所以再进行语义分析使那颗粗糙的树更加完整完善（给类添加默认的构造函数，检查变量在使用前有没有初始化，检查操作变量类型是否匹配），然后 Javac 编译器调用 com.sun.tools.javac.jvm.Gen 类遍历这棵语法树将 Java 方法中的代码块转换成符合 JVM 语法的命令形式的二进制数据。按照 JVM 的文件组织格式将字节码输出到以 class 为扩展名的文件中，也就是生成最终的 Java 字节码。**词法分析就是将关键词组织成 token 流即检查源码中的的关键词是否真确并组织成 token 流，而语法分析就是检查源码是否符合 Java 语法规范并将词组成语句。语义分析就是简化复杂的添加缺少的，检查变量类型是否合法。代码生成器就是遍历这棵树生成符合 JVM 规范的代码**。

## 1.2 class 加载到 JVM

![ALt '类的生命周期'](https://s3.ax1x.com/2021/01/23/s7XU2R.md.jpg)

如图一个类生命周期包括

> 1. 装载
> 2. 链接(验证、准备、解析)
> 3. 初始化
> 4. 使用
> 5. 卸载

而涉及到类加载阶段的有 装载, 链接，初始化 3 个阶段.

### 1.2.1 装载

1. 通过一个类的全限定名获取定义此类的二进制字节流(由类装载器 ClassLoader 进行加载操作)
2. 将类文件的信息交给 JVM (将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构)
3. 为类文件产生一个对应的 Class 对象(作为对方法区中这些数据的访问入口)


整个的加载过程涉及到**类加载机制**, 整个类加载机制涉及的知识点大体就2个 **不同的 ClassLoader** 和**双亲委派机制**。

* ClassLoader
在类的装载中, 我们知道 class 文件是由 ClassLoader 加载到 JVM 中的, 但是在 Java 中 ClassLoader 由很多个,同时还有优先级, 分别对不同区域的文件进行加载

![Alt 'ClassLoader'](https://s3.ax1x.com/2021/01/23/s7v6gA.png)]

如图, 处于最顶层的是  
Boostrap ClassLoader: 它主要负责加载 **$Java_Home$ 中 jre/lib/rt.jar 中所有 class 或 Xbootclasspath 选项指定的 jar 包**，它是由 C++ 编写的, 不是 ClassLoader 的子类

处于第二层的是  
Extension ClassLoader: 它主要负责加载**加载 Java 平台中扩展功能的一些 Jar 包, 包括 $Java_Home 中 `jre/lib/ext/*.jar` 或 -Djava.ext.dirs 指定目录下的 jar 包**, 由 Java 语言编写，父加载器为 null

处于第三层的是  
App ClassLoader; 它主要负责加载 **classpath 中指定目录下的类和 jar 包 或-Djava.class.path 指定目录下的 jar 包**

处于第四层的是 
Custom ClassLoader(自定义加载器): 通过 java.lang.ClassLoader 的子类自定义加载 class, 属于应用程序根据自身需要自定义的 ClassLoader ,如 tomcat, jboss 都会根据 j2ee 规范自行实现 ClassLoader, 满足我们装载器的特殊要求

* 双亲委派  
当我们的 class 文件加载到 JVM 中, 会对这些类进行分类, 由对应的 ClassLoader 进行加载。但是当存在 2 个全路径完全一致的类时，加载器应该怎么操作的，这就是有双亲委派其作用了。

运行的逻辑大体是这样的，下层的装载器加载类时，先不加载，先让父级去加载, 如果父级能加载，自身就不加载了, 这样每个父级就会调用自身的父级，直到 Boostrap ClassLoader 停止。简化过来就是从 Boostrap ClassLoader 开始尝试加载，没法加载就由子级加载, 这样就能保证全路径相同的类，可以优先加载到系统内部的，同时避免了全路径相同的类的出现。 代码的逻辑大体是这样的(ClassLoader.loadClass)

```java
protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
    synchronized (getClassLoadingLock(name)) {
        // 先检查类是否加载过
        Class<?> c = findLoadedClass(name);
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                // 有父级的话，让父级进行加载
                if (parent != null) {
                    c = parent.loadClass(name, false);
                } else {
                    // 没有父级，自己进行加载
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
            }

            // 依旧为空的，自己尝试进行查找
            if (c == null) {
                long t1 = System.nanoTime();
                c = findClass(name);

                // this is the defining class loader; record the stats
                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                sun.misc.PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
```

双亲委派机制的好处:
Java 类随着加载它的类加载器一起具备了一种带有优先级的层次关系。比如，Java 中的 Object 类，它存放在 rt.jar之 中,无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 在各种类加载环境中都是同一个类。如果不采用双亲委派模型，那么由各个类加载器自己取加载的话，那么系统中会存在多种不同的 Object 类


* 双亲委派的破坏  
自定义的类装载器重新 loadClass 方法

### 1.2.2 链接(验证，准备，解析)

1. 验证  
主要用于保证被加载类的正确性
>1. 文件格式验证
>2. 元数据验证
>3. 字节码验证
>4. 符号引用验证

2. 准备  
为类的静态变量分配内存，并将其初始化为默认值

3. 解析  
把类中的符号引用转换为直接引用

### 1.2.3 初始化
对类的静态变量，静态代码块执行初始化操作


## 1.3 类文件数据的存储位置
当我们把类文件加载进 JVM 后, 不是直接开辟一个空间就把这个文件存储下来，而是会把这个类文件按照不同的内容存储在不同的地方

1. 类文件信息(类的结构)存储在 **Method Area(方法区)**
2. 类文件对应的 Class 对象存储在 **heap(堆)**




## 1.3 转载来源
[Java代码编译过程简述](https://blog.csdn.net/fuzhongmin05/article/details/54880257)

[JVM系列——java文件到JVM中的整个过程](https://blog.csdn.net/o9109003234/article/details/105501939)