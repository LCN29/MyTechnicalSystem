
# 01. Java 文件到 JVM 的过程

## 1.1 Java 文件到 class 文件

我们编写的 Java 源代码需要借助 Javac 编译器, 才能编译成 JVM 能识别的字节码文件, 流程如图所示

![Alt 'Java 源代码编译为字节码文件的过程'](https://s3.ax1x.com/2021/01/23/s7ilCT.md.jpg)


Javac 是一种编译器，能**将一种语言规范转化成另外一种语言规范，通常编译器都是将便于人理解的语言规范转化成机器容易理解的语言规范**，如 C/C++ 或者汇编语言都是将源代码直接编译成目标机器码，这个目标机器代码是 CPU 直接执行的指令集合。这些指令集合也就是底层的一种语言规范。

Javac 的编译器也是将 Java这 种对人非常友好的编程语言编译成对对所有机器都非常友好的一种语言。这种语言不是针对某种机器或某个平台。**怎么消除不同种类，不同平台之间的差异这个任务就有 JVM 来完成**，而 Javac 的任务就是将 Java 源代码语言转化为 JVM 能够识别的一种语言，然后由 JVM 将 JVM 语言再转化成当前这个机器能够识别的机器语言。

Javac 的任务就是将 Java 源代码编译成 Java 字节码，也就是JVM能够识别的二进制代码，从表面看是将 .java 文件转化为 .class 文件。而实际上是将 Java 源代码转化成一连串二进制数字，这些二进制数字是有格式的，只有 JVM 能够真确的识别他们到底代表什么意思。

编译器把一种语言规范转化为另一种语言规范的这个过程需要哪些步骤？回答这个问题需要参照《编译原理》，总结过程如下:

1）词法分析：读取源代码，一个字节一个字节的读进来，找出这些词法中我们定义的语言关键词如：if、else、while 等，识别哪些 if 是合法的哪些是不合法的。这个步骤就是词法分析过程。

词法分析的结果：就是从源代码中找出了一些规范化的 token 流，就像人类语言中，给你一句话你要分辨出哪些是一个词语，哪些是标点符号，哪些是动词，哪些是名词。

2）语法分析：就是对词法分析中得到的 token 流进行语法分析，这一步就是检查这些关键词组合在一起是不是符合 Java 语言规范。如 if 的后面是不是紧跟着一个布尔型判断表达式。

语法分析的结果：就是形成一个符合 Java 语言规定的抽象语法树，抽象语法树是一个结构化的语法表达形式，它的作用是把语言的主要词法用一个结构化的形式组织在一起。这棵语法树可以被后面按照新的规则再重新组织。

 3）语义分析：语法分析完成之后也就不存在语法问题了，语义分析的主要工作就是把一些难懂的，复杂的语法转化成更简单的语法。就如难懂的文言文转化为大家都懂的百话文，或者是注释一下一些不懂的成语。

语义分析结果：就是将复杂的语法转化为简单的语法，对应到 Java 就是将 foreach 转化为 for 循环，还有一些注释等。最后生成一棵抽象的语法树，这棵语法树也就更接近目标语言的语法规则。

4）字节码生成：将会根据经过注释的抽象语法树生成字节码，也就是将一个数据结构转化为另外一个数据结构。就像将所有的中文词语翻译成英文单词后按照英文语法组装成英文语句。代码生成器的结果就是生成符合 Java 虚拟机规范的字节码。这个过程中的需要的组件如下图所示

![Alt '字节码生成过程'](https://s3.ax1x.com/2021/01/23/s7VfgK.md.png)

从上面的描述中我们知道编译就是将一种语言通过分析分解，再按照一定的方式先形成一个简单的框架（将 Java 源文件的字节流转化为对应的 token 流）然后在通过详细的分析按照一定的规定在这个框架里添加东西使这个token流形成更加结构化的语法树（就是将前面生成的token流中的一个个单词组装成一句话），但是这棵树离我们的目标— Java 字节码还有点差距，所以再进行语义分析使那颗粗糙的树更加完整完善（给类添加默认的构造函数，检查变量在使用前有没有初始化，检查操作变量类型是否匹配），然后 Javac 编译器调用 com.sun.tools.javac.jvm.Gen 类遍历这棵语法树将 Java 方法中的代码块转换成符合 JVM 语法的命令形式的二进制数据。按照 JVM 的文件组织格式将字节码输出到以 class 为扩展名的文件中，也就是生成最终的 Java 字节码。**词法分析就是将关键词组织成 token 流即检查源码中的的关键词是否真确并组织成 token 流，而语法分析就是检查源码是否符合 Java 语法规范并将词组成语句。语义分析就是简化复杂的添加缺少的，检查变量类型是否合法。代码生成器就是遍历这棵树生成符合 JVM 规范的代码**。

## 1.2 class 加载到 JVM

![ALt '类的生命周期'](https://s3.ax1x.com/2021/01/23/s7XU2R.md.jpg)

如图一个类生命周期包括

> 1. 装载
> 2. 链接(验证、准备、解析)
> 3. 初始化
> 4. 使用
> 5. 卸载

而涉及到类加载阶段的有 装载, 链接，初始化 3 个阶段.

### 1.2.1 装载

1. 通过一个类的全限定名获取定义此类的二进制字节流(由类装载器 ClassLoader 进行加载操作)
2. 将类文件的信息交给 JVM (将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构)
3. 为类文件产生一个对应的 Class 对象(作为对方法区中这些数据的访问入口)


整个的加载过程涉及到**类加载机制**, 整个类加载机制涉及的知识点大体就2个 **不同的 ClassLoader** 和**双亲委派机制**。

* ClassLoader
在类的装载中, 我们知道 class 文件是由 ClassLoader 加载到 JVM 中的, 但是在 Java 中 ClassLoader 由很多个,同时还有优先级, 分别对不同区域的文件进行加载

![Alt 'ClassLoader'](https://s3.ax1x.com/2021/01/23/s7v6gA.png)]

如图, 处于最顶层的是  
Boostrap ClassLoader: 它主要负责加载 **$Java_Home$ 中 jre/lib/rt.jar 中所有 class 或 Xbootclasspath 选项指定的 jar 包**，它是由 C++ 编写的, 不是 ClassLoader 的子类

处于第二层的是  
Extension ClassLoader: 它主要负责加载**加载 Java 平台中扩展功能的一些 Jar 包, 包括 $Java_Home 中 `jre/lib/ext/*.jar` 或 -Djava.ext.dirs 指定目录下的 jar 包**, 由 Java 语言编写，父加载器为 null

处于第三层的是  
App ClassLoader; 它主要负责加载 **classpath 中指定目录下的类和 jar 包 或-Djava.class.path 指定目录下的 jar 包**

处于第四层的是 
Custom ClassLoader(自定义加载器): 通过 java.lang.ClassLoader 的子类自定义加载 class, 属于应用程序根据自身需要自定义的 ClassLoader ,如 tomcat, jboss 都会根据 j2ee 规范自行实现 ClassLoader, 满足我们装载器的特殊要求

* 双亲委派  
当我们的 class 文件加载到 JVM 中, 会对这些类进行分类, 由对应的 ClassLoader 进行加载。但是当存在 2 个全路径完全一致的类时，加载器应该怎么操作的，这就是有双亲委派其作用了。

运行的逻辑大体是这样的，下层的装载器加载类时，先不加载，先让父级去加载, 如果父级能加载，自身就不加载了, 这样每个父级就会调用自身的父级，直到 Boostrap ClassLoader 停止。简化过来就是从 Boostrap ClassLoader 开始尝试加载，没法加载就由子级加载, 这样就能保证全路径相同的类，可以优先加载到系统内部的，同时避免了全路径相同的类的出现。 代码的逻辑大体是这样的(ClassLoader.loadClass)

```java
protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
    synchronized (getClassLoadingLock(name)) {
        // 先检查类是否加载过
        Class<?> c = findLoadedClass(name);
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                // 有父级的话，让父级进行加载
                if (parent != null) {
                    c = parent.loadClass(name, false);
                } else {
                    // 没有父级，自己进行加载
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
            }

            // 依旧为空的，自己尝试进行查找
            if (c == null) {
                long t1 = System.nanoTime();
                c = findClass(name);

                // this is the defining class loader; record the stats
                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                sun.misc.PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
```

双亲委派机制的好处:
Java 类随着加载它的类加载器一起具备了一种带有优先级的层次关系。比如，Java 中的 Object 类，它存放在 rt.jar之 中,无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 在各种类加载环境中都是同一个类。如果不采用双亲委派模型，那么由各个类加载器自己取加载的话，那么系统中会存在多种不同的 Object 类


* 双亲委派的破坏  
自定义的类装载器重新 loadClass 方法

### 1.2.2 链接(验证，准备，解析)

1. 验证  
主要用于保证被加载类的正确性
>1. 文件格式验证
>2. 元数据验证
>3. 字节码验证
>4. 符号引用验证

2. 准备  
为类的静态变量分配内存，并将其初始化为默认值

3. 解析  
把类中的符号引用转换为直接引用

### 1.2.3 初始化
对类的静态变量赋予真正的值，静态代码块执行初始化操作


## 1.3 JVM 中的区

当我们把类文件加载进 JVM 后, 不是直接开辟一个空间就把这个文件存储下来，而是会把这个类文件按照不同的内容存储在不同的区内的，那么都有哪些区, 都存储着些什么呢? 

![Alt '运行时数据区'](https://s3.ax1x.com/2021/01/24/sHqytJ.png)

如图:  
这个运行时数据区被分为了 5 大块
1. 方法区(Method Area)
2. 堆(Heap)
3. 虚拟机栈(Virtual Machine Stacks)
4. 本地方法栈(Native Method Stacks)
5. PC 寄存器(Program Counter Register)


* 方法区(Method Area)    
1. JVM 只有一个方法区，所有的线程共享着这个唯一的方法区，他的生命周期和 JVM 一样。

1. 它用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。

3. 方法区里有一个运行时常量池，用于存放**静态编译产生的字面量和符号引用**。该常量池
具有动态性，也就是说常量并不一定是编译时确定，运行时生成的常量也会存在这个常量
池中。

4. 方法区逻辑上是属于堆的一部分, 但是方法区中，垃圾回收比较少见，但并不是不进行 GC，这个区域的回收目标主要是针对常量池的回收和对类的卸载

5. 当方法区内存不足时，会导致 OutOfMemoryError(OOM)

* 堆(Heap)
1. JVM 只有一个堆, 同样的所有的线程共享这个堆, 他的生命周期同样和 JVM 一样

2. 堆主要存放的是类的实例和被分配的数组

3. 对是 JVM 中内存最大的一块, 也是垃圾回收管理的主要区域，堆在物理上是可以为不连续的内存空间，只要逻辑上连续即可。

4. 堆的实现是可以固定大小,也可以是动态扩展的，单堆的内存使用完了, 同样会抛出  OutOfMemoryError

* 虚拟机栈(Virtual Machine Stacks)    
1. 虚拟机栈是线程私有的，它的生命周期与线程相同

2. **虚拟机栈可以看做是 Java 方法执行的内存模型：每个方法执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息**。 一个 Java 方法从调用到执行完的过程，就对应着一个栈帧从虚拟机栈入栈到出栈的过程。

3. 局部变量表中存放了编译期可知的基本数据类型、对象引用、returnAddress类型（指向了一条字节码指令的地址）

4. 在虚拟机栈中可能会出现两种异常：StackOverflowError 和 OutOfMemory。  
如果线程请求的栈深度大于当前虚拟机所允许的深度，会抛出该异常。  
如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存，会抛出该异常

* 虚拟机栈(Native Method Stacks)  
1. 本地方法栈类似与虚拟机栈类似，它们不同之处在于，虚拟机栈是为虚拟机执行的 Java 方法服务，而本地方法栈是为虚拟机使用到的 Native 方法服务

2. 在 HotSpot 虚拟机中直接把本地方法栈和虚拟机栈合二为一

3. 同样的本地方法栈也会抛出 StackOverflowError和OutOfMemory

* PC 寄存器(Program Counter Register)  
1. 程序计数器是一块较小的内存分区，你可以把它看做当前线程所执行的字节码的指示器(类似于, 记录了线程执行到了哪个位置, 下一步的位置)。在虚拟机的概念模型里，字节码解释器工作时，就是通过改变计数器的值来选择下一条需要执行的字节码指令

2. 程序技术器为线程私有，每个线程都有它们各自的程序计数器，这样再多线程的情况下，线程之间的来回切换，也能正确找到上次切换时执行的位置

3. 如果线程正在执行的是一个 Java 方法，那么程序计数器记录的是当前线程正在执行的字节码指令的地址；如果线程正在执行的是一个 native 方法，则计数器值为空

4. 此内存区域是唯一一个Java虚拟机规范中没有规定任何 OutOfMemoryError(OOM) 情况的区域



## 1.3 转载来源
[Java代码编译过程简述](https://blog.csdn.net/fuzhongmin05/article/details/54880257)

[JVM系列——java文件到JVM中的整个过程](https://blog.csdn.net/o9109003234/article/details/105501939)