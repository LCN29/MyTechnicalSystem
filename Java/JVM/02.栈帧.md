# 02. 栈帧

虚拟机栈内部存储的是栈帧, 每调用一个方法就往栈里面押入一个栈帧，每执行完一个方法，就把这个栈帧出栈

那么，栈帧里面存储的是什么和栈帧是怎么起作用的?


## 2.1 栈帧存储的内容
通过[官网](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)的资料可以知道

栈帧存储的内容

1. 本地变量(Local Variables)
2. 操作栈(Operand Stacks)
3. 动态链接(Dynamic Linking)
4. 正常方法调用完成(Normal Method Invocation Completion)
5. 中断(异常)方法调用完成(Abrupt Method Invocation Completion)

但是他们都有什么作用呢?

## 2.2 局部变量变 和 操作数栈的作用

我们先看一个例子

```java
public class Application {

    public static void main(String[] args) throws InterruptedException {
        int add = add(1, 2);
        System.out.println(add);
    }

    public static int add(int num1, int num2) {
        num1 = 3;
        int result = num1 + num2;
        return result;
    }
}
```

先通过 `javac Application.java`
得到字节码文件, 再通过 `javap -c -l -p -v Application.class >> class.txt`

打开 class.txt 就能得到我们的字节码文件了, 内容如下
```java
Compiled from "Application.java"
public class Application {
  public Application();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]) throws java.lang.InterruptedException;
    Code:
       0: iconst_1
       1: iconst_2
       2: invokestatic  #2                  // Method add:(II)I
       5: istore_1
       6: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
       9: iload_1
      10: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V
      13: return

  public static int add(int, int);
    Code:
       0: iconst_3
       1: istore_0
       2: iload_0
       3: iload_1
       4: iadd
       5: istore_2
       6: iload_2
       7: ireturn
}
```


整理成图的话，是这样的
![Alt '操作数栈-01'](https://s3.ax1x.com/2021/01/24/sq9smj.png)


* 先看一下 add 方法的局部变量

首先我们看到 add 方法的局部变量表有三个属性, 分别是入参的 num1, num2, 还有方法内部声明的 result 变量。

补充说明: 因为这里的 add 方法是静态的, 所以入参有几个变量, 那么局部变量表就有几个。  
在实际中，如果方法是非静态的话, 局部变量变的第一个会多 1 个 this 的变量，后面才是入参。

this 的存在作用:  
在 Java 中, 实例方法是没办法直接调用的，需要通过 instance.方法 才能使用。所以调用方调用实例方法时, 会将自身传到局部变量表的 this, 通过这样达到 instance.方法。

* add 方法的操作数栈的变化

各个指令的作用可以通过查看官网得知: [地址](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5)


add 方法  
1. 第一个指令 iconst_3, 把一个 int 的数字放入到操作栈，这里的 iconst_3, 代表的时把 3 放入到操作栈(注意这里的 iconst_? 只能表示到 5, 超过 5 后的指令会变成 bipush 数字)

这时候的操作数栈是这样的  
![Alt '操作数栈-02'](https://s3.ax1x.com/2021/01/24/sqPcWV.png)

2. 第二个指令 istore_0, 把操作数栈, 最上面的数字(必须是 int) 出栈，并覆盖局部变量表第 0 的位置

这时候的操作数栈是这样的  
![Alt '操作数栈-03'](https://s3.ax1x.com/2021/01/24/sqP4eJ.png)

通过查看局部变量表的变化，我们可以知道 `num1 = 3` 在程序中是分成了 2 个指令完成的

3. 第三个指令 iload_0, 把第 0 个局部变量的值放入栈帧(这个值必须是 int 类型)    
第四个命令为 iload_1, 那么就是把第 1 个局部变量放入到栈帧

经过第三，四个指令后，这时候的操作数栈是这样的  
![Alt '操作数栈-04'](https://s3.ax1x.com/2021/01/24/sqi01K.png)

4. 第五个指令 iadd, 把栈帧中的头 2 个 int 操作数弹出来, 进行相加，然后再把结果入栈。

经过第五个指令后，这时候的操作数栈是这样的
![Alt '操作数栈-05'](https://s3.ax1x.com/2021/01/24/sqFVgK.png)

后面的六，七 就省略了

ireturn 从纸面上就能里面了吧，从方把操作数栈中的栈顶(一个 int 的数字)返回出去。

## 2.3 正常方法调用完成 和 中断(异常)方法调用完成

一个方法开始执行后，只有**两种方式可以退出这个方法**  
1. 遇到任意一个方法返回的字节码指令(ireturn, dreturn, areturn 之类的), 也就是代码里面的 return, 这时候可能会有返回值传递给上层的方法调用者, 是否有返回值和返回值的类型会由方法返回指令来决定，这种退出方法的方式称为**正常方法调用完成**  
2. 在方法执行过程中遇到了异常(JVM 内部抛出来的异常，手动 throw 的异常)，并且这个异常没有在方法体内得到处理(try, catch), 只要在本方法的异常表(方法内部还有一个异常表，表里面存放的是方法中主动捕获的异常列表，也就是我们说的 catch 掉的异常)中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为**中断(异常)方法调用完成**

当方法返回时，**可能进行3个操作**
1. 恢复上层方法的局部变量表和操作数栈  
2. 把返回值压入调用者调用者栈帧的操作数栈
3. 调整 PC 计数器的值以指向方法调用指令后面的一条指令

这样恢复当前调用方法的方法的栈帧, 同时调整 PC 计算器，让方法能继续执行下去

## 2.4 动态链接
这个有点绕，先上一下官网原文

```
原文:

Each frame contains a reference to the run-time constant pool for the type of the current method to support dynamic linking of the method code. The class file code for a method refers to methods to be invoked and variables to be accessed via symbolic references. Dynamic linking translates these symbolic method references into concrete method references, loading classes as necessary to resolve as-yet-undefined symbols, and translates variable accesses into appropriate offsets in storage structures associated with the run-time location of these variables.

This late binding of the methods and variables makes changes in other classes that a method uses less likely to break this code.

翻译:

每个栈帧都包含一个指向当前方法类型的运行时常量池的引用，用于支持方法调用过程中的动态连接。Class 文件代码中包含了通过符号引用来表示将要被调用的方法和将要被访问的常量。动态链接就是将这些符号方法引用转变为具体的方法引用，并加载必须的类来解析那些尚未被定义的符号，并根据变量在运行时的位置，将这些变量引用转变为存储结构中的适当偏移量。

这种方法和变量的后期绑定的使用很有用，使得方法使用的其他类的变更对代码的破坏很小
```