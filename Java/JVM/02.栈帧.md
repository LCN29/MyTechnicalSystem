# 02. 栈帧

虚拟机栈内部存储的是栈帧, 每调用一个方法就往栈里面押入一个栈帧，每执行完一个方法，就把这个栈帧出栈

那么，栈帧里面存储的是什么和栈帧是怎么起作用的?


## 2.1 栈帧存储的内容
通过[官网](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)的资料可以知道

栈帧存储的内容

1. 本地变量(Local Variables)
2. 操作栈(Operand Stacks)
3. 动态链接(Dynamic Linking)
4. 正常方法调用完成(Normal Method Invocation Completion)
5. 中断(异常)方法调用完成(Abrupt Method Invocation Completion)

但是他们都有什么作用呢?

## 2.2 局部变量变和操作数栈的作用

我们先看一个例子

```java
public class Application {

    public static void main(String[] args) throws InterruptedException {
        int add = add(1, 2);
        System.out.println(add);
    }

    public static int add(int num1, int num2) {
        num1 = 3;
        int result = num1 + num2;
        return result;
    }
}
```

先通过 `javac Application.java`
得到字节码文件, 再通过 `javap -c -l -p -v Application.class >> class.txt`

打开 class.txt 就能得到我们的字节码文件了, 内容如下
```java
Compiled from "Application.java"
public class Application {
  public Application();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]) throws java.lang.InterruptedException;
    Code:
       0: iconst_1
       1: iconst_2
       2: invokestatic  #2                  // Method add:(II)I
       5: istore_1
       6: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
       9: iload_1
      10: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V
      13: return

  public static int add(int, int);
    Code:
       0: iconst_3
       1: istore_0
       2: iload_0
       3: iload_1
       4: iadd
       5: istore_2
       6: iload_2
       7: ireturn
}
```


整理成图的话，是这样的
![Alt '操作数栈-01'](https://s3.ax1x.com/2021/01/24/sq9smj.png)


* 先看一下 add 方法的局部变量

首先我们看到 add 方法的局部变量表有三个属性, 分别是入参的 num1, num2, 还有方法内部声明的 result 变量。

补充说明: 因为这里的 add 方法是静态的, 所以入参有几个变量, 那么局部变量表就有几个。  
在实际中，如果方法是非静态的话, 局部变量变的第一个会多 1 个 this 的变量，后面才是入参。

this 的存在作用:  
在 Java 中, 实例方法是没办法直接调用的，需要通过 instance.方法 才能使用。所以调用方调用实例方法时, 会将自身传到局部变量表的 this, 通过这样达到 instance.方法。

* add 方法的操作数栈的变化

各个指令的作用可以通过查看官网得知: [地址](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5)


add 方法  
1. 第一个指令 iconst_3, 把一个 int 的数字放入到操作栈，这里的 iconst_3, 代表的时把 3 放入到操作栈(注意这里的 iconst_? 只能表示到 5, 超过 5 后的指令会变成 bipush 数字)

这时候的操作数栈是这样的  
![Alt '操作数栈-02'](https://s3.ax1x.com/2021/01/24/sqPcWV.png)

2. 第二个指令 istore_0, 把操作数栈, 最上面的数字(必须是 int) 出栈，并覆盖局部变量表第 0 的位置

这时候的操作数栈是这样的  
![Alt '操作数栈-03'](https://s3.ax1x.com/2021/01/24/sqP4eJ.png)

通过查看局部变量表的变化，我们可以知道 `num1 = 3` 在程序中是分成了 2 个指令完成的

3. 第三个指令 iload_0, 把第 0 个局部变量的值放入栈帧(这个值必须是 int 类型)    
第四个命令为 iload_1, 那么就是把第 1 个局部变量放入到栈帧

经过第三，四个指令后，这时候的操作数栈是这样的  
![Alt '操作数栈-04'](https://s3.ax1x.com/2021/01/24/sqi01K.png)

4. 第五个指令 iadd, 把栈帧中的头 2 个 int 操作数弹出来, 进行相加，然后再把结果入栈。

经过第五个指令后，这时候的操作数栈是这样的
![Alt '操作数栈-05'](https://s3.ax1x.com/2021/01/24/sqFVgK.png)

后面的六，七 就省略了

ireturn 从纸面上就能里面了吧，从方把操作数栈中的栈顶(一个 int 的数字)返回出去。

## 2.3 

// 22