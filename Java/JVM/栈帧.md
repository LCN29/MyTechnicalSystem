# 02. 栈帧

虚拟机栈内部存储的是栈帧, 每调用一个方法就往栈里面押入一个栈帧，每执行完一个方法，就把这个栈帧出栈

那么，栈帧里面存储的是什么和栈帧是怎么起作用的?

## 2.1 栈帧存储的内容
通过[官网](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)的资料可以知道

和栈帧相关的内容有

1. 本地变量(Local Variables)
2. 操作栈(Operand Stacks)
3. 动态链接(Dynamic Linking)
4. 正常方法调用完成(Normal Method Invocation Completion)
5. 中断(异常)方法调用完成(Abrupt Method Invocation Completion)

但是他们都有什么作用呢?

## 2.2 局部变量变 和 操作数栈的作用

我们先看一个例子

```java
public class Application {

    public static void main(String[] args) throws InterruptedException {
        int add = add(1, 2);
        System.out.println(add);
    }

    public static int add(int num1, int num2) {
        num1 = 3;
        int result = num1 + num2;
        return result;
    }
}
```

先通过 `javac Application.java`
得到字节码文件, 再通过 `javap -c -l -p -v Application.class >> class.txt`

打开 class.txt 就能得到我们的字节码文件了, 内容如下
```java
Compiled from "Application.java"
public class Application {
  public Application();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]) throws java.lang.InterruptedException;
    Code:
       0: iconst_1
       1: iconst_2
       2: invokestatic  #2                  // Method add:(II)I
       5: istore_1
       6: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
       9: iload_1
      10: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V
      13: return

  public static int add(int, int);
    Code:
       0: iconst_3
       1: istore_0
       2: iload_0
       3: iload_1
       4: iadd
       5: istore_2
       6: iload_2
       7: ireturn
}
```

整理成图的话，是这样的
![Alt '操作数栈-01'](https://s3.ax1x.com/2021/01/24/sq9smj.png)


* 先看一下 add 方法的局部变量

首先我们看到 add 方法的局部变量表有三个属性, 分别是入参的 num1, num2, 还有方法内部声明的 result 变量。

补充说明: 因为这里的 add 方法是静态的, 所以入参有几个变量, 那么局部变量表就有几个。  
在实际中，如果方法是非静态的话, 局部变量变的第一个会多 1 个 this 的变量，后面才是入参。

this 的存在作用:  
在 Java 中, 实例方法是没办法直接调用的，需要通过 instance.方法 才能使用。所以调用方调用实例方法时, 会将自身传到局部变量表的 this, 通过这样达到 instance.方法。

* add 方法的操作数栈的变化

各个指令的作用可以通过查看官网得知: [地址](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5)

add 方法  

1. 第一个指令 iconst_3, 把一个 int 的数字放入到操作栈，这里的 iconst_3, 代表的时把 3 放入到操作栈(注意这里的 iconst_? 只能表示到 5, 超过 5 后的指令会变成 bipush 数字)

这时候的操作数栈是这样的  
![Alt '操作数栈-02'](https://s3.ax1x.com/2021/01/24/sqPcWV.png)

2. 第二个指令 istore_0, 把操作数栈, 最上面的数字(必须是 int) 出栈，并覆盖局部变量表第 0 的位置

这时候的操作数栈是这样的  
![Alt '操作数栈-03'](https://s3.ax1x.com/2021/01/24/sqP4eJ.png)

通过查看局部变量表的变化，我们可以知道 `num1 = 3` 在程序中是分成了 2 个指令完成的

3. 第三个指令 iload_0, 把第 0 个局部变量的值放入栈帧(这个值必须是 int 类型)    
第四个命令为 iload_1, 那么就是把第 1 个局部变量放入到栈帧

经过第三，四个指令后，这时候的操作数栈是这样的  
![Alt '操作数栈-04'](https://s3.ax1x.com/2021/01/24/sqi01K.png)

4. 第五个指令 iadd, 把栈帧中的头 2 个 int 操作数弹出来, 进行相加，然后再把结果入栈。

经过第五个指令后，这时候的操作数栈是这样的
![Alt '操作数栈-05'](https://s3.ax1x.com/2021/01/24/sqFVgK.png)

后面的六，七 就省略了

ireturn 从纸面上就能里面了吧，把操作数栈中的栈顶(一个 int 的数字)返回出去。

从上面的内容, 可以知道，操作数栈用于方法执行过程的流转, 局部变量表则用于存储临时的变量数据

## 2.3 正常方法调用完成 和 中断(异常)方法调用完成

一个方法开始执行后，只有**两种方式可以退出这个方法**  
1. 遇到任意一个方法返回的字节码指令(ireturn, dreturn, areturn 之类的), 也就是代码里面的 return, 这时候可能会有返回值传递给上层的方法调用者, 是否有返回值和返回值的类型会由方法返回指令来决定，这种退出方法的方式称为**正常方法调用完成**  
2. 在方法执行过程中遇到了异常(JVM 内部抛出来的异常，手动 throw 的异常)，并且这个异常没有在方法体内得到处理(try, catch), 只要在本方法的异常表(方法内部还有一个异常表，表里面存放的是方法中主动捕获的异常列表，也就是我们说的 catch 掉的异常)中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为**中断(异常)方法调用完成**

当方法返回时，**可能进行3个操作**
1. 恢复上层方法的局部变量表和操作数栈  
2. 把返回值压入调用者调用者栈帧的操作数栈
3. 调整 PC 计数器的值以指向方法调用指令后面的一条指令

这样恢复当前调用方法的方法的栈帧, 同时调整 PC 计算器，让方法能继续执行下去

总的概况下来, 2 个都是的作用就是标识当前方法执行结束, 回到调用方, 如果有返回值的话，给调用方返回值

## 2.4 动态链接
这个有点绕，先上一下官网原文


```
原文:

Each frame contains a reference to the run-time constant pool for the type of the current method to support dynamic linking of the method code. The class file code for a method refers to methods to be invoked and variables to be accessed via symbolic references. Dynamic linking translates these symbolic method references into concrete method references, loading classes as necessary to resolve as-yet-undefined symbols, and translates variable accesses into appropriate offsets in storage structures associated with the run-time location of these variables.

This late binding of the methods and variables makes changes in other classes that a method uses less likely to break this code.

翻译:

每个栈帧都包含一个属于当前所属方法的指向的运行时常量池的引用，用于支持方法调用过程中的动态连接。Class 文件代码中包含了通过符号引用来表示将要被调用的方法和将要被访问的常量。动态链接就是将这些符号方法引用转变为具体的方法引用，并加载必须的类来解析那些尚未被定义的符号，并根据变量在运行时的位置，将这些变量引用转变为存储结构中的适当偏移量。

这种方法和变量的后期绑定的使用很有用，使得方法使用的其他类的变更对代码的破坏很小。
```

这一段话里面包含了很多东西, 我们一步步的整理。

1. 什么是符号引用

假设我们有一个类文件
```java
public class SymbolicReference {

    public void fn1() {
        fn2();
    }

    public void fn2() {

    }
}
```
将其编译为字节码后的内容如下
```
Classfile /Users/test/src/main/java/SymbolicReference.class
  Last modified 2021-1-31; size 316 bytes
  MD5 checksum e97c5362ae57c81ebd30969786434e2b
  Compiled from "SymbolicReference.java"
public class SymbolicReference
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #4.#13         // java/lang/Object."<init>":()V
   #2 = Methodref          #3.#14         // SymbolicReference.fn2:()V
   #3 = Class              #15            // SymbolicReference
   #4 = Class              #16            // java/lang/Object
   #5 = Utf8               <init>
   #6 = Utf8               ()V
   #7 = Utf8               Code
   #8 = Utf8               LineNumberTable
   #9 = Utf8               fn1
  #10 = Utf8               fn2
  #11 = Utf8               SourceFile
  #12 = Utf8               SymbolicReference.java
  #13 = NameAndType        #5:#6          // "<init>":()V
  #14 = NameAndType        #10:#6         // fn2:()V
  #15 = Utf8               SymbolicReference
  #16 = Utf8               java/lang/Object
{
  public SymbolicReference();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 9: 0

  public void fn1();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokevirtual #2                  // Method fn2:()V
         4: return
      LineNumberTable:
        line 12: 0
        line 13: 4

  public void fn2();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=0, locals=1, args_size=1
         0: return
      LineNumberTable:
        line 17: 0
}
SourceFile: "SymbolicReference.java"
```

可以看到 Class 文件里有一段叫做“常量池”，里面存储的该 Class 文件里的大部分常量的内容。

我们看一下 fn1 方法所在的地方, 里面有一段
```
1: invokevirtual #2                  // Method fn2:()V
```
里面的 1: 当前指令的位置, 而 invokevirtual 这是操作栈里面的指令, 表示调用一个**虚方法**(这里你可以简单的理解为调用一个方法), 调用的是什么方法呢? 这就是后面的 #数字的内容了, 他指向的就是我们 class 内部自己的常量池内容的, 通过 #2 我们到常量池的 2 号项，看到的是

```
#2 = Methodref          #3.#14
```

同样的后面的 #3 #14 分别指向的也是常量池的下标, 顺着这条路, 我们整理后会得到下面的常量项
```
#2  = Methodref          #3.#14

#3  = Class              #15
#15 = Utf8               SymbolicReference

#14 = NameAndType        #10:#6
#10 = Utf8               fn2
#6  = Utf8               ()V
```

里面的 Utf8 表示的是 UTF-8 编码的字符串。

由此可以看出， Class 文件中的 invokevirtual 指令，调用的方法，经过几次常量池的转换，最后都是由字符串表示的，
就如上面的 **SymbolicReference.fn2:()V**, 这个字符串就是 **符号引用**。


2. 什么是直接引用  

这里的内容涉及很多底层的东西，我也不是百分百了解，就讲解我了解的部分。

我们的 class 文件加载到 JVM 中时，
1. 会将我们的 class 文件里面的内容加载到我们的方法区中, 这个在方法区里面的对象和内容和我们看到的 class 文件字节码的内容类似的. (备注: 听说这个对象内部会持有一个 cache 对象, 是为了编译器运行更快的缓存对象)

2. 同时在堆空间里面创建一个对应的 Class 对象, 这个对象有个引用指向了方法区中真正的 Class 对象结构。

3. 当一个类被加载到 JVM 时，Class 文件里的常量池和每个方法的字节码（Code 属性）会被基本原样的拷贝到内存里先放着，也就是说仍然处于使用“符号引用”的状态; 直到真的要被使用到的时候才会被解析（resolve）为直接引用。


假设我们执行到了 fn1 调用 fn2 的地方，既 `invokevirtual #2` 的地方, 此时 JVM 会发现该指令尚未被解析（resolve），所以会先去解析一下。

>1. 通过到 #2 找到到常量池对应的地方, 发现该常量池项也尚未被解析 (resolve), 于是进一步操作
>2. 通过我们的 Utf8 字符串, 既**符号引用**，将对应的类加载进来,到类的方法列表中, 找到我们需要的方法块
>3. 将这个方法块的指针替换掉常量池的 #2 的位置。这样，以后再查询到常量池项 #2 时，里面就不再是一个符号引用, 而是一个能直接找到 Java 方法元数据的方法块了。这里的方法块指针就是一个直接引用。
>4. 解析好常量池项 #2 之后, 得到调用的方法块的直接引用, 继续回到 invokevirtual 指令, 进行另一个方法的调用。

备注: 在早期的 JVM 的实现中, 存在一些已经解析成功的指令进行替换的操作, 让其执行更快的操作。当前我们的指令解析成功后，每次执行还是需要到常量池找到对应执行方法的指针。而在早期, **invokevirtual #2** 指令会修改为 **invokevirtual_quick vtable_index=6, args_size=1**, 其中**invokevirtual_quick**表示这里已经解析完成了, **vtable_index=6** 虚方法表的第 6 的位置(虚方法表可以看成是当前加载到 JVM 中每个类的方法列表表格, 6 代表第 7 行的内容), **args_size=1** 入参的个数 1个(这里的应该就是当前对象的 this)。 

上面就是把符号引用转变为直接引用, 既动态连接的作用。

