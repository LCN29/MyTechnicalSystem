# 05.对象回收判断算法

在 JVM 中, 如果一个对象不被任何对象所引用的话, 那么这个对象就是可回收对象。

那么如何判断一个对象是可回收的话, 现在常用的有 2 种方式。

## 1. 引用计数算法 (Reference Counting)

在对象中添加一个引用计数器, 每当有一个地方引用它时, 计数器值就加一。当引用失效时, 计数器值就减一。任何时刻计数器为零的对象就是不可能再被使用的, 可以判定为可以回收的对象。

优点: 实现简单, 判定的效率也很高  
缺点: 需要占用一下额外的内存空间, 很多复杂的情景没有考虑, 很难解决对象之间相互循环引用的问题。

```java
Obj a = new Obj();
Obj b = new Obj();

a.attr = b;
b.attr = a;
```
上面 2 个对象没有作用了, 但是互相持有对方的引用, 导致他们的引用计数不为 0, 无法回收。

在主流的 Java 虚拟机中没有选用引用计数法作用内存管理的方式。

## 2. 可达性分析算法 (Reachability Analysis)

设定一系列称为 "GC Roots" 的根对象作为起始节点集, 从这些节点开始, 根据引用关系向下搜索, 搜索过程所走过的路径称为 "引用链" （Reference Chain), 如果某个对象到 GC Roots 间没有任何引用链相连, 则证明此对象是不可能再被使用。

![Alt 'JvmRuntimeDataArea'](https://raw.githubusercontent.com/PictureRespository/Java/main/JVM/ReachabilityAnalysis.png)


如图: obj1, obj2, obj3 顺着链路, 可以达到 GC Root, 所以属于不可回收对象, 而 obj4, obj5, obj6 之间虽然有引用关系, 但是没有达到 GC Root 的链路, 所以为可回收对象。

在 Java 中, 固定可作为 GC Roots 的对象有  
1. 在虚拟机栈 (栈帧中的本地局部变量表) 中引用的对象, 比如线程调用的方法堆栈中使用到的参数, 局部变量, 临时变量等

2. 在本地方法栈中 JNI（即通常所说的 Native 方法）引用的对象

3. 在方法区中类静态属性引用的对象, 比如 Java 类的引用类型静态变量

4. 在方法区中常量引用的对象, 比如字符串常量池 (String Table) 里的引用

5. Java 虚拟机内部的引用, 如基本数据类型对应的 Class 对象, 一些常驻的异常对象 (比如 NullPointException, OutOfMemoryError）等, 还有系统类加载器


其他的分类

1. 当前活跃线程的栈桢里指向堆中对象的引用，即当前所有正在被调用方法的引用类型参数、局部变量等

2. 类的引用类型静态变量，这里指的是引用类型，像 int 等基本数据类型的静态变量肯定不能作为 GC Roots

3. 当前所有已被加载的Java类和类加载器

4. JNI 句柄，包括 JNI Local Handles 和 JNI Global Handles

5. 在方法区中常量引用的对象，譬如字符串常量池 (String Table ) 里的引用

6. 所有被同步锁 (synchronized关键字) 持有的对象引用

## 3. 可达性分析算法的大体步骤

大体分为 2 步:
1. 根节点枚举 (GC Roots Enumeration)
2. 引用链查询标记

### 3.1 根节点枚举 

从上面列举的可作为 GC Roots 的对象列表可知, 可以作为 GC Roots 的主要在全局性的引用 (例如常量或类静态属性) 与执行上下文 (例如 栈帧中的本地变量表) 中, 尽管目标明确。但是在程序实际运行中, 真正的 GC Roots 集合会随着程序的运行变更的。所以整个可达性分析的过程, 第一步就是先确定哪些对象的是 GC  Roots, 也就是根节点枚举 (有了GC Roots 就能通过引用链查找可回收对象了)。

注: 现在所有的收集器, 在 GC Roots 这一步骤时都是必须暂停用户线程的, 也就是 “Stop the world”。而耗时更长的查找引用链的过程已经可以做到与用户线程一起并发。

根节点枚举期间要求在一个能保障一致性的快照中才得以进行, 这里的一致性指定是: 在分析过程, 根节点集合的对象引用关系不会发生变化, 所以需要暂停所有的线程。

在根节点枚举的过程, 如果一个个的遍历所有符合条件的对象, 将是一个耗时的过程。 现在主流的 Java 虚拟机使用了一组称为 OopMap 的数据结构来达到优化查找的过程, 避免一个不漏的检查所有的的对象。 通过扫描 OopMap, 存储的引用类型的指针, 也就是 GC Roots 集合, 就能通过引用链找到存活的对象。

### 3.2 OopMap 是怎么样工作的

在 HotSpot 中, 对象的类型信息里有记录自己的 OopMap, 记录了在该类型的对象内什么偏移量上是什么类型的数据, 这些数据是在类加载过程中计算得到的, 所以从对象开始向外的扫描可以是准确的。  

所以, 方法区内的静态属性引用, 常量, 这些不太会改变的 GC Roots 会在类加载成功后, 就确定好了。

对于方法栈的 GC Roots 的话，则是这样的:  
每个被 JIT 编译过后的方法会在一些**特定的位置**更新这个方法栈帧的 OopMap。 记录执行到这个位置时, 方法栈上和寄存器里哪些位置是引用。


### 3.2 安全点 (safepoint)

上面说的**特定的位置**主要在：
1. 循环的末尾
2. 方法临返回前 
3. 调用方法的 call 指令后面
4. 可能抛异常的位置

这种位置被称为 “安全点”（safepoint)。 之所以要选择一些特定的位置来记录 OopMap, 是因为如果对每条指令(的位置)都记录 OopMap 的话，这些记录就会比较大, 那么空间开销会显得不值得。选用一些比较关键的位置来记录就能有效的缩小需要记录的数据量, 但仍然能达到区分引用的目的。 因为这样, HotSpot 中 GC 不是在任意位置都可以进入, 而只能在safepoint 处进入。

对 Java 线程中的 JNI 方法, 它们既不是由 JVM 里的解释器执行的, 也不是由 JVM 的 JIT 编译器生成的, 所以会缺少OopMap 信息。那么GC碰到这样的栈帧该如何维持准确性呢？

HotSpot 的解决方法是: 所有经过 JNI 调用边界（调用 JNI 方法传入的参数, 从 JNI 方法传回的返回值）的引用都必须用 "句柄"（handle）包装起来。JNI 需要调用 Java API 的时候也必须自己用句柄包装指针。在这种实现中，JNI 方法里写的 "jobject" 实际上不是直接指向对象的指针, 而是先指向一个句柄, 通过句柄才能间接访问到对象。这样在扫描到 JNI 方法的时候就不需要扫描它的栈帧了 —— 只要扫描句柄表就可以得到所有从 JNI 方法能访问到的 GC 堆里的对象。
但这也就意味着调用 JNI 方法会有句柄的包装/拆包装的开销，是导致 JNI 方法的调用比较慢的原因之一。

平时这些OopMap都是压缩了存在内存里的, 在GC的时候才按需解压出来使用。

安全点的选定标准
1. 不能太少以至于让收集器等待时间过长
2. 不能太过频繁以至于过分增大运行时的内存负荷

对于安全点, 另外一个需要考虑的问题是, 如何在垃圾收集发生时让所有线程 (这里其实不包括 执行JNI调用的线程) 都跑到最近的安全点, 然后停顿下来。

这里有两种方案可供选择: 抢先式中断 (Preemptive Suspension) 和主动式中断（Voluntary Suspension）。

抢先式中断不需要线程的执行代码主动去配合, 在垃圾收集发生时, 系统首先把所有用户线程全部中断, 如果发现有用户线程中断的地方不在安全点上, 就恢复这条线程执行, 让它一会再重新中断, 直到跑到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程响应 GC 事件

主动式中断的思想是当垃圾收集需要中断线程的时候, 不直接对线程操作, 仅仅简单地设置一个标志位, 各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。