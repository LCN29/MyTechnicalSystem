# 02. Java 实例对象内存布局

我们知道 JVM 中堆存放的是对象, 但是这些对象在内存中是怎么样分配的呢?

在 HotSpot 虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头 (Object Header), 实例数据 (Instance Data) 和对齐填充 (Padding) 。  
如图:
![Alt 'JavaInstanceMemoryLayout'](https://raw.githubusercontent.com/PictureRespository/Java/main/JVM/JavaInstanceMemoryLayout.png)

## 对象头（Object Header）
Java 实例的对象头主要包含 2/3 个部分, 如果是对象的话, 只包含 2 部分 Mark Word 和 Class Pointer, 如果是对象的话, 还会多一个 Array Length。

**Mark Word**: 用于存储对象自身的运行时数据, 如哈希码（HashCode）, GC分代年龄, 锁状态标志, 线程持有的锁, 偏向线程ID, 偏向时间戳等。
这一部分在 32 位系统里面的大小为 4 个字节, 而 64 位系统里面则为 8 个字节。

**Klass Pointer**: 类型指针, 即对象指向它的类型元数据的指针, Java 虚拟机通过这个指针来确定该对象是哪个类的实例 (并不是所有的虚拟机实现都必须在对象数据上保留类型指针,
也就是, 查找对象的元数据信息并不一定要经过对象本身)。 这一部分在 32 位系统里面的大小为 4 个字节, 而 64 位系统里面则为 8 个字节。

**Length**: 当我们的对象实例是数组对象的话, 对象头里面还会有一个用于记录数组长度的数据, 大小为 4 个字节, 主要用于确定对象的大小。因为普通的 Java 对象可以通过
元数据推算出对象的大小, 但是数组的长度不确定时, 无法推算出数组的大小。

在 32 位系统中, HotSpot 里面的 Mark Work 正常情况(无锁状态)的分布如下:

![Alt 'MarkWorkContentInNoLock'](https://raw.githubusercontent.com/PictureRespository/Java/main/JVM/MarkWorkContentInNoLockWhen32bSystem.png)

64 位系统的话, 如图:
![Alt 'MarkWorkContentInNoLock'](https://raw.githubusercontent.com/PictureRespository/Java/main/JVM/MarkWorkContentInNoLockWhen64bSystem.png)

Mark Work 的内容不是一成不变的, 如果对象被当做 synchronized 锁的话, 其内部的内容会随锁的状态变更。

对象头一般情况下的大小:

32 位系统下: Class Pointer 4 个字节, MarkWord 4 个字节, 对象头为 8 个字节, 如果是数组的话, 再加上 4 个字节的数组长度。   
64 位系统下: Class Pointer 8 个字节, MarkWord 8 个字节, 对象头为 16 个字节, 如果是数组的话, 再加上 4 个字节的数组长度。

Java 中还有一项技术会影响到对象头的大小: **指针压缩技术**。

在 64 位的 HotSpot 的虚拟机, 开启了指针压缩技术, 会对对象的


Class Pointer 的大小会变为 32 位, 如果是数组的话,

## 实例数据（Instance Data）

对象真正有效的信息，也就是我们类中声明的各个字段（包括从父类继承下来的）, 每个字段都有自己的大小限制。

| 字段类型               | 内存大小(单位: 字节) |
| :-:                   | :-:               |
| boolean               |        1          |
| byte                  |        1          |
| short                 |        2          |
| char                  |        2          |
| int                   |        4          |
| float                 |        4          |
| long                  |        8          |
| double                |        8          |
| reference(引用类型)    |   4(32位系统), 8(64位系统) |

通过上面的大小的字段类型的, 基本可以确定每个对象的实际数据大小。(静态属性不算在对象大小里面)

## 对齐填充 (Padding)

这个不是必须，也没有具体的含义，只是单纯的起占位作用。他的出现与否取决于当前对象实例的内存大小。
所以的 Java 对象所占用的字节数必须是 8 的倍数。比如 一个对象的对象头的大小为 12 byte, 实例数据为 13 byte。
当前对象所占的大小为 25 byte。但是 JVM 要求每个对象的大小必须是 8 的倍数, 这时候 padding 就其作用了, 填充 7 个字节, 凑够 32, 
达到 8 的倍数。当对象头和实例数据刚好达到 8 的倍数, 这时候就不需要 padding 了。



