# 10. JVM 执行引擎

执行引擎是 Java 虚拟机核心的组成部分之一。在《Java虚拟机规范》中制定了 Java 虚拟机字节码执行引擎的概念模型, 这个概念模型成为各大发 行商的 
Java 虚拟机执行引擎的统一外观 (Facade)。不同的虚拟机的实现中, 通常会有解释执行 (通过解释器执行) 和编译执行 (通过即时编译器产生本地代码执行) 
两种选择, 也可能两者兼备, 还可能会有同时包含几个不同级别的即时编译器一起工作的执行引擎。但是从外观上看, 所有的 Java 虚拟机的执行引擎都是: 输
入的是字节码二进制流, 输出的是执行结果。

## 10.1 运行时栈帧

Java 虚拟机以方法作为最基本的执行单元, "栈帧" (Stack Frame) 则是用于支持虚拟机进行方法调用和方法执行背后的数据结构, 它也是虚拟机运行时数
据区中的虚拟机栈 (Virtual Machine Stack) 的栈元素。栈帧存储了方法的局部变量表 / 操作数栈 / 动态连接和方法返回地址等信息。每一个方法从调
用开始至执行结束的过程, 都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。

每一个栈帧都包括了局部变量表, 操作数栈, 动态连接, 方法返回地址和一些额外的附加信息。  
在编译 Java 程序源码的时候, 栈帧中需要多大的局部变量表, 需要多深的操作数栈就已经被分析计算出来, 并且写入到方法表的 Code 属性之中。  
一个栈帧需要分配多少内存, 并不会受到程序运行期变量数据的影响, 而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式。

一个线程中的方法调用链可能会很长, 以 Java 程序的角度来看, 同一时刻, 同一条线程里面, 在调用堆栈的所有方法都同时处于执行状态。而对于执行引擎
来讲, 在活动线程中, 只有位于栈顶的方法才是在运行的, 只有位于栈顶的栈帧才是生效的, 其被称为 "当前栈帧" (Current Stack Frame), 与这个栈帧
所关联的方法被称为 "当前方法" (Current Method)

综上, 栈帧的结构如下:  
![Alt 'ConstructionOfStackFrame'](https://raw.githubusercontent.com/PictureRespository/Java/main/JVM/ConstructionOfStackFrame.png)

### 10.1.1 局部变量表 - Local Variables Table

局部变量表是一组变量值的存储空间, 用于存放方法参数和方法内部定义的局部变量。在 Java 程序被编译为 Class 文件时, 就在方法的 Code 属性的 
max_locals 数据项中确定了该方法所需分配的局部变量表的最大容量。

局部变量表的容量以变量槽 (Variable Slot) 为最小单位。1 个槽的具体大小, 《Java虚拟机规范》中并没有明确指出, 但是引导性地说明了 boolean 
/ byte / char / short / int / float / reference / returnAddress 类型的数据, 这 8 种数据类型, 都可以使用 32 位或更小的物理内存来存储。

reference 类型表示对一个对象实例的引用, 《Java虚拟机规范》既没有说明它的长度, 也没有明确指出这种引用应有怎样的结构。但是需要能通过这个引
用做到两件事情: 一是从根据引用直接或间接地查找到对象在 Java 堆中的数据存放的起始地址或索引, 二是根据引用直接或间接地查找到对象所属数据类型在
方法区中的存储的类型信息。

returnAddress 类型模板以及很少见了, 它是为字节码指令 jsr, jsr_w 和 ret 服务的, 指向了一条字节码指令的地址, 某些很古老的 Java 虚拟机曾
经使用这几条指令来实现异常处理时的跳转, 但现在也已经全部改为采用异常表来代替了。

对于 64 位的数据类型, Java 虚拟机会以高位对齐的方式为其分配两个连续的变量槽空间。Java 语言中明确的 64 位的数据类型只有 long 和 double 两种。
Java 虚拟机通过索引定位的方式使用局部变量表, 索引值的范围是从 0 开始至局部变量表最大的变量槽数量。如果访问的是 32 位数据类型的变量, 索引 N 
就代表了使用第 N 个变量槽, 如果访问的是 64 位数据类型的变量, 则说明会同时使用第 N 和 N + 1 两个变量槽。 对于两个相邻的共同存放一个 64 位数
据的两个变量槽, 虚拟机不允许采用任何方式单独访问其中的某一个。

当一个方法被调用时, Java 虚拟机会使用局部变量表来完成参数值到参数变量列表的传递过程, 即实参到形参的传递。 如果执行的是实例方法 (没有被 static 
修饰的方法), 那局部变量表中第 0 位索引的变量槽默认是用于传递方法所属对象实例的引用, 在方法中可以通过关键字 "this" 来访问到这个隐含的参数。
其余参数则按照参数表顺序排列, 占用从 1 开始的局部变量槽, 参数表分配完毕后, 再根据方法体内部定义的变量顺序和作用域分配其余的变量槽。

为了尽可能节省栈帧耗用的内存空间, 局部变量表中的变量槽是可以重用的, 方法体中定义的变量, 其作用域并不一定会覆盖整个方法体, 如果当前字节码 PC 
计数器的值已经超出了某个变量的作用域, 那这个变量对应的变量槽就可以交给其他变量来重用。 不过, 这样的设计除了节省栈帧空间以外, 还会伴随有少量
额外的副作用, 例如在某些情况下变量槽的复用会直接影响到系统的垃圾收集行为

注: 在虚拟机运行参数中加上 "-verbose:gc" 来看看垃圾收集的过程。 

```java
public static void main(String[] args)() { 
    byte[] placeholder = new byte[64 * 1024 * 1024]; 
    System.gc(); 
}
```

输出结果:
```
[GC (System.gc())  76402K->67232K(188416K), 0.0062015 secs]
[Full GC (System.gc())  67232K->67164K(188416K), 0.0253018 secs]
```

发现在 System.gc() 运行后并没有回收掉这 64MB 的内存, 因为在执行 System.gc() 时, 变量 placeholder 还处于作用域之内, 虚拟机自然不敢回收掉 placeholder 的内存。

修改一下代码
```java
public static void main(String[] args)() {

	if (1 == 1) {
    	byte[] placeholder = new byte[64 * 1024 * 1024];
    }
	System.gc(); 
}

```

输出结果:
```
[GC (System.gc())  76402K->67232K(188416K), 0.0062015 secs]
[Full GC (System.gc())  67232K->67164K(188416K), 0.0253018 secs]
```

在 if 判断结束后, placeholder 的作用域被限制在花括号以内, 从代码逻辑上讲, 在执行 System.gc() 的时候, placeholder 已经不可能再被访问了, 但执行这段程序 gc 后, 64MB 的内存还是没释放

再做一下修改

```java
public static void main(String[] args) {
    if (1 == 1) {
        byte[] placeholder = new byte[64 * 1024 * 1024];
    }
    int a = 12;
    System.gc();
}
```

这次的输出结果:
```
[GC (System.gc())  76402K->67232K(188416K), 0.0038170 secs]
[Full GC (System.gc())  67232K->1629K(188416K), 0.0189803 secs]

```

placeholder 能否被回收的根本原因就是: 局部变量表中的变量槽是否还存有关于 placeholder 数组对象的引用。 第一次修改中, 代码虽然已经离开了 placeholder 的作用域, 但在此之后, 再没有发生过任何对局部变量表的读写操作, placeholder 原本所占用的变量槽还没有被其他变量所复用。 所以作为 GC Roots 一部分的局部变量表仍然保持着对它的关联。 这种关联没有被及时打断,  绝大部分情况下影响都很轻微。 但如果遇到一个方法, 其后面的代码有一些耗时很长的操作, 而前面又定义了占用了大量内存但实际上已经不会再使用的变量, 手动将其设置为 null 值 (用来代替那句 int
a=12, 把变量对应的局部变量槽清空) 便不见得是一个绝对无意义的操作, 这种操作可以作为一种在极特殊情形 (对象占用内存大, 此方法的栈帧长时间不能被回收, 方法调用次数达不到即时编译器的编译条件) 下的 "奇技" 来使用。


我们知道在类的加载阶段, 对于类的属性值, 会存在 2 次赋值, 第一次在准备阶段, 基于了字段的默认值, 第二次基于字段真正的数值。 但是在局部变量中, 如果只声明了, 但是没有赋值, 这个字段是没法使用的, 因为其不存在默认值。


### 10.1.2 操作数栈 - Operand Stack

也常被称为操作栈, 是一个后入先出 (Last In First Out, LIFO) 的栈。 操作数栈的最大深度也在编译的时候被写入到 Code 属性的 max_stacks 数据项之中。 操作数栈的每一个元素都可以是包括 long 和 double 在内的任意 Java 数据类型。 32 位数据类型所占的栈容量为 1, 64 位数据类型所占的栈容量为 2。 当一个方法刚刚开始执行的时候, 这个方法的操作数栈是空的, 在方法的执行过程中, 会有各种**字节码指令**往操作数栈中写入和提取内容, 也就是出栈和入栈操作。 例如: 整数加法的字节码指令 iadd, 会从操作数栈的顶部出去 2 个数, 相加后, 在存入栈顶。

操作数栈中元素的数据类型必须与字节码指令的序列严格匹配。 每个字节码都有其操作的数据类型限制。 这个限制编译程序代码的时候, 编译器会进行保证, 在类校验阶段的数据流分析中还会再次验证这一点。

在概念模型中, 两个不同栈帧作为不同方法的虚拟机栈的元素, 是完全相互独立的。 但是在大多虚拟机的实现里都会进行一些优化处理, 令两个栈帧出现一部分重叠。 让下面栈帧的部分操作数 栈与上面栈帧的部分局部变量表重叠在一起, 这样做不仅节约了一些空间, 更重要的是在进行方法调 用时就可以直接共用一部分数据，无须进行额外的参数复制传递了。

如图: ![Alt 'RealStackFrameImplement'](https://raw.githubusercontent.com/PictureRespository/Java/main/JVM/RealStackFrameImplement.png)



* 操作数栈 + 局部变量表配合的流程

```java
public class Application {

    public static void main(String[] args) throws InterruptedException {
        int add = add(1, 2);
        System.out.println(add);
    }

    public static int add(int num1, int num2) {
        num1 = 3;
        int result = num1 + num2;
        return result;
    }
}
```

先通过 `javac Application.java`
得到字节码文件, 再通过 `javap -c -l -p -v Application.class >> class.txt`

打开 class.txt 就能得到我们的字节码文件了, 内容如下

打开 class.txt 就能得到我们的字节码文件了, 内容如下
```java
Compiled from "Application.java"
public class Application {
  public Application();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]) throws java.lang.InterruptedException;
    Code:
       0: iconst_1
       1: iconst_2
       2: invokestatic  #2                  // Method add:(II)I
       5: istore_1
       6: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
       9: iload_1
      10: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V
      13: return

  public static int add(int, int);
    Code:
       0: iconst_3
       1: istore_0
       2: iload_0
       3: iload_1
       4: iadd
       5: istore_2
       6: iload_2
       7: ireturn
}
```

整理成图的话，调用 add 方法前是这样的

![Alt 'StackFrameProcessesDemo01'](https://raw.githubusercontent.com/PictureRespository/Java/main/JVM/StackFrameProcessesDemo01.png)


* 先看一下 add 方法的局部变量

首先我们看到 add 方法的局部变量表有三个属性, 分别是入参的 num1, num2, 还有方法内部声明的 result 变量。

补充说明: 因为这里的 add 方法是静态的, 所以入参有几个变量, 那么局部变量表就有几个。  
在实际中，如果方法是非静态的话, 局部变量变的第一个会多 1 个 this 的变量，后面才是入参。

* add 方法的操作数栈的变化

各个指令的作用可以通过查看官网得知: [地址](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5)

add 方法  

1. 第一个指令 iconst_3, 把一个 int 的数字放入到操作栈，这里的 iconst_3, 代表的是把 3 放入到操作栈 (注意这里的 iconst_? 只能表示到 5, 
超过 5 后的指令会变成 bipush 数字)

这时候的操作数栈是这样的
![Alt 'StackFrameProcessesDemo02'](https://raw.githubusercontent.com/PictureRespository/Java/main/JVM/StackFrameProcessesDemo02.png)

2. 第二个指令 istore_0, 把操作数栈, 最上面的数字 (必须是 int) 出栈, 并覆盖局部变量表第 0 的位置

这时候的操作数栈是这样的
![Alt 'StackFrameProcessesDemo03'](https://raw.githubusercontent.com/PictureRespository/Java/main/JVM/StackFrameProcessesDemo03.png)

通过查看局部变量表的变化，我们可以知道 `num1 = 3` 在程序中是分成了 2 个指令完成的

3. 第三个指令 iload_0, 把第 0 个局部变量的值放入栈帧(这个值必须是 int 类型)    
第四个命令为 iload_1, 那么就是把第 1 个局部变量放入到栈帧

经过第三，四个指令后，这时候的操作数栈是这样的  
![Alt 'StackFrameProcessesDemo04'](https://raw.githubusercontent.com/PictureRespository/Java/main/JVM/StackFrameProcessesDemo04.png)

4. 第五个指令 iadd, 把栈帧中的头 2 个 int 操作数弹出来, 进行相加，然后再把结果入栈。

经过第五个指令后，这时候的操作数栈是这样的
![Alt 'StackFrameProcessesDemo05'](https://raw.githubusercontent.com/PictureRespository/Java/main/JVM/StackFrameProcessesDemo05.png)

后面的六，七 就省略了

ireturn 从纸面上就能里面了吧，把操作数栈中的栈顶(一个 int 的数字)返回出去。

从上面的内容, 可以知道，操作数栈用于方法执行过程的流转, 局部变量表则用于存储临时的变量数据


### 10.1.3 动态连接 - Dynamic Linking

每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用, 持有这个引用是为了支持方法调用过程中的动态连接。  
Class 文件的常量池中存有大量的符号引用, 字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数 (invokevirtual #4 // Method java/io/PrintStream.println:(I)V)
这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用, 这种转化被称为静态解析。 另外一部分将在每一次运行期间都转化为直接引用,
这部分就称为动态连接。

### 10.1.4 方法返回地址 - return address

当一个方法开始执行后, 只有两种方式退出这个方法。  

第一种方式是执行引擎遇到任意一个方法返回的字节码指令, 这时候可能会有返回值传递给上层的方法调用者 (调用当前方法的方法称为调用者或者主调方法), 
方法是否有返回值以及返回值的类型将根据遇到何种方法返回指令来决定, 这种退出方法的方式称为 "正常调用完成" (Normal Method Invocation Completion)

第二种退出方式是在方法执行的过程中遇到了异常, 并且这个异常没有在方法体内得到妥善处理。无论是 Java 虚拟机内部产生的异常, 还是代码中使用 athrow 
字节码指令产生的异常。只要在本方法的异常表中没有搜索到匹配的异常处理器, 就会导致方法退出, 这种退出方法的方式称为 "异常调用完成 (Abrupt Method Invocation Completion)"。
一个方法使用异常完成出口的方式退出, 是不会给它的上层调用者提供任何返回值的。

无论采用何种退出方式, 在方法退出之后, 都必须返回到最初方法被调用时的位置, 程序才能继续执行。  
方法返回时可能需要在**栈帧**中保存一些信息, 用来帮助恢复它的上层主调方法的执行状态。  
一般来说, 方法正常退出时, 主调方法的 PC 计数器的值就可以作为返回地址, 栈帧中很可能会保存这个计数器值。而方法异常退出时, 返回地址是要通过异常
处理器表来确定的, 栈帧中就一般不会保存这部分信息。

方法退出的过程实际上等同于把当前栈帧出栈, 因此退出时可能执行的操作有: 恢复上层方法的局部变量表和操作数栈, 把返回值 (如果有的话) 压入调用者栈
帧的操作数栈中, 调整 PC 计数器的值以指向方法调用指令后面的一条指令等。

### 10.1.5 附加信息 - overhead information

《Java虚拟机规范》允许虚拟机实现增加一些规范里没有描述的信息到栈帧之中, 例如与调试, 性能收集相关的信息, 这部分信息完全取决于具体的虚拟机实现, 
这里不再详述。


## 10.2 方法调用
方法调用并不等同于方法中的代码被执行, 方法调用阶段唯一的任务就是确定被调用方法的版本 (即调用哪一个方法), 暂时还未涉及方法内部的具体运行过程。

Class 文件的编译过程中不包含传统程序语言编译的连接步骤, 一切方法调用在 Class 文件里面存储的都只是符号引用, 而不是方法在实际运行时内存布局中
的入口地址 (也就是之前说的直接引用), 这个特性给 Java 带来了更强大的动态扩展能力, 但也使得 Java 方法调用过程变得相对复杂, 某些调用需要在类加
载期间, 甚至到运行期间才能确定目标方法的直接引用。

### 10.2.1 解析

所有方法调用的目标方法在 Class 文件里面都是一个常量池中的符号引用, 在类加载的解析阶段, 会将其中的一部分符号引用转化为直接引用, 这种解析能够
成立的前提是: 方法在程序真正运行之前就有一个可确定的调用版本, 并且这个方法的调用版本在运行期是不可改变的。  
调用目标在程序代码写好, 编译器进行编译那一刻就已经确定下来。这类方法的调用被称为解析 (Resolution)。

在 Java 语言中符合 "编译期可知, 运行期不可变" 这个要求的方法, 主要有静态方法和私有方法两大类。前者与类型直接关联, 后者在外部不可被访问, 这
两种方法各自的特点决定了它们都不可能通过继承或别的方式重写出其他版本, 因此它们都适合在类加载阶段进行解析。

调用不同类型的方法, 字节码指令集里设计了不同的指令。在 Java 虚拟机支持以下 5 条方法调用字节码指令, 分别是
> 1. invokestatic: 用于调用静态方法
> 2. invokespecial: 用于调用实例构造器 <init>() 方法, 私有方法和父类中的方法
> 3. invokevirtual: 用于调用所有的虚方法
> 4. invokeinterface: 用于调用接口方法, 会在运行时在确定一个实现该接口的对象
> 5. invokedynamic: 先在运行时动态解析出调用点限定符所引用的方法, 然后再执行该方法

前面 4 条调用指令, 分派逻辑都固化在 Java 虚拟机内部, 而 invokedynamic 指令的分派逻辑是由用户设定的引导方法来决定的。

只要能被 invokestatic 和 invokespecial 指令调用的方法, 都可以在解析阶段中确定唯一的调用版本, Java 语言里符合这个条件的方法共有静态方法, 
私有方法, 实例构造器, 父类方法 4 种, 再加上被 final 修饰的方法 (final 方法是通过 invokevirtual 指令调用的)。

这 5 种方法调用会在类加载的时候就可以把符号引用解析为该方法的直接引用。这些方法统称为 "非虚方法" (No-Virtual Method), 与之相反, 其他方法
就被称为 "虚方法" (Virtual Method)。

解析调用一定是个静态的过程, 在编译期间就完全确定, 在类加载的解析阶段就会把涉及的符号引用全部转变为明确的直接引用, 不必延迟到运行期再去完成。
而另一种主要的方法调用形式: 分派 (Dispatch) 调用则要复杂许多, 它可能是静态的也可能是动态的。按照分派依据的宗量数可分为单分派和多分派。
这两类分派方式两两组合就构成了静态单分派, 静态多分派, 动态单分派, 动态多分派 4 种分派组合情况。

### 10.2.2 分派

#### 10.2.2.1 静态分派

先看一下一段代码
```java
public class StaticDispatch {
    
    static abstract class Human {
    }

    static class Man extends Human {
    }

    static class Woman extends Human {
    }

    public void sayHello(Human guy) { 
        System.out.println("hello,guy!"); 
    }
    
    public void sayHello(Man guy) { 
        System.out.println("hello,gentleman!"); 
    }
    
    public void sayHello(Woman guy) { 
        System.out.println("hello,lady!"); 
    }

    public static void main(String[] args) { 
        
        Human man = new Man(); 
        Human woman = new Woman(); 
        StaticDispatch sr = new StaticDispatch(); 
        
        // 此处输出结果: hello,guy!
        sr.sayHello(man); 
        
        // 此处输出结果: hello,guy!
        sr.sayHello(woman); 
    }
}
```

再确定为什么输出结果是这样之前, 先理解一点概念性的东西。

```java
Human man = new Man();
```
在上面的代码中,   
"Human" 称为变量的 "静态类型 (Static Type)" 或者 "外观类型 (Apparent Type)",  
"Man" 称为变量的 "实际类型 (Actual Type)" 或者 "运行时类型 (Runtime Type)"。

静态类型和实际类型在程序中都可能发生变化, 区别是静态类型的编号仅仅在使用时发生, 变量本身的静态类型不会被改变, 并且最终的静态类型咋编译期就可知。  
实际类型变化的结果在运行期才可确定, 编译器在编译期并不知道一个对象的实际类型是什么。

例子:
```java
// 实际类型变化 
Human human = (new Random()).nextBoolean() ? new Man() : new Woman();

// 静态类型变化 
sr.sayHello((Man) human);
sr.sayHello((Woman) human)
```

对象 human 的实际类型是可变的, 必须等到程序运行到这行的时候才能确定。
而 human 的静态类型是 Human, 使用时临时改变这个类型 (例如: 通过强转), 但这个改变在编译期是可知的。

理解了这 2 个概念后, 分析一下上面的代码了。

在方法接收者已经确定是对象 "sr" 的前提下, 使用哪个重载版本, 就完全取决于**传入参数的数量**和**数据类型**。
虚拟机 (或者准确地说是编译器) 在重载时是通过参数的静态类型而不是实际类型作为判定依据的。由于静态类型在编译期可知, 所以在编译阶段, Javac 编
译器就根据参数的静态类型决定了会使用哪个重载版本, 因此选择了 sayHello(Human) 作为调用目标, 并把这个方法的符号引用写到 main() 方法里的两条 
invokevirtual 指令的参数中。

所有依赖静态类型来决定方法执行版本的分派动作, 都称为静态分派。静态分派的最典型应用表现就是方法重载。静态分派发生在编译阶段, 因此确定静态分派的
动作实际上不是由虚拟机来执行的。

Javac 编译器虽然能确定出方法的重载版本, 但在很多情况下这个重载版本并不是 "唯一" 的, 往往只能确定一个 "相对更合适的" 版本。 产生这种模糊结论
的主要原因是字面量天生的模糊性, 它不需要定义, 所以字面量就没有显式的静态类型, 它的静态类型只能通过语言, 语法的规则去理解和推断。

```java
public class Overload {
    public static void sayHello(Object arg) {
        System.out.println("hello Object");
    }

    public static void sayHello(int arg) {
        System.out.println("hello int");
    }

    public static void sayHello(long arg) {
        System.out.println("hello long");
    }

    public static void sayHello(Character arg) {
        System.out.println("hello Character");
    }

    public static void sayHello(char arg) {
        System.out.println("hello char");
    }

    public static void sayHello(char... arg) {
        System.out.println("hello char ...");
    }

    public static void sayHello(Serializable arg) {
        System.out.println("hello Serializable");
    }

    public static void main(String[] args) {
        sayHello('a');
    }
}
```

上面的代码输出的结果为: "hello char", 因为 'a' 是一个 char 类型的数据, 但是注释掉 **sayHello(char arg)** 方法后, 会输出 "hello, int",  
这时候发送了一次自动类型转换, 'a' 处理代表一个字符串, 还可以代表数字 97 (字符 'a' 的 Unicode 数值为十进制数字 97)。  
再一次注释掉 **sayHello(int arg)**, 输出结果为 "hello long", int 可以转换为 long。一般 char 依次可以转换为 char > int > long > 
float > double 的顺序进行转换。

注释 **sayHello(long arg)** 输出: "hello Character"  
注释 **sayHello(Character arg)** 输出 "hello Serializable" (Character 实现了 Serializable), 这时候如果代码里面还有一个 Comparable<Character>
的参数的话, 这时会出现编译失败, Character 同时实现了 Serializable 和 Comparable<Character>, 2 个重载方法的优先级是一样的。

注释 **sayHello(Serializable arg)** 输出: "hello Object"  
注释 **sayHello(Object arg)** 输出: "hello char ..."  

可见变长参数的重载优先级是最低的。


#### 10.2.2.2 动态分派

动态分派主要与Java语言多态性的**重写**有关。

```java
public class DynamicDispatch {

    static abstract class Human { 
        protected abstract void sayHello(); 
    }

    static class Man extends Human {
        @Override 
        protected void sayHello() { 
            System.out.println("man say hello"); 
        }
    }

    static class Woman extends Human {
        @Override
        protected void sayHello() {
            System.out.println("woman say hello");
        }
    }

    public static void main(String[] args) {
        Human man = new Man(); 
        Human woman = new Woman(); 
        
        // man say hello
        man.sayHello();
        // woman say hello
        woman.sayHello(); 
        
        man = new Woman(); 
        
        // woman say hello
        man.sayHello();
    }
}
```

选择调用的方法版本是不可能再根据静态类型来决定的, 因为静态类型同样都是 Human 的两个变量 man 和 woman 在调用 sayHello() 方法时产生了不同
的行为, 甚至变量 man 在两次调用中还执行了两个不同的方法。

通过 **javac 和 javap** 获取到字节码文件
```
public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=3, args_size=1
         0: new           #2                  // class DynamicDispatch$Man
         3: dup
         4: invokespecial #3                  // Method DynamicDispatch$Man."<init>":()V
         7: astore_1
         8: new           #4                  // class DynamicDispatch$Woman
        11: dup
        12: invokespecial #5                  // Method DynamicDispatch$Woman."<init>":()V
        15: astore_2
        16: aload_1
        17: invokevirtual #6                  // Method DynamicDispatch$Human.sayHello:()V
        20: aload_2
        21: invokevirtual #6                  // Method DynamicDispatch$Human.sayHello:()V
        24: new           #4                  // class DynamicDispatch$Woman
        27: dup
        28: invokespecial #5                  // Method DynamicDispatch$Woman."<init>":()V
        31: astore_1
        32: aload_1
        33: invokevirtual #6                  // Method DynamicDispatch$Human.sayHello:()V
        36: return
```

0～15 行的字节码是准备动作, 作用是建立 man 和 woman 的内存空间, 调用 Man 和 Woman 类型的实例构造器, 将这两个实例的引用存放在第 1, 2 个
局部变量表的变量槽中, 对应的代码就是 
```java
Human man = new Man(); 
Human woman = new Woman();
```




