# 10. JVM 执行引擎

执行引擎是 Java 虚拟机核心的组成部分之一。在《Java虚拟机规范》中制定了 Java 虚拟机字节码执行引擎的概念模型, 这个概念模型成为各大发 行商的 
Java 虚拟机执行引擎的统一外观 (Facade)。不同的虚拟机的实现中, 通常会有解释执行 (通过解释器执行) 和编译执行 (通过即时编译器产生本地代码执行) 
两种选择, 也可能两者兼备, 还可能会有同时包含几个不同级别的即时编译器一起工作的执行引擎。但是从外观上看, 所有的 Java 虚拟机的执行引擎都是: 输
入的是字节码二进制流, 输出的是执行结果。

## 10.1 运行时栈帧

Java 虚拟机以方法作为最基本的执行单元, "栈帧" (Stack Frame) 则是用于支持虚拟机进行方法调用和方法执行背后的数据结构, 它也是虚拟机运行时数
据区中的虚拟机栈 (Virtual Machine Stack) 的栈元素。栈帧存储了方法的局部变量表 / 操作数栈 / 动态连接和方法返回地址等信息。每一个方法从调
用开始至执行结束的过程, 都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。

每一个栈帧都包括了局部变量表, 操作数栈, 动态连接, 方法返回地址和一些额外的附加信息。  
在编译 Java 程序源码的时候, 栈帧中需要多大的局部变量表, 需要多深的操作数栈就已经被分析计算出来, 并且写入到方法表的 Code 属性之中。  
一个栈帧需要分配多少内存, 并不会受到程序运行期变量数据的影响, 而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式。

一个线程中的方法调用链可能会很长, 以 Java 程序的角度来看, 同一时刻, 同一条线程里面, 在调用堆栈的所有方法都同时处于执行状态。而对于执行引擎
来讲, 在活动线程中, 只有位于栈顶的方法才是在运行的, 只有位于栈顶的栈帧才是生效的, 其被称为 "当前栈帧" (Current Stack Frame), 与这个栈帧
所关联的方法被称为 "当前方法" (Current Method)

综上, 栈帧的结构如下:  
![Alt 'ConstructionOfStackFrame'](https://raw.githubusercontent.com/PictureRespository/Java/main/JVM/ConstructionOfStackFrame.png)

### 10.1.1 局部变量表 - Local Variables Table

局部变量表是一组变量值的存储空间, 用于存放方法参数和方法内部定义的局部变量。在 Java 程序被编译为 Class 文件时, 就在方法的 Code 属性的 
max_locals 数据项中确定了该方法所需分配的局部变量表的最大容量。

局部变量表的容量以变量槽 (Variable Slot) 为最小单位。1 个槽的具体大小, 《Java虚拟机规范》中并没有明确指出, 但是引导性地说明了 boolean 
/ byte / char / short / int / float / reference / returnAddress 类型的数据, 这 8 种数据类型, 都可以使用 32 位或更小的物理内存来存储。

reference 类型表示对一个对象实例的引用, 《Java虚拟机规范》既没有说明它的长度, 也没有明确指出这种引用应有怎样的结构。但是需要能通过这个引
用做到两件事情: 一是从根据引用直接或间接地查找到对象在 Java 堆中的数据存放的起始地址或索引, 二是根据引用直接或间接地查找到对象所属数据类型在
方法区中的存储的类型信息。

returnAddress 类型模板以及很少见了, 它是为字节码指令 jsr, jsr_w 和 ret 服务的, 指向了一条字节码指令的地址, 某些很古老的 Java 虚拟机曾
经使用这几条指令来实现异常处理时的跳转, 但现在也已经全部改为采用异常表来代替了。

对于 64 位的数据类型, Java 虚拟机会以高位对齐的方式为其分配两个连续的变量槽空间。Java 语言中明确的 64 位的数据类型只有 long 和 double 两种。
Java 虚拟机通过索引定位的方式使用局部变量表, 索引值的范围是从 0 开始至局部变量表最大的变量槽数量。如果访问的是 32 位数据类型的变量, 索引 N 
就代表了使用第 N 个变量槽, 如果访问的是 64 位数据类型的变量, 则说明会同时使用第 N 和 N + 1 两个变量槽。 对于两个相邻的共同存放一个 64 位数
据的两个变量槽, 虚拟机不允许采用任何方式单独访问其中的某一个。

当一个方法被调用时, Java 虚拟机会使用局部变量表来完成参数值到参数变量列表的传递过程, 即实参到形参的传递。 如果执行的是实例方法 (没有被 static 
修饰的方法), 那局部变量表中第 0 位索引的变量槽默认是用于传递方法所属对象实例的引用, 在方法中可以通过关键字 "this" 来访问到这个隐含的参数。
其余参数则按照参数表顺序排列, 占用从 1 开始的局部变量槽, 参数表分配完毕后, 再根据方法体内部定义的变量顺序和作用域分配其余的变量槽。

为了尽可能节省栈帧耗用的内存空间, 局部变量表中的变量槽是可以重用的, 方法体中定义的变量, 其作用域并不一定会覆盖整个方法体, 如果当前字节码 PC 
计数器的值已经超出了某个变量的作用域, 那这个变量对应的变量槽就可以交给其他变量来重用。 不过, 这样的设计除了节省栈帧空间以外, 还会伴随有少量
额外的副作用, 例如在某些情况下变量槽的复用会直接影响到系统的垃圾收集行为

```java
public static void main(String[] args)() { 
    byte[] placeholder = new byte[64 * 1024 * 1024]; 
    System.gc(); 
}
```



