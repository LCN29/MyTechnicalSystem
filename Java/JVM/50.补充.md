# 字节码解释器

字节码解释器

c++ 语言执行每个指令的过程   涉及的文件: bytecodeInterpreter.cpp

模板解释器

汇编语言执行每个指令的过程    涉及的文件: TemplateInterpreter.cpp   模板文件: templateTable_x84_64.cpp


```c++
CASE(_monitorenter): {

    // 锁对象
    oop lockee = STACK_OBJECT(-1);
    // 非空判断
    CHECK_NULL(lockee);

    // 1. 找到一个空闲的 monitor 或已经为该对象分配的 monitor
    // 如果我们找到匹配的对象, 那么我们需要一个新的 monitor  由于递归输入 
    // if we find a matching object then we need a new monitor since this is recursive enter

    // 调用栈帧中查找一个空闲的 BasicObjectLock, 也就是 Lock Record 
    BasicObjectLock* limit = istate->monitor_base();
    BasicObjectLock* most_recent = (BasicObjectLock*) istate->stack_base();
    BasicObjectLock* entry = NULL;
    while (most_recent != limit ) {
      if (most_recent->obj() == NULL) 
        entry = most_recent;
      else if (most_recent->obj() == lockee) 
        break;
      most_recent++;
    }

    // entry不为null，代表还有空闲的Lock Record  
    if (entry != NULL) {
      // 将 entry 的 obj 属性设置为当前的锁对象
      entry->set_obj(lockee);
      int success = false;
      uintptr_t epoch_mask_in_place = (uintptr_t)markOopDesc::epoch_mask_in_place;

      // 获取锁对象的 mark word
      markOop mark = lockee->mark();
      intptr_t hash = (intptr_t) markOopDesc::no_hash;

      // 锁对象的 mark word 的状态是偏向模式
      if (mark->has_bias_pattern()) {
        uintptr_t thread_ident;
        uintptr_t anticipated_bias_locking_value;

        // 当前的线程 ID
        thread_ident = (uintptr_t)istate->thread();

        // 获取到 锁对象的 class 的属性头, 正常情况下和锁对象的对象头一样，除了年龄代为 4 个 0 外
        // | 有 1 就是 1, 变成了 线程 Id + class 的 epoch + class 年龄代 + 偏向锁标志 + 锁标志
        // ^ 上面的结果和当前锁对象的 mark word 异或, 相等位变为 0, 不相等为 1
        // markOopDesc::age_mask_in_place 等于 0...1111000, 取反后为 1...0000111
        // 将上面 2 步的结果进行与, 
        
        anticipated_bias_locking_value =
          (((uintptr_t)lockee->klass()->prototype_header() | thread_ident) ^ (uintptr_t)mark) &
          ~((uintptr_t) markOopDesc::age_mask_in_place);

        // 如果偏向的线程是自己 且 epoch 等于 class 对象的 epoch
        if  (anticipated_bias_locking_value == 0) {
          // 已经偏向了这个线程, 不需要做其他事情了
          // 如果开启了偏向锁分析
          if (PrintBiasedLockingStatistics) {
              // 偏向锁获取次数 + 1
            (* BiasedLocking::biased_lock_entry_count_addr())++;
          }
          // 偏向锁处理成功
          success = true;
        }

        // 如果偏向模式关闭，则尝试撤销偏向锁
        else if ((anticipated_bias_locking_value & markOopDesc::biased_lock_mask_in_place) != 0) {
          
          // 获取当前 class 对象的 对象头
          markOop header = lockee->klass()->prototype_header();
          // 设置 hash , 这时候这个 header 没了年龄代信息?
          if (hash != markOopDesc::no_hash) {
            header = header->copy_set_hash(hash);
          }

          // 通过 CAS 将 锁对象的 mark word 从 mark  设置 为 header 
          if (Atomic::cmpxchg_ptr(header, lockee->mark_addr(), mark) == mark) {
            // 
            if (PrintBiasedLockingStatistics)
              // 锁撤销次数 + 1
              (*BiasedLocking::revoked_lock_entry_count_addr())++;
          }

        }
        // 如果 锁对象的 epoch 不等于 class 中的 epoch, 则尝试重偏向
        else if ((anticipated_bias_locking_value & epoch_mask_in_place) !=0) {
          // 构造一个偏向当前线程的mark word
          markOop new_header = (markOop) ( (intptr_t) lockee->klass()->prototype_header() | thread_ident);

          // 设置 hash
          if (hash != markOopDesc::no_hash) {
            new_header = new_header->copy_set_hash(hash);
          }

          // CAS替换对象头的 为新的 mark word
          if (Atomic::cmpxchg_ptr((void*)new_header, lockee->mark_addr(), mark) == mark) {
            if (PrintBiasedLockingStatistics)
              // 重偏向次数 + 1
              (* BiasedLocking::rebiased_lock_entry_count_addr())++;
          }
          else {
              // 重偏向失败，代表存在多线程竞争，则调用 InterpreterRuntime:;monitorenter 方法进行锁升级
            CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);
          }
          success = true;
        }
        else {


          // 走到这里说明当前要么偏向别的线程，要么是匿名偏向 (即没有偏向任何线程)

          //构建一个匿名偏向的mark word，尝试用CAS指令替换掉锁对象的mark word
          markOop header = (markOop) ((uintptr_t) mark & ((uintptr_t)markOopDesc::biased_lock_mask_in_place | (uintptr_t)markOopDesc::age_mask_in_place |
                                                          epoch_mask_in_place));

          if (hash != markOopDesc::no_hash) {
            header = header->copy_set_hash(hash);
          }

          // 线程偏向这个线程
          markOop new_header = (markOop) ((uintptr_t) header | thread_ident);

          // 调试信息 
          DEBUG_ONLY(entry->lock()->set_displaced_header((markOop) (uintptr_t) 0xdeaddead);)


          if (Atomic::cmpxchg_ptr((void*)new_header, lockee->mark_addr(), header) == header) {
            // CAS修改成功  
            if (PrintBiasedLockingStatistics)
              // 匿名偏向锁次数 + 1
              (* BiasedLocking::anonymously_biased_lock_entry_count_addr())++;
          }
          else {
            // 如果修改失败说明存在多线程竞争，所以进入InterpreterRuntime::monitorenter 方法进行锁升级
            CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);
          }
          success = true;
        }
      }

      // 传统轻量级锁实现
      // 如果没有开启偏向模式等原因都会导致 success == false
      if (!success) {
        //  构造一个无锁状态的 Displaced Mark Word, 并将 Lock Record 的 lock 指向它
        markOop displaced = lockee->mark()->set_unlocked();
        entry->lock()->set_displaced_header(displaced);

        bool call_vm = UseHeavyMonitors;

        //如果指定了 -XX:+UseHeavyMonitors, 则 call_vm = true, 代表禁用偏向锁和轻量级锁
        // CAS 失败了
        if (call_vm || Atomic::cmpxchg_ptr(entry, lockee->mark_addr(), displaced) != displaced) {

           // 启用了偏向锁同时 从锁对象获取的 mark word 所在的位置指向的 Lock Record 所在的线程为当前线程
          if (!call_vm && THREAD->is_lock_owned((address) displaced->clear_lock_bits())) {
            // 锁重入，则直接将 Displaced Mark Word 设置为 null, 最外层可以找到对象信息, 轻量级锁处说明原因
            entry->lock()->set_displaced_header(NULL);
          } else {
            // 锁竞争, 锁升级
            CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);
          }
        }
      }
      // 下一个指令
      UPDATE_PC_AND_TOS_AND_CONTINUE(1, -1);
    } else {
      istate->set_msg(more_monitors);
      UPDATE_PC_AND_RETURN(0); // Re-execute
    }
  }

```


偏向锁的撤销和释放

撤销: 获取偏向锁的过程因为不满足条件导致要将锁对象改为非偏向锁状态
释放: 指退出同步块时的过程，释放锁



非 VM Thread 获取偏向锁失败:
InterpreterRuntime::monitorenter 
--> ObjectSynchronizer::fast_enter(h_obj, elem->lock(), true, CHECK)
--> BiasedLocking::revoke_and_rebias(obj, attempt_rebias, THREAD)

```C++

BiasedLocking::Condition BiasedLocking::revoke_and_rebias(Handle obj, bool attempt_rebias, TRAPS) {

    // SafepointSynchronize::is_at_safepoint 所有的线程都停在一个安全点上, 只有 VM Thread 在运行
    // 不能在安全点进行操作, 防止 VM Thread 执行下面的逻辑
    assert(!SafepointSynchronize::is_at_safepoint(), "must not be called while at safepoint");
    
    // 获取锁对象的 markOop 
    markOop mark = obj->mark();
    
    // 匿名偏向锁, attempt_rebias: 上游推送过来的, 默认为true
    if (mark->is_biased_anonymously() && !attempt_rebias) {
        // 如果是匿名偏向且 attempt_rebias == false 会走到这里，
        // 如锁对象的 hashcode 方法被调用会出现这种情况，需要撤销偏向锁。
        
        markOop biased_value       = mark;
        
        // 未偏向锁 mark work
        markOop unbiased_prototype = markOopDesc::prototype()->set_age(mark->age());
        // CAS 锁对象的 mark work 为 无锁
        markOop res_mark = (markOop) Atomic::cmpxchg_ptr(unbiased_prototype, obj->mark_addr(), mark);
        if (res_mark == biased_value) {
          return BIAS_REVOKED;
        }
    // 开启了偏向锁   
    } else if (mark->has_bias_pattern()) {
        // 锁对象开启了偏向模式会走到这里
        Klass* k = obj->klass();
        markOop prototype_header = k->prototype_header();
        // 如果对应 class 关闭了偏向模式
        if (!prototype_header->has_bias_pattern()) {
        
          markOop biased_value       = mark;
          markOop res_mark = (markOop) Atomic::cmpxchg_ptr(prototype_header, obj->mark_addr(), mark);
          assert(!(*(obj->mark_addr()))->has_bias_pattern(), "even if we raced, should still be revoked");
          return BIAS_REVOKED;
          
         //code2： 如果epoch过期
        } else if (prototype_header->bias_epoch() != mark->bias_epoch()) {
        
            // 是否为重偏向 
            if (attempt_rebias) {
            
                assert(THREAD->is_Java_thread(), "");
                
                markOop biased_value       = mark;
                // 重建一个新的 epoch 相同, 并且偏向当前线程的 mark word 
                markOop rebiased_prototype = markOopDesc::encode((JavaThread*) THREAD, mark->age(), prototype_header->bias_epoch());
                // 重试设置新的偏向锁
                markOop res_mark = (markOop) Atomic::cmpxchg_ptr(rebiased_prototype, obj->mark_addr(), mark);
                if (res_mark == biased_value) {
                  return BIAS_REVOKED_AND_REBIASED;
                }
            } else {
                // 设置为无锁状态
                markOop biased_value       = mark;
                markOop unbiased_prototype = markOopDesc::prototype()->set_age(mark->age());
                markOop res_mark = (markOop) Atomic::cmpxchg_ptr(unbiased_prototype, obj->mark_addr(), mark);
                if (res_mark == biased_value) {
                    return BIAS_REVOKED;
                }
            }
        }
    }
    
    //code 3：批量重偏向与批量撤销的逻辑
    HeuristicsResult heuristics = update_heuristics(obj(), attempt_rebias);
    if (heuristics == HR_NOT_BIASED) {
        return NOT_BIASED;
    } else if (heuristics == HR_SINGLE_REVOKE) {
        //code 4：撤销单个线程
        Klass *k = obj->klass();
        markOop prototype_header = k->prototype_header();
        
        if (mark->biased_locker() == THREAD && prototype_header->bias_epoch() == mark->bias_epoch()) {
        
            // 走到这里说明需要撤销的是偏向当前线程的锁，当调用 Object#hashcode 方法时会走到这一步
            // 因为只要遍历当前线程的栈就好了，所以不需要等到 safepoint 再撤销。
            ResourceMark rm;
            if (TraceBiasedLocking) {
                tty->print_cr("Revoking bias by walking my own stack:");
            }
            
            // 调用方法
            BiasedLocking::Condition cond = revoke_bias(obj(), false, false, (JavaThread*) THREAD);
            ((JavaThread*) THREAD)->set_cached_monitor_info(NULL);
            assert(cond == BIAS_REVOKED, "why not?");
            return cond;
            
        } else {
            // 下面代码最终会在VM线程中的 safepoint 调用 revoke_bias 方法, 类似于注册事件
            VM_RevokeBias revoke(&obj, (JavaThread*) THREAD);
            VMThread::execute(&revoke);
            return revoke.status_code();
        }
    
    }
    
    assert((heuristics == HR_BULK_REVOKE) || (heuristics == HR_BULK_REBIAS), "?");
    
    //code5：批量撤销、批量重偏向的逻辑
    VM_BulkRevokeBias bulk_revoke(&obj, (JavaThread*) THREAD, (heuristics == HR_BULK_REBIAS), attempt_rebias);
    VMThread::execute(&bulk_revoke);
    return bulk_revoke.status_code();
}
```

会走到该方法的逻辑有很多, 我们只分析最常见的情况: 假设锁已经偏向线程A, 这时B线程尝试获得锁。

上面的code 1, code 2 B线程都不会走到, 最终会走到 code 4 处，如果要撤销的锁偏向的是当前线程则直接调用 revoke_bias 撤销偏向锁, 否则会将该
操作 push 到 VM Thread 中等到 safepoint 的时候再执行。

关于VM Thread这里介绍下：在JVM中有个专门的VM Thread，该线程会源源不断的从VMOperationQueue中取出请求，比如GC请求。对于需要 safepoint 
的操作（VM_Operationevaluate_at_safepoint 返回 true）必须要等到所有的 Java 线程进入到 safepoint 才开始执行


单个线程的锁撤销重点:

```C++
// obj: 锁对象, allow_rebias 为 faslse, is_bulk 为 false requesting_thread 当前线程
static BiasedLocking::Condition revoke_bias(oop obj, bool allow_rebias, bool is_bulk, JavaThread* requesting_thread) {
   
   markOop mark = obj->mark();
  // 如果没有开启偏向模式，则直接返回 NOT_BIASED
  if (!mark->has_bias_pattern()) {
    ...
    return BiasedLocking::NOT_BIASED;
  }
  
  uint age = mark->age();
  // 构建两个mark word，一个是匿名偏向模式（101），一个是无锁模式（001）
  markOop   biased_prototype = markOopDesc::biased_locking_prototype(); 
  markOop unbiased_prototype = markOopDesc::prototype()->set_age(age);

  ...
  
  // 当前的对象的偏向的线程
  JavaThread* biased_thread = mark->biased_locker();
  
  // 为空
  if (biased_thread == NULL) {
     // 匿名偏向。当调用锁对象的hashcode()方法可能会导致走到这个逻辑
     // 如果不允许重偏向，则将对象的mark word设置为无锁模式
    // allow_rebias 为false, 此处变为无锁状态
    if (!allow_rebias) {
      obj->set_mark(unbiased_prototype);
    }
    ...
    return BiasedLocking::BIAS_REVOKED;
  }
  
  // code 1：判断偏向线程是否还存活
  bool thread_is_alive = false;
  // 如果当前线程就是偏向线程 
  if (requesting_thread == biased_thread) {
    thread_is_alive = true;
  } else {
    // 遍历当前jvm的所有线程，如果能找到，则说明偏向的线程还存活
    for (JavaThread* cur_thread = Threads::first(); cur_thread != NULL; cur_thread = cur_thread->next()) {
      if (cur_thread == biased_thread) {
        thread_is_alive = true;
        break;
      }
    }
  }
  
  // 如果偏向的线程已经不存活了
  if (!thread_is_alive) {
    // 允许重偏向则将对象mark word设置为匿名偏向状态，否则设置为无锁状态
    if (allow_rebias) {
      obj->set_mark(biased_prototype);
    } else {
      obj->set_mark(unbiased_prototype);
   }
    ...
    return BiasedLocking::BIAS_REVOKED;
  }
  
  
  // 线程还存活则遍历线程栈中所有的Lock Record
  GrowableArray<MonitorInfo*>* cached_monitor_info = get_or_compute_monitor_info(biased_thread);
  BasicLock* highest_lock = NULL;
  for (int i = 0; i < cached_monitor_info->length(); i++) {
  
    MonitorInfo* mon_info = cached_monitor_info->at(i);
    // 如果能找到对应的 Lock Record 说明偏向的线程还在执行同步代码块中的代码
    // 这个 Lock Record 指向的 obj 是当前锁对象
    if (mon_info->owner() == obj) {
    
      ...
      // 需要升级为轻量级锁，直接修改偏向线程栈中的 Lock Record。
      // 为了处理锁重入的情况，在这里将 Lock Record 的 Displaced Mark Word 设置为 null，
      // 第一个 Lock Record 会在下面的代码中再处理
      
      markOop mark = markOopDesc::encode((BasicLock*) NULL);
      highest_lock = mon_info->lock();
      highest_lock->set_displaced_header(mark);
    } else {
      ...
    }
  }
  
  if (highest_lock != NULL) {
    // 修改第一个Lock Record为无锁状态，然后将obj的mark word设置为指向该Lock Record的指针
    highest_lock->set_displaced_header(unbiased_prototype);
    obj->release_set_mark(markOopDesc::encode(highest_lock));
    ...
  } else {
  
    // 走到这里说明偏向线程已经不在同步块中了
    ...
    if (allow_rebias) {
       //设置为匿名偏向状态
      obj->set_mark(biased_prototype);
    } else {
      // 将mark word设置为无锁状态
      obj->set_mark(unbiased_prototype);
    }
  }
  return BiasedLocking::BIAS_REVOKED;
}
```

需要注意下，当调用锁对象的Object#hash或System.identityHashCode()方法会导致该对象的偏向锁或轻量级锁升级。这是因为在Java中一个对象的 
hashcode是在调用这两个方法时才生成的，如果是无锁状态则存放在mark word中，如果是重量级锁则存放在对应的monitor中，而偏向锁是没有地方能存放该信息的，所以必须升级


言归正传，revoke_bias方法逻辑：

查看偏向的线程是否存活，如果已经不存活了，则直接撤销偏向锁。JVM维护了一个集合存放所有存活的线程，通过遍历该集合判断某个线程是否存活。
偏向的线程是否还在同步块中，如果不在了，则撤销偏向锁。我们回顾一下偏向锁的加锁流程：每次进入同步块（即执行monitorenter）的时候都会以从高往低的顺序在栈中找到第一个可用的Lock Record，将其obj字段指向锁对象。每次解锁（即执行monitorexit）的时候都会将最低的一个相关Lock Record移除掉。所以可以通过遍历线程栈中的Lock Record来判断线程是否还在同步块中。
将偏向线程所有相关Lock Record的Displaced Mark Word设置为null，然后将最高位的Lock Record的Displaced Mark Word 设置为无锁状态，最高位的Lock Record也就是第一次获得锁时的Lock Record（这里的第一次是指重入获取锁时的第一次），然后将对象头指向最高位的Lock Record，这里不需要用CAS指令，因为是在safepoint。 执行完后，就升级成了轻量级锁。原偏向线程的所有Lock Record都已经变成轻量级锁的状态。这里如果看不明白，请回顾上篇文章的轻量级锁加锁过程。






偏向级锁 弃用
https://www.zhihu.com/question/288104563


jdk6默认开启偏向锁, 4秒后 启用偏向锁状态

几个调优参数

-XX:+UseHeavyMonitors  只使用重量锁
-XX:+/- UseBiasedLocking  启用/关闭 偏向锁, JDK 6 后默认为启用状态
-XX:BiasedLockingStartupDelay=0  //关闭延迟开启偏向锁

在虚拟机启动后的 BiasedLockingStartupDelay 毫秒内, 创建的对象都是无锁状态
BiasedLockingStartupDelay 毫秒后创建的对象，包括 Class 对象, 默认都是 匿名偏向, 也就是偏向锁状态, 但是锁的线程 ID 为 0


hash 会导致锁升级