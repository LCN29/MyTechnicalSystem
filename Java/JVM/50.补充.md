# 字节码解释器

字节码解释器

c++ 语言执行每个指令的过程   涉及的文件: bytecodeInterpreter.cpp

模板解释器

汇编语言执行每个指令的过程    涉及的文件: TemplateInterpreter.cpp   模板文件: templateTable_x84_64.cpp


```c++
CASE(_monitorenter): {

    // 锁对象
    oop lockee = STACK_OBJECT(-1);
    // 非空判断
    CHECK_NULL(lockee);

    // 1. 找到一个空闲的 monitor 或已经为该对象分配的 monitor
    // 如果我们找到匹配的对象, 那么我们需要一个新的 monitor  由于递归输入 
    // if we find a matching object then we need a new monitor since this is recursive enter

    // 调用栈帧中查找一个空闲的 BasicObjectLock
    BasicObjectLock* limit = istate->monitor_base();
    BasicObjectLock* most_recent = (BasicObjectLock*) istate->stack_base();
    BasicObjectLock* entry = NULL;
    while (most_recent != limit ) {
      if (most_recent->obj() == NULL) 
        entry = most_recent;
      else if (most_recent->obj() == lockee) 
        break;
      most_recent++;
    }

    // entry不为null，代表还有空闲的Lock Record  
    if (entry != NULL) {
      // 将 entry 的 obj 属性设置为当前的锁对象
      entry->set_obj(lockee);
      int success = false;
      uintptr_t epoch_mask_in_place = (uintptr_t)markOopDesc::epoch_mask_in_place;

      // 获取锁对象的 mark word
      markOop mark = lockee->mark();
      intptr_t hash = (intptr_t) markOopDesc::no_hash;

      // 锁对象的 mark word 的状态是偏向模式
      if (mark->has_bias_pattern()) {
        uintptr_t thread_ident;
        uintptr_t anticipated_bias_locking_value;
        thread_ident = (uintptr_t)istate->thread();

        
        anticipated_bias_locking_value =
          (((uintptr_t)lockee->klass()->prototype_header() | thread_ident) ^ (uintptr_t)mark) &
          ~((uintptr_t) markOopDesc::age_mask_in_place);

        // 如果偏向的线程是自己且epoch等于class的epoch
        if  (anticipated_bias_locking_value == 0) {
          // 已经偏向了这个线程, 不需要做其他事情了 already biased towards this thread, nothing to do
          if (PrintBiasedLockingStatistics) {
              // 重入性 +1
            (* BiasedLocking::biased_lock_entry_count_addr())++;
          }
          success = true;
        }

        // 如果偏向模式关闭，则尝试撤销偏向锁
        else if ((anticipated_bias_locking_value & markOopDesc::biased_lock_mask_in_place) != 0) {
          
          // try revoke bias
          markOop header = lockee->klass()->prototype_header();
          if (hash != markOopDesc::no_hash) {
            header = header->copy_set_hash(hash);
          }

          // 通过 CAS 将 锁对象的 mark word 从 mark  设置 为 header 
          if (Atomic::cmpxchg_ptr(header, lockee->mark_addr(), mark) == mark) {

             // 重入性 + 1 
            if (PrintBiasedLockingStatistics)
              (*BiasedLocking::revoked_lock_entry_count_addr())++;
          }

        }
        // 如果epoch不等于class中的epoch，则尝试重偏向
        else if ((anticipated_bias_locking_value & epoch_mask_in_place) !=0) {
          // 构造一个偏向当前线程的mark word
          markOop new_header = (markOop) ( (intptr_t) lockee->klass()->prototype_header() | thread_ident);

          if (hash != markOopDesc::no_hash) {
            new_header = new_header->copy_set_hash(hash);
          }

          // CAS替换对象头的mark word
          if (Atomic::cmpxchg_ptr((void*)new_header, lockee->mark_addr(), mark) == mark) {
            if (PrintBiasedLockingStatistics)
              (* BiasedLocking::rebiased_lock_entry_count_addr())++;
          }
          else {
              // 重偏向失败，代表存在多线程竞争，则调用monitorenter方法进行锁升级
            CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);
          }
          success = true;
        }
        else {
          // 走到这里说明当前要么偏向别的线程，要么是匿名偏向（即没有偏向任何线程）

          //构建一个匿名偏向的mark word，尝试用CAS指令替换掉锁对象的mark word
          markOop header = (markOop) ((uintptr_t) mark & ((uintptr_t)markOopDesc::biased_lock_mask_in_place | (uintptr_t)markOopDesc::age_mask_in_place |
                                                          epoch_mask_in_place));


          if (hash != markOopDesc::no_hash) {
            header = header->copy_set_hash(hash);
          }

          // 线程偏向这个线程
          markOop new_header = (markOop) ((uintptr_t) header | thread_ident);
          // 调试信息 
          DEBUG_ONLY(entry->lock()->set_displaced_header((markOop) (uintptr_t) 0xdeaddead);)
          if (Atomic::cmpxchg_ptr((void*)new_header, lockee->mark_addr(), header) == header) {
            // CAS修改成功  
            if (PrintBiasedLockingStatistics)
              (* BiasedLocking::anonymously_biased_lock_entry_count_addr())++;
          }
          else {
            // 如果修改失败说明存在多线程竞争，所以进入monitorenter方法
            CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);
          }
          success = true;
        }
      }

      // 轻量级锁
      // traditional lightweight locking
      // 如果偏向线程不是当前线程或没有开启偏向模式等原因都会导致success==false
      if (!success) {
        //  构造一个无锁状态的Displaced Mark Word，并将 Lock Record 的lock指向它
        markOop displaced = lockee->mark()->set_unlocked();
        entry->lock()->set_displaced_header(displaced);

        bool call_vm = UseHeavyMonitors;
        if (call_vm || Atomic::cmpxchg_ptr(entry, lockee->mark_addr(), displaced) != displaced) {
          // Is it simple recursive case?
          // 如果是锁重入，则直接将 Displaced Mark Word 设置为null
          if (!call_vm && THREAD->is_lock_owned((address) displaced->clear_lock_bits())) {
            entry->lock()->set_displaced_header(NULL);
          } else {
            CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);
          }
        }
      }
      UPDATE_PC_AND_TOS_AND_CONTINUE(1, -1);
    } else {
      istate->set_msg(more_monitors);
      UPDATE_PC_AND_RETURN(0); // Re-execute
    }
  }

```

偏向级锁 弃用
https://www.zhihu.com/question/288104563
