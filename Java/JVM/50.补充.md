# 字节码解释器

字节码解释器

c++ 语言执行每个指令的过程   涉及的文件: bytecodeInterpreter.cpp

模板解释器

汇编语言执行每个指令的过程    涉及的文件: TemplateInterpreter.cpp   模板文件: templateTable_x84_64.cpp


```c++
CASE(_monitorenter): {

    // 锁对象
    oop lockee = STACK_OBJECT(-1);
    // 非空判断
    CHECK_NULL(lockee);

    // 1. 找到一个空闲的 monitor 或已经为该对象分配的 monitor
    // 如果我们找到匹配的对象, 那么我们需要一个新的 monitor  由于递归输入 
    // if we find a matching object then we need a new monitor since this is recursive enter

    // 调用栈帧中查找一个空闲的 BasicObjectLock, 也就是 Lock Record 
    BasicObjectLock* limit = istate->monitor_base();
    BasicObjectLock* most_recent = (BasicObjectLock*) istate->stack_base();
    BasicObjectLock* entry = NULL;
    while (most_recent != limit ) {
      if (most_recent->obj() == NULL) 
        entry = most_recent;
      else if (most_recent->obj() == lockee) 
        break;
      most_recent++;
    }

    // entry不为null，代表还有空闲的Lock Record  
    if (entry != NULL) {
      // 将 entry 的 obj 属性设置为当前的锁对象
      entry->set_obj(lockee);
      int success = false;
      uintptr_t epoch_mask_in_place = (uintptr_t)markOopDesc::epoch_mask_in_place;

      // 获取锁对象的 mark word
      markOop mark = lockee->mark();
      intptr_t hash = (intptr_t) markOopDesc::no_hash;

      // 锁对象的 mark word 的状态是偏向模式
      if (mark->has_bias_pattern()) {
        uintptr_t thread_ident;
        uintptr_t anticipated_bias_locking_value;

        // 当前的线程 ID
        thread_ident = (uintptr_t)istate->thread();

        // 获取到 锁对象的 class 的属性头, 正常情况下和锁对象的对象头一样，除了年龄代为 4 个 0 外
        // | 有 1 就是 1, 变成了 线程 Id + class 的 epoch + class 年龄代 + 偏向锁标志 + 锁标志
        // ^ 上面的结果和当前锁对象的 mark word 异或, 相等位变为 0, 不相等为 1
        // markOopDesc::age_mask_in_place 等于 0...1111000, 取反后为 1...0000111
        // 将上面 2 步的结果进行与, 
        
        anticipated_bias_locking_value =
          (((uintptr_t)lockee->klass()->prototype_header() | thread_ident) ^ (uintptr_t)mark) &
          ~((uintptr_t) markOopDesc::age_mask_in_place);

        // 如果偏向的线程是自己 且 epoch 等于 class 对象的 epoch
        if  (anticipated_bias_locking_value == 0) {
          // 已经偏向了这个线程, 不需要做其他事情了
          // 如果开启了偏向锁分析
          if (PrintBiasedLockingStatistics) {
              // 偏向锁获取次数 + 1
            (* BiasedLocking::biased_lock_entry_count_addr())++;
          }
          // 偏向锁处理成功
          success = true;
        }

        // 如果偏向模式关闭，则尝试撤销偏向锁
        else if ((anticipated_bias_locking_value & markOopDesc::biased_lock_mask_in_place) != 0) {
          
          // 获取当前 class 对象的 对象头
          markOop header = lockee->klass()->prototype_header();
          // 设置 hash , 这时候这个 header 没了年龄代信息?
          if (hash != markOopDesc::no_hash) {
            header = header->copy_set_hash(hash);
          }

          // 通过 CAS 将 锁对象的 mark word 从 mark  设置 为 header 
          if (Atomic::cmpxchg_ptr(header, lockee->mark_addr(), mark) == mark) {
            // 
            if (PrintBiasedLockingStatistics)
              // 锁撤销次数 + 1
              (*BiasedLocking::revoked_lock_entry_count_addr())++;
          }

        }
        // 如果 锁对象的 epoch 不等于 class 中的 epoch, 则尝试重偏向
        else if ((anticipated_bias_locking_value & epoch_mask_in_place) !=0) {
          // 构造一个偏向当前线程的mark word
          markOop new_header = (markOop) ( (intptr_t) lockee->klass()->prototype_header() | thread_ident);

          // 设置 hash
          if (hash != markOopDesc::no_hash) {
            new_header = new_header->copy_set_hash(hash);
          }

          // CAS替换对象头的 为新的 mark word
          if (Atomic::cmpxchg_ptr((void*)new_header, lockee->mark_addr(), mark) == mark) {
            if (PrintBiasedLockingStatistics)
              // 重偏向次数 + 1
              (* BiasedLocking::rebiased_lock_entry_count_addr())++;
          }
          else {
              // 重偏向失败，代表存在多线程竞争，则调用 InterpreterRuntime:;monitorenter 方法进行锁升级
            CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);
          }
          success = true;
        }
        else {


          // 走到这里说明当前要么偏向别的线程，要么是匿名偏向 (即没有偏向任何线程)

          //构建一个匿名偏向的mark word，尝试用CAS指令替换掉锁对象的mark word
          markOop header = (markOop) ((uintptr_t) mark & ((uintptr_t)markOopDesc::biased_lock_mask_in_place | (uintptr_t)markOopDesc::age_mask_in_place |
                                                          epoch_mask_in_place));


          if (hash != markOopDesc::no_hash) {
            header = header->copy_set_hash(hash);
          }

          // 线程偏向这个线程
          markOop new_header = (markOop) ((uintptr_t) header | thread_ident);

          // 调试信息 
          DEBUG_ONLY(entry->lock()->set_displaced_header((markOop) (uintptr_t) 0xdeaddead);)


          if (Atomic::cmpxchg_ptr((void*)new_header, lockee->mark_addr(), header) == header) {
            // CAS修改成功  
            if (PrintBiasedLockingStatistics)
              // 匿名偏向锁次数 + 1
              (* BiasedLocking::anonymously_biased_lock_entry_count_addr())++;
          }
          else {
            // 如果修改失败说明存在多线程竞争，所以进入InterpreterRuntime::monitorenter 方法进行锁升级
            CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);
          }
          success = true;
        }
      }

      // 传统轻量级锁实现
      // 如果没有开启偏向模式等原因都会导致 success == false
      if (!success) {
        //  构造一个无锁状态的 Displaced Mark Word, 并将 Lock Record 的 lock 指向它
        markOop displaced = lockee->mark()->set_unlocked();
        entry->lock()->set_displaced_header(displaced);

        bool call_vm = UseHeavyMonitors;

        //如果指定了 -XX:+UseHeavyMonitors, 则 call_vm = true, 代表禁用偏向锁和轻量级锁
        if (call_vm || Atomic::cmpxchg_ptr(entry, lockee->mark_addr(), displaced) != displaced) {

          // 如果是锁重入，则直接将 Displaced Mark Word 设置为 null, 最外层可以找到对象信息
          if (!call_vm && THREAD->is_lock_owned((address) displaced->clear_lock_bits())) {
            entry->lock()->set_displaced_header(NULL);
          } else {
            CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);
          }
        }
      }
      // 下一个指令
      UPDATE_PC_AND_TOS_AND_CONTINUE(1, -1);
    } else {
      istate->set_msg(more_monitors);
      UPDATE_PC_AND_RETURN(0); // Re-execute
    }
  }

```

偏向级锁 弃用
https://www.zhihu.com/question/288104563


jdk6默认开启偏向锁, 4秒后 启用偏向锁状态

几个调优参数

-XX:+UseHeavyMonitors  只使用重量锁
-XX:+/- UseBiasedLocking  启用/关闭 偏向锁, JDK 6 后默认为启用状态
-XX:BiasedLockingStartupDelay=0  //关闭延迟开启偏向锁

在虚拟机启动后的 BiasedLockingStartupDelay 毫秒内, 创建的对象都是无锁状态
BiasedLockingStartupDelay 毫秒后创建的对象，包括 Class 对象, 默认都是 匿名偏向, 也就是偏向锁状态, 但是锁的线程 ID 为 0


hash 会导致锁升级