# 字节码解释器

字节码解释器

c++ 语言执行每个指令的过程   涉及的文件: bytecodeInterpreter.cpp

模板解释器

汇编语言执行每个指令的过程    涉及的文件: TemplateInterpreter.cpp   模板文件: templateTable_x84_64.cpp


```c++
CASE(_monitorenter): {

    // 锁对象
    oop lockee = STACK_OBJECT(-1);
    // 非空判断
    CHECK_NULL(lockee);

    // 1. 找到一个空闲的 monitor 或已经为该对象分配的 monitor
    // 如果我们找到匹配的对象, 那么我们需要一个新的 monitor  由于递归输入 
    // if we find a matching object then we need a new monitor since this is recursive enter

    // 调用栈帧中查找一个空闲的 BasicObjectLock, 也就是 Lock Record 
    BasicObjectLock* limit = istate->monitor_base();
    BasicObjectLock* most_recent = (BasicObjectLock*) istate->stack_base();
    BasicObjectLock* entry = NULL;
    while (most_recent != limit ) {
      if (most_recent->obj() == NULL) 
        entry = most_recent;
      else if (most_recent->obj() == lockee) 
        break;
      most_recent++;
    }

    // entry不为null，代表还有空闲的Lock Record  
    if (entry != NULL) {
      // 将 entry 的 obj 属性设置为当前的锁对象
      entry->set_obj(lockee);
      int success = false;
      uintptr_t epoch_mask_in_place = (uintptr_t)markOopDesc::epoch_mask_in_place;

      // 获取锁对象的 mark word
      markOop mark = lockee->mark();
      intptr_t hash = (intptr_t) markOopDesc::no_hash;

      // 锁对象的 mark word 的状态是偏向模式
      if (mark->has_bias_pattern()) {
        uintptr_t thread_ident;
        uintptr_t anticipated_bias_locking_value;

        // 当前的线程 ID
        thread_ident = (uintptr_t)istate->thread();

        // 获取到 锁对象的 class 的属性头, 正常情况下和锁对象的对象头一样，除了年龄代为 4 个 0 外
        // | 有 1 就是 1, 变成了 线程 Id + class 的 epoch + class 年龄代 + 偏向锁标志 + 锁标志
        // ^ 上面的结果和当前锁对象的 mark word 异或, 相等位变为 0, 不相等为 1
        // markOopDesc::age_mask_in_place 等于 0...1111000, 取反后为 1...0000111
        // 将上面 2 步的结果进行与, 
        
        anticipated_bias_locking_value =
          (((uintptr_t)lockee->klass()->prototype_header() | thread_ident) ^ (uintptr_t)mark) &
          ~((uintptr_t) markOopDesc::age_mask_in_place);

        // 如果偏向的线程是自己 且 epoch 等于 class 对象的 epoch
        if  (anticipated_bias_locking_value == 0) {
          // 已经偏向了这个线程, 不需要做其他事情了
          // 如果开启了偏向锁分析
          if (PrintBiasedLockingStatistics) {
              // 偏向锁获取次数 + 1
            (* BiasedLocking::biased_lock_entry_count_addr())++;
          }
          // 偏向锁处理成功
          success = true;
        }

        // 如果偏向模式关闭，则尝试撤销偏向锁
        else if ((anticipated_bias_locking_value & markOopDesc::biased_lock_mask_in_place) != 0) {
          
          // 获取当前 class 对象的 对象头
          markOop header = lockee->klass()->prototype_header();
          // 设置 hash , 这时候这个 header 没了年龄代信息?
          if (hash != markOopDesc::no_hash) {
            header = header->copy_set_hash(hash);
          }

          // 通过 CAS 将 锁对象的 mark word 从 mark  设置 为 header 
          if (Atomic::cmpxchg_ptr(header, lockee->mark_addr(), mark) == mark) {
            // 
            if (PrintBiasedLockingStatistics)
              // 锁撤销次数 + 1
              (*BiasedLocking::revoked_lock_entry_count_addr())++;
          }

        }
        // 如果 锁对象的 epoch 不等于 class 中的 epoch, 则尝试重偏向
        else if ((anticipated_bias_locking_value & epoch_mask_in_place) !=0) {
          // 构造一个偏向当前线程的mark word
          markOop new_header = (markOop) ( (intptr_t) lockee->klass()->prototype_header() | thread_ident);

          // 设置 hash
          if (hash != markOopDesc::no_hash) {
            new_header = new_header->copy_set_hash(hash);
          }

          // CAS替换对象头的 为新的 mark word
          if (Atomic::cmpxchg_ptr((void*)new_header, lockee->mark_addr(), mark) == mark) {
            if (PrintBiasedLockingStatistics)
              // 重偏向次数 + 1
              (* BiasedLocking::rebiased_lock_entry_count_addr())++;
          }
          else {
              // 重偏向失败，代表存在多线程竞争，则调用 InterpreterRuntime:;monitorenter 方法进行锁升级
            CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);
          }
          success = true;
        }
        else {


          // 走到这里说明当前要么偏向别的线程，要么是匿名偏向 (即没有偏向任何线程)

          //构建一个匿名偏向的mark word，尝试用CAS指令替换掉锁对象的mark word
          markOop header = (markOop) ((uintptr_t) mark & ((uintptr_t)markOopDesc::biased_lock_mask_in_place | (uintptr_t)markOopDesc::age_mask_in_place |
                                                          epoch_mask_in_place));

          if (hash != markOopDesc::no_hash) {
            header = header->copy_set_hash(hash);
          }

          // 线程偏向这个线程
          markOop new_header = (markOop) ((uintptr_t) header | thread_ident);

          // 调试信息 
          DEBUG_ONLY(entry->lock()->set_displaced_header((markOop) (uintptr_t) 0xdeaddead);)


          if (Atomic::cmpxchg_ptr((void*)new_header, lockee->mark_addr(), header) == header) {
            // CAS修改成功  
            if (PrintBiasedLockingStatistics)
              // 匿名偏向锁次数 + 1
              (* BiasedLocking::anonymously_biased_lock_entry_count_addr())++;
          }
          else {
            // 如果修改失败说明存在多线程竞争，所以进入InterpreterRuntime::monitorenter 方法进行锁升级
            CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);
          }
          success = true;
        }
      }

      // 传统轻量级锁实现
      // 如果没有开启偏向模式等原因都会导致 success == false
      if (!success) {
        //  构造一个无锁状态的 Displaced Mark Word, 并将 Lock Record 的 lock 指向它
        markOop displaced = lockee->mark()->set_unlocked();
        entry->lock()->set_displaced_header(displaced);

        bool call_vm = UseHeavyMonitors;

        //如果指定了 -XX:+UseHeavyMonitors, 则 call_vm = true, 代表禁用偏向锁和轻量级锁
        // CAS 失败了
        if (call_vm || Atomic::cmpxchg_ptr(entry, lockee->mark_addr(), displaced) != displaced) {

           // 启用了偏向锁同时 从锁对象获取的 mark word 所在的位置指向的 Lock Record 所在的线程为当前线程
          if (!call_vm && THREAD->is_lock_owned((address) displaced->clear_lock_bits())) {
            // 锁重入，则直接将 Displaced Mark Word 设置为 null, 最外层可以找到对象信息, 轻量级锁处说明原因
            entry->lock()->set_displaced_header(NULL);
          } else {
            // 锁竞争, 锁升级
            CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);
          }
        }
      }
      // 下一个指令
      UPDATE_PC_AND_TOS_AND_CONTINUE(1, -1);
    } else {
      istate->set_msg(more_monitors);
      UPDATE_PC_AND_RETURN(0); // Re-execute
    }
  }

```


偏向锁的撤销和释放

撤销: 获取偏向锁的过程因为不满足条件导致要将锁对象改为非偏向锁状态
释放: 指退出同步块时的过程，释放锁



非 VM Thread 获取偏向锁失败:
InterpreterRuntime::monitorenter 
--> ObjectSynchronizer::fast_enter(h_obj, elem->lock(), true, CHECK)
--> BiasedLocking::revoke_and_rebias(obj, attempt_rebias, THREAD)

```C++

BiasedLocking::Condition BiasedLocking::revoke_and_rebias(Handle obj, bool attempt_rebias, TRAPS) {

    // SafepointSynchronize::is_at_safepoint 所有的线程都停在一个安全点上, 只有 VM Thread 在运行
    // 不能在安全点进行操作, 防止 VM Thread 执行下面的逻辑
    assert(!SafepointSynchronize::is_at_safepoint(), "must not be called while at safepoint");
    
    // 获取锁对象的 markOop 
    markOop mark = obj->mark();
    
    // 匿名偏向锁, attempt_rebias: 上游推送过来的, 默认为true
    if (mark->is_biased_anonymously() && !attempt_rebias) {
        // 如果是匿名偏向且 attempt_rebias == false 会走到这里，
        // 如锁对象的 hashcode 方法被调用会出现这种情况，需要撤销偏向锁。
        
        markOop biased_value       = mark;
        
        // 未偏向锁 mark work
        markOop unbiased_prototype = markOopDesc::prototype()->set_age(mark->age());
        // CAS 锁对象的 mark work 为 无锁
        markOop res_mark = (markOop) Atomic::cmpxchg_ptr(unbiased_prototype, obj->mark_addr(), mark);
        if (res_mark == biased_value) {
          return BIAS_REVOKED;
        }
    // 开启了偏向锁   
    } else if (mark->has_bias_pattern()) {
        // 锁对象开启了偏向模式会走到这里
        Klass* k = obj->klass();
        markOop prototype_header = k->prototype_header();
        // 如果对应 class 关闭了偏向模式
        if (!prototype_header->has_bias_pattern()) {
        
          markOop biased_value       = mark;
          markOop res_mark = (markOop) Atomic::cmpxchg_ptr(prototype_header, obj->mark_addr(), mark);
          assert(!(*(obj->mark_addr()))->has_bias_pattern(), "even if we raced, should still be revoked");
          return BIAS_REVOKED;
          
         //code2： 如果epoch过期
        } else if (prototype_header->bias_epoch() != mark->bias_epoch()) {
        
            // 是否为重偏向 
            if (attempt_rebias) {
            
                assert(THREAD->is_Java_thread(), "");
                
                markOop biased_value       = mark;
                // 重建一个新的 epoch 相同, 并且偏向当前线程的 mark word 
                markOop rebiased_prototype = markOopDesc::encode((JavaThread*) THREAD, mark->age(), prototype_header->bias_epoch());
                // 重试设置新的偏向锁
                markOop res_mark = (markOop) Atomic::cmpxchg_ptr(rebiased_prototype, obj->mark_addr(), mark);
                if (res_mark == biased_value) {
                  return BIAS_REVOKED_AND_REBIASED;
                }
            } else {
                // 设置为无锁状态
                markOop biased_value       = mark;
                markOop unbiased_prototype = markOopDesc::prototype()->set_age(mark->age());
                markOop res_mark = (markOop) Atomic::cmpxchg_ptr(unbiased_prototype, obj->mark_addr(), mark);
                if (res_mark == biased_value) {
                    return BIAS_REVOKED;
                }
            }
        }
    }
    
    //code 3：批量重偏向与批量撤销的逻辑
    HeuristicsResult heuristics = update_heuristics(obj(), attempt_rebias);
    if (heuristics == HR_NOT_BIASED) {
        return NOT_BIASED;
    } else if (heuristics == HR_SINGLE_REVOKE) {
        //code 4：撤销单个线程
        Klass *k = obj->klass();
        markOop prototype_header = k->prototype_header();
        
        if (mark->biased_locker() == THREAD && prototype_header->bias_epoch() == mark->bias_epoch()) {
        
            // 走到这里说明需要撤销的是偏向当前线程的锁，当调用 Object#hashcode 方法时会走到这一步
            // 因为只要遍历当前线程的栈就好了，所以不需要等到 safepoint 再撤销。
            ResourceMark rm;
            if (TraceBiasedLocking) {
                tty->print_cr("Revoking bias by walking my own stack:");
            }
            
            // 调用方法
            BiasedLocking::Condition cond = revoke_bias(obj(), false, false, (JavaThread*) THREAD);
            ((JavaThread*) THREAD)->set_cached_monitor_info(NULL);
            assert(cond == BIAS_REVOKED, "why not?");
            return cond;
            
        } else {
            // 下面代码最终会在VM线程中的 safepoint 调用 revoke_bias 方法, 类似于注册事件
            VM_RevokeBias revoke(&obj, (JavaThread*) THREAD);
            VMThread::execute(&revoke);
            return revoke.status_code();
        }
    
    }
    
    assert((heuristics == HR_BULK_REVOKE) || (heuristics == HR_BULK_REBIAS), "?");
    
    //code5：批量撤销、批量重偏向的逻辑
    VM_BulkRevokeBias bulk_revoke(&obj, (JavaThread*) THREAD, (heuristics == HR_BULK_REBIAS), attempt_rebias);
    VMThread::execute(&bulk_revoke);
    return bulk_revoke.status_code();
}
```

会走到该方法的逻辑有很多, 我们只分析最常见的情况: 假设锁已经偏向线程A, 这时B线程尝试获得锁。

上面的code 1, code 2 B线程都不会走到, 最终会走到 code 4 处，如果要撤销的锁偏向的是当前线程则直接调用 revoke_bias 撤销偏向锁, 否则会将该
操作 push 到 VM Thread 中等到 safepoint 的时候再执行。

关于VM Thread这里介绍下：在JVM中有个专门的VM Thread，该线程会源源不断的从VMOperationQueue中取出请求，比如GC请求。对于需要 safepoint 
的操作（VM_Operationevaluate_at_safepoint 返回 true）必须要等到所有的 Java 线程进入到 safepoint 才开始执行


单个线程的锁撤销重点:

```C++
// obj: 锁对象, allow_rebias 为 faslse, is_bulk 为 false requesting_thread 当前线程
static BiasedLocking::Condition revoke_bias(oop obj, bool allow_rebias, bool is_bulk, JavaThread* requesting_thread) {
   
   markOop mark = obj->mark();
  // 如果没有开启偏向模式，则直接返回 NOT_BIASED
  if (!mark->has_bias_pattern()) {
    ...
    return BiasedLocking::NOT_BIASED;
  }
  
  uint age = mark->age();
  // 构建两个mark word，一个是匿名偏向模式（101），一个是无锁模式（001）
  markOop   biased_prototype = markOopDesc::biased_locking_prototype(); 
  markOop unbiased_prototype = markOopDesc::prototype()->set_age(age);

  ...
  
  // 当前的对象的偏向的线程
  JavaThread* biased_thread = mark->biased_locker();
  
  // 为空
  if (biased_thread == NULL) {
     // 匿名偏向。当调用锁对象的hashcode()方法可能会导致走到这个逻辑
     // 如果不允许重偏向，则将对象的mark word设置为无锁模式
    // allow_rebias 为false, 此处变为无锁状态
    if (!allow_rebias) {
      obj->set_mark(unbiased_prototype);
    }
    ...
    return BiasedLocking::BIAS_REVOKED;
  }
  
  // code 1：判断偏向线程是否还存活
  bool thread_is_alive = false;
  // 如果当前线程就是偏向线程 
  if (requesting_thread == biased_thread) {
    thread_is_alive = true;
  } else {
    // 遍历当前jvm的所有线程，如果能找到，则说明偏向的线程还存活
    for (JavaThread* cur_thread = Threads::first(); cur_thread != NULL; cur_thread = cur_thread->next()) {
      if (cur_thread == biased_thread) {
        thread_is_alive = true;
        break;
      }
    }
  }
  
  // 如果偏向的线程已经不存活了
  if (!thread_is_alive) {
    // 允许重偏向则将对象mark word设置为匿名偏向状态，否则设置为无锁状态
    if (allow_rebias) {
      obj->set_mark(biased_prototype);
    } else {
      obj->set_mark(unbiased_prototype);
   }
    ...
    return BiasedLocking::BIAS_REVOKED;
  }
  
  
  // 线程还存活则遍历线程栈中所有的Lock Record
  GrowableArray<MonitorInfo*>* cached_monitor_info = get_or_compute_monitor_info(biased_thread);
  BasicLock* highest_lock = NULL;
  for (int i = 0; i < cached_monitor_info->length(); i++) {
  
    MonitorInfo* mon_info = cached_monitor_info->at(i);
    // 如果能找到对应的 Lock Record 说明偏向的线程还在执行同步代码块中的代码
    // 这个 Lock Record 指向的 obj 是当前锁对象
    if (mon_info->owner() == obj) {
    
      ...
      // 需要升级为轻量级锁，直接修改偏向线程栈中的 Lock Record。
      // 为了处理锁重入的情况，在这里将 Lock Record 的 Displaced Mark Word 设置为 null，
      // 第一个 Lock Record 会在下面的代码中再处理
      
      markOop mark = markOopDesc::encode((BasicLock*) NULL);
      highest_lock = mon_info->lock();
      highest_lock->set_displaced_header(mark);
    } else {
      ...
    }
  }
  
  if (highest_lock != NULL) {
    // 修改第一个Lock Record为无锁状态，然后将obj的mark word设置为指向该Lock Record的指针
    highest_lock->set_displaced_header(unbiased_prototype);
    obj->release_set_mark(markOopDesc::encode(highest_lock));
    ...
  } else {
  
    // 走到这里说明偏向线程已经不在同步块中了
    ...
    if (allow_rebias) {
       //设置为匿名偏向状态
      obj->set_mark(biased_prototype);
    } else {
      // 将mark word设置为无锁状态
      obj->set_mark(unbiased_prototype);
    }
  }
  return BiasedLocking::BIAS_REVOKED;
}
```

需要注意下，当调用锁对象的Object#hash或System.identityHashCode()方法会导致该对象的偏向锁或轻量级锁升级。这是因为在Java中一个对象的 
hashcode是在调用这两个方法时才生成的，如果是无锁状态则存放在mark word中，如果是重量级锁则存放在对应的monitor中，而偏向锁是没有地方能存放该信息的，所以必须升级


言归正传，revoke_bias方法逻辑：

查看偏向的线程是否存活，如果已经不存活了，则直接撤销偏向锁。JVM维护了一个集合存放所有存活的线程，通过遍历该集合判断某个线程是否存活。
偏向的线程是否还在同步块中，如果不在了，则撤销偏向锁。我们回顾一下偏向锁的加锁流程：每次进入同步块（即执行monitorenter）的时候都会以从高往低的顺序在栈中找到第一个可用的Lock Record，将其obj字段指向锁对象。每次解锁（即执行monitorexit）的时候都会将最低的一个相关Lock Record移除掉。所以可以通过遍历线程栈中的Lock Record来判断线程是否还在同步块中。
将偏向线程所有相关Lock Record的Displaced Mark Word设置为null，然后将最高位的Lock Record的Displaced Mark Word 设置为无锁状态，最高位的Lock Record也就是第一次获得锁时的Lock Record（这里的第一次是指重入获取锁时的第一次），然后将对象头指向最高位的Lock Record，这里不需要用CAS指令，因为是在safepoint。 执行完后，就升级成了轻量级锁。原偏向线程的所有Lock Record都已经变成轻量级锁的状态。这里如果看不明白，请回顾上篇文章的轻量级锁加锁过程。


## 偏向锁的释放

```C++
CASE(_monitorexit): {
    oop lockee = STACK_OBJECT(-1);
    CHECK_NULL(lockee);
    
    // find our monitor slot
    BasicObjectLock* limit = istate->monitor_base();
    BasicObjectLock* most_recent = (BasicObjectLock*) istate->stack_base();
    
    // 从低往高遍历栈的Lock Record
    while (most_recent != limit ) {
        // 如果Lock Record关联的是该锁对象
        if ((most_recent)->obj() == lockee) {
            BasicLock* lock = most_recent->lock();
            markOop header = lock->displaced_header();
            // 释放Lock Record
            most_recent->set_obj(NULL);
            
            // 如果是偏向模式，仅仅释放Lock Record就好了。否则要走轻量级锁or重量级锁的释放流程
            if (!lockee->mark()->has_bias_pattern()) {
          
                bool call_vm = UseHeavyMonitors;
                // header!=NULL说明不是重入，则需要将Displaced Mark Word CAS到对象头的Mark Word
                if (header != NULL || call_vm) {
                    if (call_vm || Atomic::cmpxchg_ptr(header, lockee->mark_addr(), lock) != lock) {
                        // CAS失败或者是重量级锁则会走到这里，先将obj还原，然后调用monitorexit方法
                        // InterpreterRuntime::monitorexit方法中。该方法会在轻量级与重量级锁的文章中讲解
                        most_recent->set_obj(lockee);
                        CALL_VM(InterpreterRuntime::monitorexit(THREAD, most_recent), handle_exception);
                    }
                
                }
            }
            //执行下一条命令
            UPDATE_PC_AND_TOS_AND_CONTINUE(1, -1);
        }
        //处理下一条Lock Record
        most_recent++;
    }

    // Need to throw illegal monitor state exception
    CALL_VM(InterpreterRuntime::throw_illegal_monitor_state_exception(THREAD), handle_exception);
    ShouldNotReachHere();
}

```



## 批量重偏向和批量撤销

```C++
BiasedLocking::Condition BiasedLocking::revoke_and_rebias(Handle obj, bool attempt_rebias, TRAPS) {
  ...
  //code 1：重偏向的逻辑
  HeuristicsResult heuristics = update_heuristics(obj(), attempt_rebias);
  // 非重偏向的逻辑
  ...
      
  assert((heuristics == HR_BULK_REVOKE) ||
         (heuristics == HR_BULK_REBIAS), "?");	
   //code 2：批量撤销、批量重偏向的逻辑
  VM_BulkRevokeBias bulk_revoke(&obj, (JavaThread*) THREAD,
                                (heuristics == HR_BULK_REBIAS),
                                attempt_rebias);
  VMThread::execute(&bulk_revoke);
  return bulk_revoke.status_code();
}
```

在每次撤销偏向锁的时候都通过 update_heuristics 方法记录下来，以类为单位，当某个类的对象撤销偏向次数达到一定阈值的时候JVM就认为该类不适合偏
向模式或者需要重新偏向另一个对象，update_heuristics就会返回HR_BULK_REVOKE或HR_BULK_REBIAS。进行批量撤销或批量重偏向

```C++
static HeuristicsResult update_heuristics(oop o, bool allow_rebias) {

    markOop mark = o->mark();
    
    //如果不是偏向模式直接返回
    if (!mark->has_bias_pattern()) {
        return HR_NOT_BIASED;
    }
    
   // 锁对象的类
   Klass* k = o->klass();
   
     // 当前时间
  jlong cur_time = os::javaTimeMillis();
   // 该类上一次批量撤销的时间
  jlong last_bulk_revocation_time = k->last_biased_lock_bulk_revocation_time();
  
    // 该类偏向锁撤销的次数
  int revocation_count = k->biased_lock_revocation_count();
  
    // BiasedLockingBulkRebiasThreshold 是重偏向阈值（默认20），
    // BiasedLockingBulkRevokeThreshold 是批量撤销阈值（默认40），
    // BiasedLockingDecayTime 是开启一次新的批量重偏向距离上次批量重偏向的后的延迟时间，默认 25000。
    // 也就是开启批量重偏向后，经过了一段较长的时间（>=BiasedLockingDecayTime），撤销计数器才超过阈值，那我们会重置计数器。
    
    if ((revocation_count >= BiasedLockingBulkRebiasThreshold) &&
        (revocation_count <  BiasedLockingBulkRevokeThreshold) &&
        (last_bulk_revocation_time != 0) && 
        (cur_time - last_bulk_revocation_time >= BiasedLockingDecayTime)) {
    
        k->set_biased_lock_revocation_count(0);
        revocation_count = 0;
    }
    
    // 自增撤销计数器
  if (revocation_count <= BiasedLockingBulkRevokeThreshold) {
    revocation_count = k->atomic_incr_biased_lock_revocation_count();
  }
  
  // 如果达到批量撤销阈值则返回HR_BULK_REVOKE
  if (revocation_count == BiasedLockingBulkRevokeThreshold) {
    return HR_BULK_REVOKE;
  }
  // 如果达到批量重偏向阈值则返回HR_BULK_REBIAS
  if (revocation_count == BiasedLockingBulkRebiasThreshold) {
    return HR_BULK_REBIAS;
  }
  
  // 没有达到阈值则撤销单个对象的锁
  return HR_SINGLE_REVOKE;

}
```

当达到阈值的时候就会通过VM 线程在safepoint调用bulk_revoke_or_rebias_at_safepoint, 参数bulk_rebias如果是true代表是批量重偏向否则为批量撤销。attempt_rebias_of_object代表对操作的锁对象o是否运行重偏向，这里是true

```C++
static BiasedLocking::Condition bulk_revoke_or_rebias_at_safepoint(oop o,
                                                                   bool bulk_rebias,
                                                                   bool attempt_rebias_of_object,
                                                                   JavaThread* requesting_thread) {
 
    jlong cur_time = os::javaTimeMillis();
    o->klass()->set_last_biased_lock_bulk_revocation_time(cur_time);                                                                  
    
    Klass* k_o = o->klass();
    Klass* klass = k_o;    
    
    
    if (bulk_rebias) {
        // 批量重偏向的逻辑
        if (klass->prototype_header()->has_bias_pattern()) {
            // 自增前类中的的epoch
            int prev_epoch = klass->prototype_header()->bias_epoch();
            // code 1：类中的epoch自增
            klass->set_prototype_header(klass->prototype_header()->incr_bias_epoch());
            
            int cur_epoch = klass->prototype_header()->bias_epoch();
            
            // code 2：遍历所有线程的栈，更新类型为该klass的所有锁实例的epoch
            for (JavaThread* thr = Threads::first(); thr != NULL; thr = thr->next()) {
                GrowableArray<MonitorInfo*>* cached_monitor_info = get_or_compute_monitor_info(thr);
                for (int i = 0; i < cached_monitor_info->length(); i++) {
                    MonitorInfo* mon_info = cached_monitor_info->at(i);
                      oop owner = mon_info->owner();
                      markOop mark = owner->mark();
                      
                    if ((owner->klass() == k_o) && mark->has_bias_pattern()) {
                                    // 在递归锁定的情况下，我们可能已经遇到了这个对象
                        assert(mark->bias_epoch() == prev_epoch || mark->bias_epoch() == cur_epoch, "error in bias epoch adjustment");
                        owner->set_mark(mark->set_bias_epoch(cur_epoch));
                    }  
                
               
                }
            
            
            }
        }
        
        // 接下来对当前锁对象进行重偏向
        revoke_bias(o, attempt_rebias_of_object && klass->prototype_header()->has_bias_pattern(), true, requesting_thread);
        
    }  else { 
    
        ...

        // code 3：批量撤销的逻辑，将类中的偏向标记关闭，markOopDesc::prototype() 返回的是一个关闭偏向模式的prototype
        klass->set_prototype_header(markOopDesc::prototype());
    
        // code 4：遍历所有线程的栈，撤销该类所有锁的偏向
        for (JavaThread* thr = Threads::first(); thr != NULL; thr = thr->next()) {
          GrowableArray<MonitorInfo*>* cached_monitor_info = get_or_compute_monitor_info(thr);
          for (int i = 0; i < cached_monitor_info->length(); i++) {
            MonitorInfo* mon_info = cached_monitor_info->at(i);
            oop owner = mon_info->owner();
            markOop mark = owner->mark();
            if ((owner->klass() == k_o) && mark->has_bias_pattern()) {
              revoke_bias(owner, false, true, requesting_thread);
            }
          }
        }
    
        // 撤销当前锁对象的偏向模式
        revoke_bias(o, false, true, requesting_thread);
    }   
    
    
    
    BiasedLocking::Condition status_code = BiasedLocking::BIAS_REVOKED;

      if (attempt_rebias_of_object &&
          o->mark()->has_bias_pattern() &&
          klass->prototype_header()->has_bias_pattern()) {
        // 构造一个偏向请求线程的mark word
        markOop new_mark = markOopDesc::encode(requesting_thread, o->mark()->age(),
                                               klass->prototype_header()->bias_epoch());
        // 更新当前锁对象的mark word
        o->set_mark(new_mark);
        status_code = BiasedLocking::BIAS_REVOKED_AND_REBIASED;
        ...
      }
    
      ...
    
      return status_code;                                                                                                                                                                                         
}
```


该方法分为两个逻辑：批量重偏向和批量撤销。

先看批量重偏向，分为两步：

code 1 将类中的撤销计数器自增1，之后当该类已存在的实例获得锁时，就会尝试重偏向，相关逻辑在偏向锁获取流程小节中。

code 2 处理当前正在被使用的锁对象，通过遍历所有存活线程的栈，找到所有正在使用的偏向锁对象，然后更新它们的epoch值。也就是说不会重偏向正在使用的锁，否则会破坏锁的线程安全性。

批量撤销逻辑如下：

code 3将类的偏向标记关闭，之后当该类已存在的实例获得锁时，就会升级为轻量级锁；该类新分配的对象的mark word则是无锁模式。

code 4处理当前正在被使用的锁对象，通过遍历所有存活线程的栈，找到所有正在使用的偏向锁对象，然后撤销偏向锁。



## 轻量级锁

重入时，会新增一个新的 Lock Record 但是他的 Displaced Mark Word 为空


```C++
void ObjectSynchronizer::slow_enter(Handle obj, BasicLock* lock, TRAPS) {
  markOop mark = obj->mark();
  assert(!mark->has_bias_pattern(), "should not see bias pattern here");
  
  // 如果是无锁状态
  if (mark->is_neutral()) {
    //设置Displaced Mark Word并替换对象头的mark word
    lock->set_displaced_header(mark);
    if (mark == (markOop) Atomic::cmpxchg_ptr(lock, obj()->mark_addr(), mark)) {
      TEVENT (slow_enter: release stacklock) ;
      return ;
    }
  } else
  if (mark->has_locker() && THREAD->is_lock_owned((address)mark->locker())) {
    assert(lock != mark->locker(), "must not re-lock the same lock");
    assert(lock != (BasicLock*)obj->mark(), "don't relock with same BasicLock");
    // 如果是重入，则设置Displaced Mark Word为null
    lock->set_displaced_header(NULL);
    return;
  }

  ...
  // 走到这一步说明已经是存在多个线程竞争锁了 需要膨胀为重量级锁
  lock->set_displaced_header(markOopDesc::unused_mark());
  ObjectSynchronizer::inflate(THREAD, obj())->enter(THREAD);
}
```


释放

InterpreterRuntime::monitorexit

```C++
IRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorexit(JavaThread* thread, BasicObjectLock* elem))
 
  Handle h_obj(thread, elem->obj());
  ...
  ObjectSynchronizer::slow_exit(h_obj(), elem->lock(), thread);
  // Free entry. This must be done here, since a pending exception might be installed on
  //释放Lock Record
  elem->set_obj(NULL);
  ...
IRT_END
```

slow_exit 是否锁

```C++

void ObjectSynchronizer::slow_exit(oop object, BasicLock* lock, TRAPS) {
  fast_exit (object, lock, THREAD) ;
}

void ObjectSynchronizer::fast_exit(oop object, BasicLock* lock, TRAPS) {
  ...
  markOop dhw = lock->displaced_header();
  markOop mark ;
  if (dhw == NULL) {
     // 重入锁，什么也不做
   	 ...
     return ;
  }

  mark = object->mark() ;

  // 如果是mark word==Displaced Mark Word即轻量级锁，CAS替换对象头的mark word
  if (mark == (markOop) lock) {
     assert (dhw->is_neutral(), "invariant") ;
     if ((markOop) Atomic::cmpxchg_ptr (dhw, object->mark_addr(), mark) == mark) {
        TEVENT (fast_exit: release stacklock) ;
        return;
     }
  }
  //走到这里说明是重量级锁或者解锁时发生了竞争，膨胀后调用重量级锁的exit方法。
  ObjectSynchronizer::inflate(THREAD, object)->exit (true, THREAD) ;
}
```

该方法中先判断是不是轻量级锁，如果是轻量级锁则将替换mark word，否则膨胀为重量级锁并调用exit方法，相关逻辑将在重量级锁的文章中讲解。

## 重量级锁

当出现多个线程同时竞争锁时，会进入到synchronizer.cpp#slow_enter方法
```C++
void ObjectSynchronizer::slow_enter(Handle obj, BasicLock* lock, TRAPS) {

   markOop mark = obj->mark();
   assert(!mark->has_bias_pattern(), "should not see bias pattern here");
   
   // 如果是无锁状态
  if (mark->is_neutral()) {
    lock->set_displaced_header(mark);
    if (mark == (markOop) Atomic::cmpxchg_ptr(lock, obj()->mark_addr(), mark)) {
      TEVENT (slow_enter: release stacklock) ;
      return ;
    }
    // Fall through to inflate() ...
  } else {
    // 如果是轻量级锁重入
    if (mark->has_locker() && THREAD->is_lock_owned((address)mark->locker())) {
        assert(lock != mark->locker(), "must not re-lock the same lock");
        assert(lock != (BasicLock*)obj->mark(), "don't relock with same BasicLock");
        lock->set_displaced_header(NULL);
        return;
    }
    
    // 这时候需要膨胀为重量级锁，膨胀前，设置Displaced Mark Word为一个特殊值，代表该锁正在用一个重量级锁的monitor
      lock->set_displaced_header(markOopDesc::unused_mark());
      //先调用inflate膨胀为重量级锁，该方法返回一个ObjectMonitor对象，然后调用其enter方法
      ObjectSynchronizer::inflate(THREAD, obj())->enter(THREAD);
  }
}
```

```C++
ObjectMonitor * ATTR ObjectSynchronizer::inflate (Thread * Self, oop object) {

         ...

    for (;;) {
    
      const markOop mark = object->mark() ;
      assert (!mark->has_bias_pattern(), "invariant") ;
    
      // mark是以下状态中的一种：
      // *  Inflated（重量级锁状态）     - 直接返回
      // *  Stack-locked（轻量级锁状态） - 膨胀
      // *  INFLATING（膨胀中）    - 忙等待直到膨胀完成
      // *  Neutral（无锁状态）      - 膨胀
      // *  BIASED（偏向锁）       - 非法状态，在这里不会出现

      // CASE: inflated
      if (mark->has_monitor()) {
          // 已经是重量级锁状态了，直接返回
          ObjectMonitor * inf = mark->monitor() ;
          assert (inf->header()->is_neutral(), "invariant");
          assert (inf->object() == object, "invariant") ;
          assert (ObjectSynchronizer::verify_objmon_isinpool(inf), "monitor is invalid");
          return inf ;
      }

      // CASE: inflation in progress

      if (mark == markOopDesc::INFLATING()) {
         // 正在膨胀中，说明另一个线程正在进行锁膨胀，continue重试
         TEVENT (Inflate: spin while INFLATING) ;
         // 在该方法中会进行spin/yield/park等操作完成自旋动作 
         ReadStableMark(object) ;
         continue ;
      }
 
      if (mark->has_locker()) {
          // 当前轻量级锁状态，先分配一个ObjectMonitor对象，并初始化值
          ObjectMonitor * m = omAlloc (Self) ;
          
          m->Recycle();
          m->_Responsible  = NULL ;
          m->OwnerIsThread = 0 ;
          m->_recursions   = 0 ;
          m->_SpinDuration = ObjectMonitor::Knob_SpinLimit ;   // Consider: maintain by type/class
		  // 将锁对象的mark word设置为INFLATING (0)状态 
          markOop cmp = (markOop) Atomic::cmpxchg_ptr (markOopDesc::INFLATING(), object->mark_addr(), mark) ;
          if (cmp != mark) {
             omRelease (Self, m, true) ;
             continue ;       // Interference -- just retry
          }

          // 栈中的displaced mark word
          markOop dmw = mark->displaced_mark_helper() ;
          assert (dmw->is_neutral(), "invariant") ;

          // 设置monitor的字段
          m->set_header(dmw) ;
          // owner为Lock Record
          m->set_owner(mark->locker());
          m->set_object(object);
          ...
          // 将锁对象头设置为重量级锁状态
          object->release_set_mark(markOopDesc::encode(m));

         ...
          return m ;
      }

      // CASE: neutral
  	 
      // 分配以及初始化ObjectMonitor对象
      ObjectMonitor * m = omAlloc (Self) ;
      // prepare m for installation - set monitor to initial state
      m->Recycle();
      m->set_header(mark);
      // owner为NULL
      m->set_owner(NULL);
      m->set_object(object);
      m->OwnerIsThread = 1 ;
      m->_recursions   = 0 ;
      m->_Responsible  = NULL ;
      // consider: keep metastats by type/class
      m->_SpinDuration = ObjectMonitor::Knob_SpinLimit ;       
	  // 用CAS替换对象头的mark word为重量级锁状态
      if (Atomic::cmpxchg_ptr (markOopDesc::encode(m), object->mark_addr(), mark) != mark) {
          // 不成功说明有另外一个线程在执行inflate，释放monitor对象
          m->set_object (NULL) ;
          m->set_owner  (NULL) ;
          m->OwnerIsThread = 0 ;
          m->Recycle() ;
          omRelease (Self, m, true) ;
          m = NULL ;
          continue ;
          // interference - the markword changed - just retry.
          // The state-transitions are one-way, so there's no chance of
          // live-lock -- "Inflated" is an absorbing state.
      }

      ...
      return m ;
  }
}
```

1.已经是重量级状态，说明膨胀已经完成，直接返回

2.如果是轻量级锁则需要进行膨胀操作

3.如果是膨胀中状态，则进行忙等待

4.如果是无锁状态则需要进行膨胀操作

其中轻量级锁和无锁状态需要进行膨胀操作，轻量级锁膨胀流程如下：

1.调用omAlloc分配一个ObjectMonitor对象(以下简称monitor)，在omAlloc方法中会先从线程私有的monitor集合omFreeList中分配对象，如果omFreeList中已经没有monitor对象，则从JVM全局的gFreeList中分配一批monitor到omFreeList中。

2.初始化monitor对象

3.将状态设置为膨胀中（INFLATING）状态

4.设置monitor的header字段为displaced mark word，owner字段为Lock Record，obj字段为锁对象

5.设置锁对象头的mark word为重量级锁状态，指向第一步分配的monitor对象

无锁状态下的膨胀流程如下：

1.调用omAlloc分配一个ObjectMonitor对象(以下简称monitor)

2.初始化monitor对象

3.设置monitor的header字段为 mark word，owner字段为null，obj字段为锁对象

4.设置锁对象头的mark word为重量级锁状态，指向第一步分配的monitor对象


至于为什么轻量级锁需要一个膨胀中（INFLATING）状态，代码中的注释是：

膨胀完成之后，会调用enter方法获得锁

```C++
void ATTR ObjectMonitor::enter(TRAPS) {

    Thread * const Self = THREAD ;
  void * cur ;
  // owner为null代表无锁状态，如果能CAS设置成功，则当前线程直接获得锁
  cur = Atomic::cmpxchg_ptr (Self, &_owner, NULL) ;
  if (cur == NULL) {
     ...
     return ;
  }
  
  // 如果是重入的情况
  if (cur == Self) {
     _recursions ++ ;
     return ;
  }
  
  // 当前线程是之前持有轻量级锁的线程。由轻量级锁膨胀且第一次调用enter方法，那cur是指向Lock Record的指针
  if (Self->is_lock_owned ((address)cur)) {
    assert (_recursions == 0, "internal state error");
    // 重入计数重置为1
    _recursions = 1 ;
    // 设置owner字段为当前线程（之前owner是指向Lock Record的指针）
    _owner = Self ;
    OwnerIsThread = 1 ;
    return ;
  }
  
    // 在调用系统的同步操作之前，先尝试自旋获得锁
  if (Knob_SpinEarly && TrySpin (Self) > 0) {
     ...
     //自旋的过程中获得了锁，则直接返回
     Self->_Stalled = 0 ;
     return ;
  }
  
  
    assert (_owner != Self          , "invariant") ;
  assert (_succ  != Self          , "invariant") ;
  assert (Self->is_Java_thread()  , "invariant") ;
  JavaThread * jt = (JavaThread *) Self ;
  assert (!SafepointSynchronize::is_at_safepoint(), "invariant") ;
  assert (jt->thread_state() != _thread_blocked   , "invariant") ;
  assert (this->object() != NULL  , "invariant") ;
  assert (_count >= 0, "invariant") ;
  
  
  EventJavaMonitorEnter event;
  
  
  { 
  // Change java thread status to indicate blocked on monitor enter.
    JavaThreadBlockedOnMonitorEnterState jtbmes(jt, this);
    
    DTRACE_MONITOR_PROBE(contended__enter, this, object(), jt);
    if (JvmtiExport::should_post_monitor_contended_enter()) {
      JvmtiExport::post_monitor_contended_enter(jt, this);
      
      // The current thread does not yet own the monitor and does not
      // yet appear on any queues that would get it made the successor.
      // This means that the JVMTI_EVENT_MONITOR_CONTENDED_ENTER event
      // handler cannot accidentally consume an unpark() meant for the
      // ParkEvent associated with this ObjectMonitor.
      
    }
    
    OSThreadContendState osts(Self->osthread());
    ThreadBlockInVM tbivm(jt);

    Self->set_current_pending_monitor(this);
    
    
    for (;;) {
      jt->set_suspend_equivalent();
      
      // 在该方法中调用系统同步操作
      EnterI (THREAD) ;

      if (!ExitSuspendEquivalent(jt)) break ;
      
      
       // We have acquired the contended monitor, but while we were
      // waiting another thread suspended us. We don't want to enter
      // the monitor while suspended because that would surprise the
      // thread that suspended us.
      
      _recursions = 0 ;
      _succ = NULL ;
      exit (false, Self) ;

      jt->java_suspend_self();
      
    }
    
  }
}
```

当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个ObjectWaiter对象插入到cxq的队列的队头，


然后调用park函数挂起当前线程。在linux系统上，park函数底层调用的是gclib库的pthread_cond_wait，JDK的ReentrantLock底层也是用该方法挂起线程的

当线程释放锁时，会从cxq或EntryList中挑选一个线程唤醒，被选中的线程叫做Heir presumptive即假定继承人（应该是这样翻译），就是图中的Ready Thread，假定继承人被唤醒后会尝试获得锁，但synchronized是非公平的，所以假定继承人不一定能获得锁（这也是它叫"假定"继承人的原因）


如果线程获得锁后调用Object#wait方法，则会将线程加入到WaitSet中，当被Object#notify唤醒后，会将线程从WaitSet移动到cxq或EntryList中去。需要注意的是，当调用一个锁对象的wait或notify方法时，如当前锁的状态是偏向锁或轻量级锁则会先膨胀成重量级锁



synchronized的monitor锁机制和JDK的ReentrantLock与Condition是很相似的，ReentrantLock也有一个存放等待获取锁线程的链表，Condition也有一个类似WaitSet的集合用来存放调用了await的线程。如果你之前对ReentrantLock有深入了解，那理解起monitor应该是很简单

```C++
void ATTR ObjectMonitor::EnterI (TRAPS) {
    Thread * Self = THREAD ;
    ...
    // 尝试获得锁
    if (TryLock (Self) > 0) {
        ...
        return ;
    }
    
    
    if (TrySpin (Self) > 0) {
        ...
        return;
    }
    
    // 将线程封装成node节点中, 放到 _cxq
    ObjectWaiter node(Self) ;
    Self->_ParkEvent->reset() ;
    node._prev   = (ObjectWaiter *) 0xBAD ;
    node.TState  = ObjectWaiter::TS_CXQ ;
    // 将node节点插入到_cxq队列的头部，cxq是一个单向链表
    ObjectWaiter * nxt ;
    
    for (;;) {
        node._next = nxt = _cxq ;
        if (Atomic::cmpxchg_ptr (&node, &_cxq, nxt) == nxt) break ;

        // CAS失败的话 再尝试获得锁，这样可以降低插入到_cxq队列的频率
        if (TryLock (Self) > 0) {
            ...
            return ;
        }
    }
    
    // SyncFlags默认为0，如果没有其他等待的线程，则将_Responsible设置为自己
    if ((SyncFlags & 16) == 0 && nxt == NULL && _EntryList == NULL) {
        Atomic::cmpxchg_ptr (Self, &_Responsible, NULL) ;
    }
    
    
    TEVENT (Inflated enter - Contention) ;
    int nWakeups = 0 ;
    int RecheckInterval = 1 ;

    for (;;) {

        if (TryLock (Self) > 0) break ;
        assert (_owner != Self, "invariant") ;

        ...

        // park self
        if (_Responsible == Self || (SyncFlags & 1)) {
            // 当前线程是_Responsible时，调用的是带时间参数的park
            TEVENT (Inflated enter - park TIMED) ;
            Self->_ParkEvent->park ((jlong) RecheckInterval) ;
            // Increase the RecheckInterval, but clamp the value.
            RecheckInterval *= 8 ;
            if (RecheckInterval > 1000) RecheckInterval = 1000 ;
        } else {
            //否则直接调用park挂起当前线程
            TEVENT (Inflated enter - park UNTIMED) ;
            Self->_ParkEvent->park() ;
        }

        if (TryLock(Self) > 0) break ;

        ...
        
        if ((Knob_SpinAfterFutile & 1) && TrySpin (Self) > 0) break ;

       	...
        // 在释放锁时，_succ会被设置为EntryList或_cxq中的一个线程
        if (_succ == Self) _succ = NULL ;

        // Invariant: after clearing _succ a thread *must* retry _owner before parking.
        // 在清除 _succ 后, 一个线程必须重试设置 _owner 在挂起之前 
        OrderAccess::fence() ;
    }

   // 走到这里说明已经获得锁了

    assert (_owner == Self      , "invariant") ;
    assert (object() != NULL    , "invariant") ;
  
	// 将当前线程的node从cxq或EntryList中移除
    UnlinkAfterAcquire (Self, &node) ;
    if (_succ == Self) _succ = NULL ;
	if (_Responsible == Self) {
        _Responsible = NULL ;
        OrderAccess::fence();
    }
    ...
    return ;

}

```

主要步骤有3步：

将当前线程插入到cxq队列的队首
然后park当前线程
当被唤醒后再尝试获得锁

当竞争发生时，选取一个线程作为_Responsible，_Responsible线程调用的是有时间限制的park方法，其目的是防止出现搁浅现象。

_succ线程是在线程释放锁是被设置，其含义是Heir presumptive，也就是我们上面说的假定继承人。



## 锁释放

```C++
void ATTR ObjectMonitor::exit(bool not_suspended, TRAPS) {
   Thread * Self = THREAD ;
   // 如果_owner不是当前线程
   if (THREAD != _owner) {
     // 当前线程是之前持有轻量级锁的线程。由轻量级锁膨胀后还没调用过enter方法，_owner会是指向Lock Record的指针。
     if (THREAD->is_lock_owned((address) _owner)) {
       assert (_recursions == 0, "invariant") ;
       _owner = THREAD ;
       _recursions = 0 ;
       OwnerIsThread = 1 ;
     } else {
       // 异常情况:当前不是持有锁的线程
       TEVENT (Exit - Throw IMSX) ;
       assert(false, "Non-balanced monitor enter/exit!");
       if (false) {
          THROW(vmSymbols::java_lang_IllegalMonitorStateException());
       }
       return;
     }
   }
   // 重入计数器还不为0，则计数器-1后返回
   if (_recursions != 0) {
     _recursions--;        // this is simple recursive enter
     TEVENT (Inflated exit - recursive) ;
     return ;
   }

   // _Responsible设置为null
   if ((SyncFlags & 4) == 0) {
      _Responsible = NULL ;
   }

   ...

   for (;;) {
      assert (THREAD == _owner, "invariant") ;

      // Knob_ExitPolicy默认为0
      if (Knob_ExitPolicy == 0) {
         // code 1：先释放锁，这时如果有其他线程进入同步块则能获得锁
         OrderAccess::release_store_ptr (&_owner, NULL) ;   // drop the lock
         OrderAccess::storeload() ;                         // See if we need to wake a successor
         // code 2：如果没有等待的线程或已经有假定继承人
         if ((intptr_t(_EntryList)|intptr_t(_cxq)) == 0 || _succ != NULL) {
            TEVENT (Inflated exit - simple egress) ;
            return ;
         }
         TEVENT (Inflated exit - complex egress) ;

         // code 3：要执行之后的操作需要重新获得锁，即设置_owner为当前线程
         if (Atomic::cmpxchg_ptr (THREAD, &_owner, NULL) != NULL) {
            return ;
         }
         TEVENT (Exit - Reacquired) ;
      } 
      ...

      ObjectWaiter * w = NULL ;
      // code 4：根据QMode的不同会有不同的唤醒策略，默认为0
      int QMode = Knob_QMode ;
	 
      if (QMode == 2 && _cxq != NULL) {
          // QMode == 2 : cxq中的线程有更高优先级，直接唤醒cxq的队首线程
          w = _cxq ;
          assert (w != NULL, "invariant") ;
          assert (w->TState == ObjectWaiter::TS_CXQ, "Invariant") ;
          ExitEpilog (Self, w) ;
          return ;
      }

      if (QMode == 3 && _cxq != NULL) {
          // 将cxq中的元素插入到EntryList的末尾
          w = _cxq ;
          for (;;) {
             assert (w != NULL, "Invariant") ;
             ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (NULL, &_cxq, w) ;
             if (u == w) break ;
             w = u ;
          }
          assert (w != NULL              , "invariant") ;

          ObjectWaiter * q = NULL ;
          ObjectWaiter * p ;
          for (p = w ; p != NULL ; p = p->_next) {
              guarantee (p->TState == ObjectWaiter::TS_CXQ, "Invariant") ;
              p->TState = ObjectWaiter::TS_ENTER ;
              p->_prev = q ;
              q = p ;
          }

          // Append the RATs to the EntryList
          // TODO: organize EntryList as a CDLL so we can locate the tail in constant-time.
          ObjectWaiter * Tail ;
          for (Tail = _EntryList ; Tail != NULL && Tail->_next != NULL ; Tail = Tail->_next) ;
          if (Tail == NULL) {
              _EntryList = w ;
          } else {
              Tail->_next = w ;
              w->_prev = Tail ;
          }

          // Fall thru into code that tries to wake a successor from EntryList
      }

      if (QMode == 4 && _cxq != NULL) {
          // 将cxq插入到EntryList的队首
          w = _cxq ;
          for (;;) {
             assert (w != NULL, "Invariant") ;
             ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (NULL, &_cxq, w) ;
             if (u == w) break ;
             w = u ;
          }
          assert (w != NULL              , "invariant") ;

          ObjectWaiter * q = NULL ;
          ObjectWaiter * p ;
          for (p = w ; p != NULL ; p = p->_next) {
              guarantee (p->TState == ObjectWaiter::TS_CXQ, "Invariant") ;
              p->TState = ObjectWaiter::TS_ENTER ;
              p->_prev = q ;
              q = p ;
          }

          // Prepend the RATs to the EntryList
          if (_EntryList != NULL) {
              q->_next = _EntryList ;
              _EntryList->_prev = q ;
          }
          _EntryList = w ;

          // Fall thru into code that tries to wake a successor from EntryList
      }

      w = _EntryList  ;
      if (w != NULL) {
          // 如果EntryList不为空，则直接唤醒EntryList的队首元素
          assert (w->TState == ObjectWaiter::TS_ENTER, "invariant") ;
          ExitEpilog (Self, w) ;
          return ;
      }

      // EntryList为null，则处理cxq中的元素
      w = _cxq ;
      if (w == NULL) continue ;

      // 因为之后要将cxq的元素移动到EntryList，所以这里将cxq字段设置为null
      for (;;) {
          assert (w != NULL, "Invariant") ;
          ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (NULL, &_cxq, w) ;
          if (u == w) break ;
          w = u ;
      }
      TEVENT (Inflated exit - drain cxq into EntryList) ;

      assert (w != NULL              , "invariant") ;
      assert (_EntryList  == NULL    , "invariant") ;


      if (QMode == 1) {
         // QMode == 1 : 将cxq中的元素转移到EntryList，并反转顺序
         ObjectWaiter * s = NULL ;
         ObjectWaiter * t = w ;
         ObjectWaiter * u = NULL ;
         while (t != NULL) {
             guarantee (t->TState == ObjectWaiter::TS_CXQ, "invariant") ;
             t->TState = ObjectWaiter::TS_ENTER ;
             u = t->_next ;
             t->_prev = u ;
             t->_next = s ;
             s = t;
             t = u ;
         }
         _EntryList  = s ;
         assert (s != NULL, "invariant") ;
      } else {
         // QMode == 0 or QMode == 2‘
         // 将cxq中的元素转移到EntryList
         _EntryList = w ;
         ObjectWaiter * q = NULL ;
         ObjectWaiter * p ;
         for (p = w ; p != NULL ; p = p->_next) {
             guarantee (p->TState == ObjectWaiter::TS_CXQ, "Invariant") ;
             p->TState = ObjectWaiter::TS_ENTER ;
             p->_prev = q ;
             q = p ;
         }
      }


      // _succ不为null，说明已经有个继承人了，所以不需要当前线程去唤醒，减少上下文切换的比率
      if (_succ != NULL) continue;

      w = _EntryList  ;
      // 唤醒EntryList第一个元素
      if (w != NULL) {
          guarantee (w->TState == ObjectWaiter::TS_ENTER, "invariant") ;
          ExitEpilog (Self, w) ;
          return ;
      }
   }
}


```

在进行必要的锁重入判断以及自旋优化后，进入到主要逻辑：

code 1 设置owner为null，即释放锁，这个时刻其他的线程能获取到锁。这里是一个非公平锁的优化；

code 2 如果当前没有等待的线程则直接返回就好了，因为不需要唤醒其他线程。或者如果说succ不为null，代表当前已经有个"醒着的"继承人线程，那当前线程不需要唤醒任何线程；

code 3 当前线程重新获得锁，因为之后要操作cxq和EntryList队列以及唤醒线程；

code 4根据QMode的不同，会执行不同的唤醒策略；

根据QMode的不同，有不同的处理方式：

QMode = 2且cxq非空：取cxq队列队首的ObjectWaiter对象，调用ExitEpilog方法，该方法会唤醒ObjectWaiter对象的线程，然后立即返回，后面的代码不会执行了；
QMode = 3且cxq非空：把cxq队列插入到EntryList的尾部；
QMode = 4且cxq非空：把cxq队列插入到EntryList的头部；
QMode = 0：暂时什么都不做，继续往下看；




-XX:SyncFlags=4 参数

偏向级锁 弃用
https://www.zhihu.com/question/288104563


jdk6默认开启偏向锁, 4秒后 启用偏向锁状态

几个调优参数

-XX:+UseHeavyMonitors  只使用重量锁
-XX:+/- UseBiasedLocking  启用/关闭 偏向锁, JDK 6 后默认为启用状态
-XX:BiasedLockingStartupDelay=0  //关闭延迟开启偏向锁

在虚拟机启动后的 BiasedLockingStartupDelay 毫秒内, 创建的对象都是无锁状态
BiasedLockingStartupDelay 毫秒后创建的对象，包括 Class 对象, 默认都是 匿名偏向, 也就是偏向锁状态, 但是锁的线程 ID 为 0


hash 会导致锁升级


https://wiki.openjdk.java.net/display/HotSpot/Synchronization



https://www.it610.com/article/1296551396493041664.htm



        //
        hashCode 的效果

        无锁 hashCode 无锁, 获取锁, 轻量级锁

        无锁 hashCode 无锁

        偏向锁  在锁代码块外 hashCode  无锁

        偏向锁  在锁代码块内 hashCode  重量级锁  退出后，变为无锁

        轻量锁  在锁代码块外 hashCode  无锁


        重量级锁  hashCode 还是重量级锁, 但是重量级锁有个特点: 当前锁对象没有线程在等待, 会降级到无锁