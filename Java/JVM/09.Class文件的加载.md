# 09. Class 文件的加载

Java 虚拟机把描述类的数据从 Class 文件加载到内存, 并对数据进行校验, 转换解析和初始化, 最终形成可以被虚拟机直接使用的 Java 类型, 这个过程被称作虚拟机的**类加载机制**。

与那些在编译时需要进行连接的语言不同, 在 Java 语言里面, 类的加载, 连接和初始化过程都是在程序运行期间完成的, 这种策略让 Java 语言进行提前编译会面临额外的困难, 也会让类加载时稍微增加一些性能开销, 但是却为 Java 应用提供了极高的扩展性和灵活性, Java 天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。

比如, 要加载一个接口的实现了, 除了可以从当前的 jar 里面或外部的依赖 jar 包加载外, 还可以自定义自己的类加载器或 Java 预置, 通过网络请求一个二进制流文件作为程序运行的实现类等。

从上面的例子中, 我们可以知道, JVM 的类加载机制的数据来源, 除了是一个真真正正的 Class 文件外, 还是可以通过网络加载回来的二进制流, 乃至可以是从数据库中读取的数据, 所以对于 Class 文件的定义范围可以适当扩大到二进制流的范畴。  
还有每个 Class 文件都有代表着 Java 语言中的一个类或接口的可能性。

## 9.1 类加载的时机

![Alt 'LifeCycleOfClass'](https://raw.githubusercontent.com/PictureRespository/Java/main/JVM/LifeCycleOfClass.png)

如图, 一个类型从被加载到虚拟机内存中开始, 到卸载出内存为止, 它的整个生命周期将会经历加载 (Loading), 验证 (Verification), 准备 (Preparation), 解析 (Resolution), 初始化 (Initialization), 使用 (Using) 和卸载 (Unloading) 七个阶段, 其中验证 + 准备 + 解析三个部分统称为连接 (Linking)

加载, 验证, 准备, 初始化和卸载这五个阶段的顺序是确定的, 类型的加载过程必须按照这种顺序按部就班地开始, 而解析阶段则不一定: 它在某些情况下可以在初始化阶段之后再开始, 这是为了支持 Java 语言的运行时绑定特性, 也称为动态绑定或晚期绑定。

对于一个类什么时候加载, 《Java虚拟机规范》没有强制要求, 但是对于类的初始化阶段, 则严格规定了有且只有六种情况必须立即对类进行 "初始化" (而加载, 验证, 准备自然需要在此之前开始):

> 1. 遇到 new / getstatic / putstatic / invokestatic 这四条字节码指令时, 如果类型没有进行过初始化, 则需要先触发其初始化阶段。能够生成这四条指令的典型 Java 代码场景有
>>1.1 使用 new 关键字实例化对象的时候
>>1.2 读取或设置一个类型的静态字段 (被 final 修饰, 已在编译期把结果放入常量池的静态字段除外) 的时候
>>1.3 调用一个类型的静态方法的时候

> 2. 使用 java.lang.reflect 包的方法对类型进行反射调用的时候, 如果类型没有进行过初始化, 则需要先触发其初始化
> 3. 当初始化类的时候, 如果发现其父类还没有进行过初始化, 则需要先触发其父类的初始化
> 4. 当虚拟机启动时, 用户需要指定一个要执行的主类 (包含 main() 方法的那个类), 虚拟机会先初始化这个主类
> 5. 当使用 JDK7 新加入的动态语言支持时, 如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic / REF_putStatic / REF_invokeStatic / REF_newInvokeSpecial 四种类型的方法句柄, 并且这个方法句柄对应的类没有进行过初始化, 则需要先触发其初始化
> 6. 当一个接口中定义了 JDK8 新加入的默认方法 (被 default 关键字修饰的接口方法) 时, 如果有这个接口的实现类发生了初始化, 那该接口要在其之前被初始化

这六种场景中的行为称为对一个类型进行**主动引用**。除此之外, 所有引用类型的方式都不会触发初始化, 称为**被动引用**。

被动引用的例子:
> 1. 通过子类引用父类的静态字段, 不会导致子类初始化

```java
public class SuperClass {
    public static int value = 123;
}

public class SubClass extends SuperClass {
}

public class TestClass {

    public static void main(String[] args) {
        // 通过子类调用父类的静态属性
        System.out.println(SubClass.value);
    }
}
```

对于静态字段, 只有直接定义这个字段的类才会被初始化, 因此通过其子类来引用父类中定义的静态字段, 只会触发父类的初始化而不会触发子类的初始化

> 2. 通过数组定义来引用类, 不会触发此类的初始化

```java
public class SuperClass {
}

public class TestClass {

    public static void main(String[] args) {
        // 通过数组定义来引用类
        SuperClass[] sca = new SuperClass[10]; 
    }
}
```

这段代码不会触发 SuperClass 的加载, 但是这段代码里面触发了另一个名为 "[Lorg.fenixsoft.classloading.SuperClass" 的类的初始化阶段, 这并不是一个合法的类型名称, 它是一个由虚拟机自动生成的, 直接继承于 java.lang.Object 的子类, 创建动作由字节码指令 newarray 触发

这个类代表了一个元素类型为 org.fenixsoft.classloading.SuperClass 的一维数组, 数组中应有的属性和方法 (用户可直接使用的只有被修饰为 public 的 length 属性和 clone() 方法) 都实现在这个类里。

> 3. 常量在编译阶段会存入调用类的常量池中, 本质上没有直接引用到定义常量的类, 因此不会触发定义常量的类的初始化

```java
public class ConstClass { 
    public static final String HELLOWORLD = "hello world"; 
}

public class TestClass { 

    public static void main(String[] args) { 
        // 通过类引用其常量
        System.out.println(ConstClass.HELLOWORLD); 
    }
}
```

在编译阶段通过常量传播优化, 已经将此常量的值 "hello world" 直接存储在 TestClass 类的常量池中, 以后 TestClass 对常量 ConstClass.HELLOWORLD 的引用, 实际都被转化为 TestClass 类对自身常量池的引用了。

接口的加载过程与类加载过程稍有不同, 接口也有初始化过程, 接口与类真正有所区别的是前面讲述的六种初始化场景中的第三种: **当一个类在初始化时, 要求其父类全部都已经初始化过了**, 但是接口没有这个限制, 只有在真正使用到父接口的时候 (如引用接口中定义的常量) 才会初始化。

## 9.2 类的加载过程

### 9.2.1 加载

在加载阶段, Java 虚拟机需要完成以下三件事情
> 1. 通过一个类的全限定名来获取定义此类的二进制字节流
> 2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
> 3. 在内存中生成一个代表这个类的 java.lang.Class 对象, 作为方法区这个类的各种数据的访问入口

在上面的说明中可以知道, 只有是一个可以转为 Class 对象的二进制字节流, 既可以作为输入源。那么可操作的空间就很大了,
从网络请求, 运行时动态代理, 由其他文件生成 (JSP 页面等), 从加密文件中获取等, 用户完全可以使用自定义的类加载器 (重写一个类加载器的 findClass() 或 
loadClass() 方法), 实现根据自己的想法来赋予应用程序获取运行代码的动态性。

对于数组类而言, 情况就有所不同, 数组类本身不通过类加载器创建, 它是由 Java 虚拟机直接在内存中动态构造出来的。 但是数组类的元素类型 (Element
Type, 指的是数组去掉所有维度的类型) 最终还是要靠类加载器来完成加载, 一个数组类 (下面简称为 C) 创建过程遵循以下规则:

> 1. 如果数组的组件类型 (Component Type, 指的是数组去掉一个维度的类型, 注意和前面的元素类型区分开来）是引用类型, 那就递归采用上面定义的加
     载过程去加载这个组件类型, 数组 C 将被标识在加载该组件类型的类加载器的类名称空间上
> 2. 如果数组的组件类型不是引用类型 (例如 int[] 数组的组件类型为 int), Java 虚拟机将会把数组 C 标记为与引导类加载器关联 (引导类加载器 Boostrap ClassLoader)
> 3. 数组类的可访问性与它的组件类型的可访问性一致, 如果组件类型不是引用类型, 它的数组类的可访问性将默认为 public, 可被所有的类和接口访问到 

类名称空间的知识可以看[这里](https://blog.csdn.net/qq_37362891/article/details/106981909)

加载阶段与连接阶段的部分动作 (如一部分字节码文件格式验证动作) 是交叉进行的, 加载阶段尚未完成, 连接阶段可能已经开始, 但这些夹在加载阶段之中进
行的动作, 仍然属于连接阶段的一部分, 这两个阶段的开始时间仍然保持着固定的先后顺序。

### 9.2.2 验证

验证是连接阶段的第一步, 这一阶段的目的是确保 Class 文件的字节流中包含的信息符合《Java 虚拟机规范》的全部约束要求, 保证这些信息被当作代码运
行后不会危害虚拟机自身的安全。

验证阶段**大致上**会完成下面四个阶段的检验动作

> 1. 文件格式验证

第一阶段要验证字节流是否符合 Class 文件格式的规范, 并且能被当前版本的虚拟机处理。这一阶段可能包括下面这些验证点  
* 是否以魔数 0xCAFEBABE 开头
* 主, 次版本号是否在当前 Java 虚拟机接受范围之内
* 常量池的常量中是否有不被支持的常量类型 (检查常量 tag 标志)
* 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量
* CONSTANT_Utf8_info 型的常量中是否有不符合 UTF-8 编码的数据
* Class 文件中各个部分及文件本身是否有被删除的或附加的其他信息

......

实际上第一阶段的验证点还远不止这些, 上面所列的只是从 HotSpot 虚拟机验证的一小部分内容。  
该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内, 格式上符合描述一个 Java 类型信息的要求。  
通过了这个阶段, 原本的字节流才被允许存放在 Java 虚拟机的方法区中, 后面的三个阶段都是基于方法区的存储结构上进行的。

> 2. 元数据验证

第二阶段是对字节码描述的信息进行语义分析, 以保证其描述的信息符合《Java语言规范》的要求, 这个阶段可能包括的验证点如下  
* 这个类是否有父类 (除了 java.lang.Object 之外, 所有的类都应当有父类)
* 这个类的父类是否继承了不允许被继承的类 (被 final 修饰的类)
* 如果这个类不是抽象类, 是否实现了其父类或接口之中要求实现的所有方法
* 类中的 字段/方法 是否与父类产生矛盾 (例如覆盖了父类的 final 字段, 或者出现不符合规则的方法重载, 例如方法参数都一致, 但返回值类型却不同等)

......
  
> 3. 字节码验证

第三阶段通过数据流分析和控制流分析, 确定程序语义是合法的, 符合逻辑的。这阶段对类的方法体 (Class 文件中的 Code 属性) 进行校验分析, 保证被校
验类的方法在运行时不会做出危害虚拟机安全的行为  
* 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作, 例如不会出现类似于 "在操作栈放置了一个 int 类型的数据, 使用时却按 long 类型来加
  载入本地变量表中" 这样的情况  
* 保证任何跳转指令都不会跳转到方法体以外的字节码指令上
* 保证方法体中的类型转换总是有效的, 例如可以把一个子类对象赋值给父类数据类型, 这是安全的, 但是把父类对象赋值给子类数据类型, 甚至把对象赋值给
  与它毫无继承关系, 完全不相干的一个数据类型, 则是危险和不合法的 
  
......
  
如果一个方法体通过了字节码验证, 也仍然不能保证它一定就是安全的。

由于数据流分析和控制流分析的高度复杂性, 为了避免过多的执行时间消耗在字节码验证阶段中, 在 JDK6 之后的 Javac 编译器和 Java 虚拟机里进行了一
项联合优化, 把尽可能多的校验辅助措施挪到 Javac 编译器里进行。具体的做法:

* 给方法体 Code 属性的属性表中新增加了一项名为 "StackMapTable" 的新属性, 这项属性描述了方法体所有的基本块 (Basic Block, 指按照控制流拆分
  的代码块) 开始时本地变量表和操作栈应有的状态  
* 在字节码验证期间, Java 虚拟机就不需要根据程序推导这些状态的合法性, 只需要检查 StackMapTable 属性中的记录是否合法即可, 从原来的将字节码
  验证的类型推导转变为类型检查, 从而节省了大量校验时间。

理论上 StackMapTable 属性也存在错误或被篡改的可能, 所以是否有可能在恶意篡改了 Code 属性的同时, 也生成相应的 StackMapTable 属性来骗过虚
拟机的类型校验, 则是虚拟机设计者们需要仔细思考的问题。

HotSpot 虚拟机 对于主版本好大于 50 (对应 JDK6) 的 Class 文件, 使用**类型检查**来完成数据流分析校验则是唯一的选择

> 4. 符号引用验证

最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候, 这个转化动作将在**连接的第三阶段 -- 解析阶段**中发生。符号引用验证可以看作
是对类自身以外 (常量池中的各种符号引用) 的各类信息进行匹配性校验, 通俗来说就是, 该类是否缺少或者被禁止访问它依赖的某些外部类, 方法, 字段等资源

* 符号引用中通过字符串描述的全限定名是否能找到对应的类
* 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段
* 符号引用中的类, 字段, 方法的可访问性 (private / protected / public / <package>) 是否可被当前类访问

......

符号引用验证的主要目的是确保解析行为能正常执行, 如果无法通过符号引用验证, Java虚拟机 将会抛出一个java.lang.IncompatibleClassChangeError的子类异常





