# 09. Class 文件的加载

Java 虚拟机把描述类的数据从 Class 文件加载到内存, 并对数据进行校验, 转换解析和初始化, 最终形成可以被虚拟机直接使用的 Java 类型, 这个过程被称作虚拟机的**类加载机制**。

与那些在编译时需要进行连接的语言不同, 在 Java 语言里面, 类的加载, 连接和初始化过程都是在程序运行期间完成的, 这种策略让 Java 语言进行提前编译会面临额外的困难, 也会让类加载时稍微增加一些性能开销, 但是却为 Java 应用提供了极高的扩展性和灵活性, Java 天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。

比如, 要加载一个接口的实现了, 除了可以从当前的 jar 里面或外部的依赖 jar 包加载外, 还可以自定义自己的类加载器或 Java 预置, 通过网络请求一个二进制流文件作为程序运行的实现类等。

从上面的例子中, 我们可以知道, JVM 的类加载机制的数据来源, 除了是一个真真正正的 Class 文件外, 还是可以通过网络加载回来的二进制流, 乃至可以是从数据库中读取的数据, 所以对于 Class 文件的定义范围可以适当扩大到二进制流的范畴。  
还有每个 Class 文件都有代表着 Java 语言中的一个类或接口的可能性。

## 9.1 类加载的时机

![Alt 'LifeCycleOfClass'](https://raw.githubusercontent.com/PictureRespository/Java/main/JVM/LifeCycleOfClass.png)

如图, 一个类型从被加载到虚拟机内存中开始, 到卸载出内存为止, 它的整个生命周期将会经历加载 (Loading), 验证 (Verification), 准备 (Preparation), 解析 (Resolution), 初始化 (Initialization), 使用 (Using) 和卸载 (Unloading) 七个阶段, 其中验证 + 准备 + 解析三个部分统称为连接 (Linking)

加载, 验证, 准备, 初始化和卸载这五个阶段的顺序是确定的, 类型的加载过程必须按照这种顺序按部就班地开始, 而解析阶段则不一定: 它在某些情况下可以在初始化阶段之后再开始, 这是为了支持 Java 语言的运行时绑定特性, 也称为动态绑定或晚期绑定。

对于一个类什么时候加载, 《Java虚拟机规范》没有强制要求, 但是对于类的初始化阶段, 则严格规定了有且只有六种情况必须立即对类进行 "初始化" (而加载, 验证, 准备自然需要在此之前开始):

> 1. 遇到 new / getstatic / putstatic / invokestatic 这四条字节码指令时, 如果类型没有进行过初始化, 则需要先触发其初始化阶段。能够生成这四条指令的典型 Java 代码场景有

>> 1.1 使用 new 关键字实例化对象的时候
>> 1.2 读取或设置一个类型的静态字段 (被 final 修饰, 已在编译期把结果放入常量池的静态字段除外) 的时候
>> 1.3 调用一个类型的静态方法的时候

> 2. 使用 java.lang.reflect 包的方法对类型进行反射调用的时候, 如果类型没有进行过初始化, 则需要先触发其初始化
> 3. 当初始化类的时候, 如果发现其父类还没有进行过初始化, 则需要先触发其父类的初始化
> 4. 当虚拟机启动时, 用户需要指定一个要执行的主类 (包含 main() 方法的那个类), 虚拟机会先初始化这个主类
> 5. 当使用 JDK7 新加入的动态语言支持时, 如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic / REF_putStatic / REF_invokeStatic / REF_newInvokeSpecial 四种类型的方法句柄, 并且这个方法句柄对应的类没有进行过初始化, 则需要先触发其初始化
> 6. 当一个接口中定义了 JDK8 新加入的默认方法 (被 default 关键字修饰的接口方法) 时, 如果有这个接口的实现类发生了初始化, 那该接口要在其之前被初始化

这六种场景中的行为称为对一个类型进行**主动引用**。除此之外, 所有引用类型的方式都不会触发初始化, 称为**被动引用**。

被动引用的例子:
> 1. 通过子类引用父类的静态字段, 不会导致子类初始化

```java
public class SuperClass {
    public static int value = 123;
}

public class SubClass extends SuperClass {
}

public class TestClass {

    public static void main(String[] args) {
        // 通过子类调用父类的静态属性
        System.out.println(SubClass.value);
    }
}
```

对于静态字段, 只有直接定义这个字段的类才会被初始化, 因此通过其子类来引用父类中定义的静态字段, 只会触发父类的初始化而不会触发子类的初始化

> 2. 通过数组定义来引用类, 不会触发此类的初始化

```java
public class SuperClass {
}

public class TestClass {

    public static void main(String[] args) {
        // 通过数组定义来引用类
        SuperClass[] sca = new SuperClass[10]; 
    }
}
```

这段代码不会触发 SuperClass 的加载, 但是这段代码里面触发了另一个名为 "[Lorg.fenixsoft.classloading.SuperClass" 的类的初始化阶段, 这并不是一个合法的类型名称, 它是一个由虚拟机自动生成的, 直接继承于 java.lang.Object 的子类, 创建动作由字节码指令 newarray 触发

这个类代表了一个元素类型为 org.fenixsoft.classloading.SuperClass 的一维数组, 数组中应有的属性和方法 (用户可直接使用的只有被修饰为 public 的 length 属性和 clone() 方法) 都实现在这个类里。

> 3. 常量在编译阶段会存入调用类的常量池中, 本质上没有直接引用到定义常量的类, 因此不会触发定义常量的类的初始化

```java
public class ConstClass { 
    public static final String HELLOWORLD = "hello world"; 
}

public class TestClass { 

    public static void main(String[] args) { 
        // 通过类引用其常量
        System.out.println(ConstClass.HELLOWORLD); 
    }
}
```

在编译阶段通过常量传播优化, 已经将此常量的值 "hello world" 直接存储在 TestClass 类的常量池中, 以后 TestClass 对常量 ConstClass.HELLOWORLD 的引用, 实际都被转化为 TestClass 类对自身常量池的引用了。

接口的加载过程与类加载过程稍有不同, 接口也有初始化过程, 接口与类真正有所区别的是前面讲述的六种初始化场景中的第三种: **当一个类在初始化时, 要求其父类全部都已经初始化过了**, 但是接口没有这个限制, 只有在真正使用到父接口的时候 (如引用接口中定义的常量) 才会初始化。

## 9.2 类的加载过程