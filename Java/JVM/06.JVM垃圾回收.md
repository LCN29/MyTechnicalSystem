# 06. JVM 垃圾回收

当前大部分的垃圾收集器都遵循着 "分代收集" (Generational Collection) 的理论进行设计的, 建立在 2 个分代假设之上

1. 弱分代假说 (Weak Generational Hypothesis): 绝大多数对象都是朝生夕灭的
2. 强分代假说 (Strong Generational Hypothesis): 熬过越多次垃圾收集过程的对象就越难以消亡

根据这 2 个假说, 收集器将 Java 堆划分出不同的区域, 然后将回收对象依据其年龄 (年龄即对象熬过垃圾收集过程的次数) 分配到不同的区域之中存储。  
1. 新生代 (Young Generation)
2. 老年代 (Old Generation)

分代收集存在的一个问题: 新生代的对象 有可能被老年代所引用, 为了确保新生代中被引用的, 需要在固定的 GC Roots 之外, 在额外变量整个老年代中所有
对象来确保可达性分析结果的正确性。(同样, 老年代也可能被新生代所引用)。基于这个问题, 有了第三条假设  

3. 跨代引用假说 (Intergenerational Reference Hypothesis): 跨代引用相对于同代引用来说仅占极少数。

依据这条假说, 我们就不应再为了少量的跨代引用去扫描整个老年代, 也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用, 只需在新生代上建立
一个全局的数据结构 (该结构被称为 "记忆集", Remembered Set), 这个结构把老年代划分成若干小块, 标识出老年代的哪一块内存会存在跨代引用。此后
当发生 Minor GC 时, 只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots 进行扫描。虽然这种方法需要在对象改变引用关系（如将自己或者某
个属性赋值）时维护记录数据的正确性, 会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。

## 1. 常用的垃圾回收算法

### 1.1 **标记-清除算法**
先标记所有需要回收的对象, 标记完成后, 统一回收所有标记的对象 (也可以反过来, 标记存活的对象, 回收未标记的对象)。 标记的依据, 通过上面的可达 
性分析法。

存在 2 个问题:
>1. 执行效率不稳定, 标记和清除的过程会随着 Java 堆中的对象增多而变长
>2. 内存空间碎片化, 回收完成后, 会产生大量不连续的内存碎片, 空间碎片太多的话, 可能会导致后续大对象的分配找不到足够的连线内存。

### 1.2 **标记-复制算法**

为了解决**标记-清除算法** 面对大量可回收对象时执行效率低的问题。

将可用内存按容量划分为大小相等的两块, 每次只使用其中的一块。当这一块的内存用完了, 就将还存活着的对象复制到另外一块上面, 然后再把已使用过的内
存空间一次清理掉。

如果内存中多数对象都是存活的, 这种算法将会产生大量的内存间复制的开销, 但对于多数对象都是可回收的情况, 算法需要复制的就是占少数的存活对象, 而
且每次都是针对整个半区进行内存回收,分配内存时也就不用考虑有空间碎片的复杂情况, 只要移动堆顶指针, 按顺序分配即可。这样实现简单, 运行高效。  

最大的缺点: 是将可用内存缩小为了原来的一半，空间浪费未免太多了。

针对空间浪费大的问题, 有一种更优化的半区复制分代策略 - Appel 式回收。(HotSpot 采用的就是这种策略)。  

Appel 式回收: 将新生代划分为一块较大的 Eden 区域 + 两块较小的 Survivor 空间。每次分配内存只使用 Eden 和其中一块 Survivor。 发生垃圾回
收时, 将 Eden 和 Survivor 中存活的对象一次性复制到另外一块 Survivor 上, 然后把 Eden 和 已使用过的那块 Survivor 空间清理掉。 HotSpot 
默认 Eden 和 Survivor 的比例是 8:1:1, 也就是每次新生代中可使用的内存占总量的 90%。

当然, 可能一次垃圾回收时, 10 % 的 Survivor 的区域无法存放存活的对象了, Appel 式回收会通过分配担保 (Handle Promotion), 将这些对象直接
放入老年代。

当一个对象进入到 Survivor 时, 他的年龄将会 + 1, 后续在 2 个 Survivor 区来回拷贝时, 每拷贝一次, 年龄就 + 1, 当年龄达到了 15 (HotSpot 
默认的配置), 这个对象就会被移入到老年代。


### 1.3 **标记-整理算法**
**标记-复制算法**在对象存活率较高时就要进行较多的复制操作，效率将会降低。 同时无论如何还是会有空间的浪费。 所以老年代一般都会会选用这种算法。

针对老年代的特点, 有一种针对性的**标记-整理算法**, 同样的先通过标记, 确定对象是否可回收, 然后让所以存活的对象都向内存空间的一端移动, 然后清
理掉边界以外的内存。这种移动式的算法是一项优缺点并存的风险决策。    

如果移动存活对象, 尤其是在老年代这种每次回收都有大量对象存活区域, 移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作, 而且这种
对象移动操作必须全程暂停用户应用程序才能进行。  

如果不移动对象, 则会有空间碎片, 这个问题就只能依赖更为复杂的内存分配器和内存访问器来解决。

基于以上两点, 是否移动对象都存在弊端, 移动则内存回收时会更复杂, 不移动则内存分配时会更复杂。
从垃圾收集的停顿时间来看, 不移动对象停顿时间会更短, 甚至可以不需要停顿, 但是从整个程序的性能来看, 移动对象会更划算 (因内存分配和访问相比垃圾
收集频率要高得多, 这部分的耗时增加, 最终可能导致性能的下降)。

HotSpot 里面的 Parallel Scavenge 收集器是基于**标记-整理算法**的, CMS 收集器是基于**标记-清除算法**。

CMS 的实现: 平时多数时间都采用标记-清除算法, 暂时容忍内存碎片的存在, 直到内存空间的碎片化程度已经大到影响对象分配时, 再采用标记-整理算法收集
一次, 以获得规整的内存空间。

## 2. 记忆集 (Remembered Set)

记忆集是一种 "抽象" 的数据结构, 只定义了记忆集的行为意图，并没有定义其行为的具体实现。 而现在常用的的具体实现为 "卡表"(Card Table), 2 者
的关系类似于 Map 和 HashMap 的关系。

卡表最简单的形式可以只是一个字节数组。

```java
CARD_TABLE [this address >> 9] = 0;
```

字节数组 CARD_TABLE 的每一个元素都对应着其标识的内存区域中一块特定大小的内存块, 这个内存块被称作 "卡页"(Card Page)。 一般来说, 卡页大小都
是以 2 的 N 次幂的字节数, HotSpot 默认为 512 字节。如果卡表标识内存区域的起始地址是 0x0000 的话，数组 CARD_TABLE 的第 0, 1, 2 号元素，
分别对应了地址范围为 0x0000～0x01FF, 0x0200～0x03FF, 0x0400～0x05FF 的卡页内存块。

一个卡页的内存中通常包含不止一个对象，只要卡页内有一个或更多对象的字段存在着跨代指针, 那就将对应卡表的数组元素的值标识为 1, 称为这个元素变
脏(Dirty), 没有则标识为 0。 

在垃圾收集发生时, 只要筛选出卡表中变脏的元素, 就能轻易得出哪些卡页内存块中包含跨代指针, 把它们加入 GC Roots 中一并扫描。 这里是把这个区域
内的对象都加入的。

### 2.1 记忆集的维护

在 HotSpot 虚拟机里是通过写屏障 (Write Barrier) 技术维护卡表状态的 (这里的写屏障不是解决并发的读写屏障), 看作在虚拟机层面对 "引用类型字
段赋值" 这个动作的 AOP 切面，在引用对象赋值时会产生一个环形 （Around）通知, 供程序执行额外的动作, 也就是说赋值的前后都在写屏障的覆盖范畴内。
在赋值前的部分的写屏障叫作写前屏障 (Pre-Write Barrier), 在赋值 后的则叫作写后屏障 (Post-Write Barrier)。 HotSpot 虚拟机只用到了写后屏障。

```C
void oop_field_store(oop* field, oop new_value) { 
    // 引用字段赋值操作 
    *field = new_value; 
    // 写后屏障, 在这里完成卡表状态更新 
    post_write_barrier(field, new_value); 
}
```
应用写屏障后, 虚拟机就会为所有赋值操作生成相应的指令, 一旦收集器在写屏障中增加了更新卡表操作, 无论更新的是不是老年代对新生代对象的引用, 每次
只要对引用进行更新, 就会产生额外的开销, 不过这个开销与 Minor GC 时扫描整个老年代的代价相比还是低得多的。

除了写屏障的开销外, 卡表在高并发场景下还面临着 "伪共享"（False Sharing）问题。什么是伪共享可以看[这里](https://blog.csdn.net/z735640642/article/details/84554706)。 

为了避免伪共享问题，一种简单的解决方案是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏, 即将卡表更新的
逻辑变为以下代码所示:
```C
if (CARD_TABLE [this address >> 9] != 0) 
    CARD_TABLE [this address >> 9] = 0;
```

在 JDK 7 之后，HotSpot 虚拟机增加了一个新的参数 -XX: +UseCondCardMark, 用来决定是否开启卡表更新的条件判断。开启会增加一次额外判断的开销, 
但能够避免伪共享问题, 两者各有性能损耗, 是否打开要根据应用实际运行情况来进行测试权衡。

## 3. 经典垃圾收集器

![Alt 'CollectorInHotSpot'](https://raw.githubusercontent.com/PictureRespository/Java/main/JVM/CollectorInHotSpot.png)

如图, 展示了 7 款 HotSpot 常用的收集器, 收集器所处的区域, 表示了他属于哪个分代的收集器。连线表示 2 个收集器可以搭配使用 (注: JDK8 将 Serial + CMS 和
ParNew + Serial Old 声明为废弃, 并在 JDK9 中完全取消了这 2 个组合的支持)。

### 3.1 Serial 串行收集器-复制算法
Serial 是一个单线程工作的收集器。它的 "单线程" 的意义不是指只会使用一个处理器或一条收集线程去完成垃圾收集工作, 而是强调在它进行垃圾收集时, 必须暂停其他所有工作线程, 直到它收集结束。

流程大体是这样的:
![Alt 'SerialCollectorProcesses'](https://raw.githubusercontent.com/PictureRespository/Java/main/JVM/SerialCollectorProcesses.png)

优点: 简单高效, 内存消耗（Memory Footprint）最小的。在 JVM 的 Client 模式下表现优异 (Client 模式下内存较小, CPU 较少, 能减少许多线程交互的开销)。  
缺点: 回收工作需要 Stop The World, 不适用虚拟机 Server 模式 (Server 模式下内存较大, CPU 较多, 导致回收工作停顿时间过长)。

### 3.2 ParNew 并行收集器-复制算法
ParNew 收集器实质上是 Serial 收集器的多线程并行版本, 除了同时使用多条线程进行垃圾收集之外, 其他的行为, 调优参数都和 Serial 一样。

流程大体是这样的:
![Alt 'ParNewCollectorProcesses'](https://raw.githubusercontent.com/PictureRespository/Java/main/JVM/ParNewCollectorProcesses.png)

优点: 多线程工作, 效率更高  
缺点: 回收工作需要 Stop The World, 只能和 CMS 收集器搭配使用。

### 3.3 Parallel Scavenge 并行收集器-复制算法
Parallel Scavenge 又称为吞吐量优先收集器, 是 Java1.8 默认的收集器, 特点是并行的多线程回收, 以吞吐量优先。

流程大体是这样的:
![Alt 'ParallelScavengeCollectorProcesses'](https://raw.githubusercontent.com/PictureRespository/Java/main/JVM/ParallelScavengeCollectorProcesses.png)

Parallel Scavenge 收集器的关注点与其他收集器不同, CMS 等收集器的关注点是尽可能地缩短垃圾收集时, 用户线程的停顿时间 (响应时间优先)。
Parallel Scavenge 收集器的目标则是达到一个可控制的吞吐量（Throughput）(吞吐量优先)。

吞吐量 = 运行用户代码时间 / 运行用户代码时间 + 垃圾收集时间。

响应时间优先: 注重的是垃圾回收时 STW 的时间最短  
吞吐量优先: 让**单位时间内** STW 的时间最短

个人认为: 就是每隔多少时间就进行一次收集。可以通过   
**-XX：MaxGCPauseMillis** 设置最大垃圾收集停顿时间
**-XX：MaxGCPauseMillis** 设置垃圾收集时间占总时间的比例

优点: 多线程工作; 注重系统吞吐量和 CPU 资源; 自适应调节策略。  
缺点: 回收工作需要 Stop The World;

### 3.4 Serial Old 串行收集器-标记整理算法

Serial Old 是 Serial 收集器的老年代版本, 它同样是一个单线程收集器, 使用标记-整理算法。

主要是供 Client 模式下的 HotSpot 虚拟机使用。如果在 Server 模式下的话, 可能是
>1. 在 JDK5 及之前的版本中和 Parallel Scavenge 收集器搭配使用
>2. 作为 CMS 收集器发生失败时的后备预案, 在并发收集发生 Concurrent Mode Failure 时使用。

流程大体是这样的:
![Alt 'SerialOldCollectorProcesses'](https://raw.githubusercontent.com/PictureRespository/Java/main/JVM/SerialOldCollectorProcesses.png)

优点: 虚拟机 Client 模式下表现尚可; CMS 收集器的后备预案（在并发收集 Concurrent Mode Failure 时使用）。
缺点: 回收工作需要 Stop The World; 单线程。

### 3.5 Parallel Old 并行收集器-标记整理算法

Parallel Old  是 Parallel Scavenge 收集器的老年代版本, 支持多线程并发收集, 使用标记-整理算法。

在注重吞吐量或者处理器资源较为稀缺的场合, 都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器这个组合。

流程大体是这样的:
![Alt 'ParallelOldCollectorProcesses'](https://raw.githubusercontent.com/PictureRespository/Java/main/JVM/ParallelOldCollectorProcesses.png)

优点: 在注重吞吐量或者处理器资源较为稀缺的场合, 都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器这个组合
缺点: 回收工作需要 Stop The World; 可搭配的新生代收集器仅有 Parallel Scavenge 收集器而已。

### 3.6 CMS(Concurrent Mark Sweep)  并行收集器-标记清除算法

CMS 是一款以获取最短**回收停顿时间**为目标的收集器, 是真正意义上与用户线程并发运行的收集器。
它的运作过程分为 4 个步骤
> 1. 初始标记 (CMS initial mark): 只是标记一下 GC Roots 能直接关联到的对象, 速度很快
> 2. 并发标记 (CMS concurrent mark): 从 GC Roots 的直接关联对象开始遍历整个对象图的过程, 这个过程耗时较长但是不需要停顿用户线程
> 3. 重新标记 (CMS remark): 修正并发标记期间, 因用户程序继续运作而导致标记产生变动的那一部分对象，这个阶段停顿的世界同步会比初始标记阶段稍长一些, 但也比并
     发标记阶段的时间短
> 4. 并发清除 (CMS concurrent sweep): 清理删除标记阶段判断的已经思维的对象，由于不需要移动对象，这个节点也是和用户线程同时并发的

初始标记和重新标记这 2 个步骤仍然需要 Stop The World。而耗时最长的为并发标记和并发清除 2 个阶段, 都是与用户线程一起工作的。

流程大体是这样的:
![Alt 'CMSCollectorProcesses'](https://raw.githubusercontent.com/PictureRespository/Java/main/JVM/CMSCollectorProcesses.png)

优点: 并发收集, 低停顿, 对于大概 4GB 到 6GB 以下的堆内存, CMS 一般处理的比较好
缺点: 
> 1. CMS收集器对CPU资源非常敏感 

会占用一定的 CPU 资源, 在并发标记/清理的时候, 虽然不会导致用户线程停顿, 但标记/清理工作是要占用一部分 CPU 资源的, 这导致吞吐量降低。
CMS 默认启动的回收线程数是 (CPU 数量 + 3)/ 4。

> 2. CMS 收集器无法处理浮动垃圾, 可能出现 "Concurrent Mode Failure" 失败而导致另一次 Full GC 的产生。

由于在垃圾收集阶段用户线程还需要运行, 那也就还需要预留有足够的内存空间给用户线程使用, 因此 CMS 收集器不能像其他收集器那样等到老年代几乎完全
被填满了再进行收集, 需要预留一部分空间提供并发收集时的程序运作使用。要是 CMS 运行期间预留的内存无法满足程序需要, 就会出现一次 
"Concurrent Mode Failure" 失败, 这时虚拟机将启动后备预案: 停止用户线程, 临时启用 Serial Old 收集器来重新进行老年代的垃圾收集, 这样停顿
时间就很长了。

> 3. CMS 收集器会产生大量空间碎片

CMS 是一款基于 "标记-清除" 算法实现的收集器, 收集结束时会有大量空间碎片产生。空间碎片过多时, 将会给大对象分配带来很大麻烦, 往往会出现老年代
还有很多剩余空间, 但就是无法找到足够大的连续空间来分配当前对象, 而不得不提前触发一次 Full GC 的情况。

### 3.7 G1(Garbage First)  并行收集器-标记整理算法

G1 是一款主要面向服务端应用的垃圾收集器, 在 JDK9 中正式使用。

G1 开创的基于 Region 的堆内存布局使其能面向局部收集。G1 虽然遵循分代收集理论设计, 但器堆内存的布局和别的收集器有明显不一样的。G1 把 Java 堆
划分为多个大小相等的独立区域 (Region), 每个 Region 
