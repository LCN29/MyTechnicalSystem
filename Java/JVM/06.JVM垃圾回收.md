# 06. JVM 垃圾回收

当前大部分的垃圾收集器都遵循着 "分代收集" (Generational Collection) 的理论进行设计的, 建立在 2 个分代假设之上

1. 弱分代假说 (Weak Generational Hypothesis): 绝大多数对象都是朝生夕灭的
2. 强分代假说 (Strong Generational Hypothesis): 熬过越多次垃圾收集过程的对象就越难以消亡

根据这 2 个假说, 收集器将 Java 堆划分出不同的区域, 然后将回收对象依据其年龄 (年龄即对象熬过垃圾收集过程的次数) 分配到不同的区域之中存储。  
1. 新生代 (Young Generation)
2. 老年代 (Old Generation)

分代收集存在的一个问题: 新生代的对象 有可能被老年代所引用, 为了确保新生代中被引用的, 需要在固定的 GC Roots 之外, 在额外变量整个老年代中所有
对象来确保可达性分析结果的正确性。(同样, 老年代也可能被新生代所引用)。基于这个问题, 有了第三条假设  

3. 跨代引用假说 (Intergenerational Reference Hypothesis): 跨代引用相对于同代引用来说仅占极少数。

依据这条假说, 我们就不应再为了少量的跨代引用去扫描整个老年代, 也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用, 只需在新生代上建立
一个全局的数据结构 (该结构被称为 "记忆集", Remembered Set), 这个结构把老年代划分成若干小块, 标识出老年代的哪一块内存会存在跨代引用。此后
当发生 Minor GC 时, 只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots 进行扫描。虽然这种方法需要在对象改变引用关系（如将自己或者某
个属性赋值）时维护记录数据的正确性, 会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。

## 1. 常用的垃圾回收算法

1. **标记-清除算法**
先标记所有需要回收的对象, 标记完成后, 统一回收所有标记的对象 (也可以反过来, 标记存活的对象, 回收未标记的对象)。 标记的依据, 通过上面的可达 
性分析法。

存在 2 个问题:
>1. 执行效率不稳定, 标记和清除的过程会随着 Java 堆中的对象增多而变长
>2. 内存空间碎片化, 回收完成后, 会产生大量不连续的内存碎片, 空间碎片太多的话, 可能会导致后续大对象的分配找不到足够的连线内存。

2. **标记-复制算法**

为了解决**标记-清除算法** 面对大量可回收对象时执行效率低的问题。

将可用内存按容量划分为大小相等的两块, 每次只使用其中的一块。当这一块的内存用完了, 就将还存活着的对象复制到另外一块上面, 然后再把已使用过的内
存空间一次清理掉。

如果内存中多数对象都是存活的, 这种算法将会产生大量的内存间复制的开销, 但对于多数对象都是可回收的情况, 算法需要复制的就是占少数的存活对象, 而
且每次都是针对整个半区进行内存回收,分配内存时也就不用考虑有空间碎片的复杂情况, 只要移动堆顶指针, 按顺序分配即可。这样实现简单, 运行高效。  

最大的缺点: 是将可用内存缩小为了原来的一半，空间浪费未免太多了。

针对空间浪费大的问题, 有一种更优化的半区复制分代策略 - Appel 式回收。(HotSpot 采用的就是这种策略)。  

Appel 式回收: 将新生代划分为一块较大的 Eden 区域 + 两块较小的 Survivor 空间。每次分配内存只使用 Eden 和其中一块 Survivor。 发生垃圾回
收时, 将 Eden 和 Survivor 中存活的对象一次性复制到另外一块 Survivor 上, 然后把 Eden 和 已使用过的那块 Survivor 空间清理掉。 HotSpot 
默认 Eden 和 Survivor 的比例是 8:1:1, 也就是每次新生代中可使用的内存占总量的 90%。

当然, 可能一次垃圾回收时, 10 % 的 Survivor 的区域无法存放存活的对象了, Appel 式回收会通过分配担保 (Handle Promotion), 将这些对象直接
放入老年代。

当一个对象进入到 Survivor 时, 他的年龄将会 + 1, 后续在 2 个 Survivor 区来回拷贝时, 每拷贝一次, 年龄就 + 1, 当年龄达到了 15 (HotSpot 
默认的配置), 这个对象就会被移入到老年代。


3. **标记-整理算法**
**标记-复制算法**在对象存活率较高时就要进行较多的复制操作，效率将会降低。 同时无论如何还是会有空间的浪费。 所以老年代一般都会会选用这种算法。

针对老年代的特点, 有一种针对性的**标记-整理算法**, 同样的先通过标记, 确定对象是否可回收, 然后让所以存活的对象都向内存空间的一端移动, 然后清
理掉边界以外的内存。这种移动式的算法是一项优缺点并存的风险决策。    

如果移动存活对象, 尤其是在老年代这种每次回收都有大量对象存活区域, 移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作, 而且这种
对象移动操作必须全程暂停用户应用程序才能进行。  

如果不移动对象, 则会有空间碎片, 这个问题就只能依赖更为复杂的内存分配器和内存访问器来解决。

基于以上两点, 是否移动对象都存在弊端, 移动则内存回收时会更复杂, 不移动则内存分配时会更复杂。
从垃圾收集的停顿时间来看, 不移动对象停顿时间会更短, 甚至可以不需要停顿, 但是从整个程序的性能来看, 移动对象会更划算 (因内存分配和访问相比垃圾
收集频率要高得多, 这部分的耗时增加, 最终可能导致性能的下降)。

HotSpot 里面的 Parallel Scavenge 收集器是基于**标记-整理算法**的, CMS 收集器是基于**标记-清除算法**。

CMS 的实现: 平时多数时间都采用标记-清除算法, 暂时容忍内存碎片的存在, 直到内存空间的碎片化程度已经大到影响对象分配时, 再采用标记-整理算法收集
一次, 以获得规整的内存空间。

## 2. 记忆集 (Remembered Set)

记忆集是一种 "抽象" 的数据结构, 只定义了记忆集的行为意图，并没有定义其行为的具体实现。 而现在常用的的具体实现为 "卡表"(Card Table), 2 者
的关系类似于 Map 和 HashMap 的关系。

卡表最简单的形式可以只是一个字节数组。

```java
CARD_TABLE [this address >> 9] = 0;
```

字节数组 CARD_TABLE 的每一个元素都对应着其标识的内存区域中一块特定大小的内存块, 这个内存块被称作 "卡页"(Card Page)。 一般来说, 卡页大小都
是以 2 的 N 次幂的字节数, HotSpot 默认为 512 字节。如果卡表标识内存区域的起始地址是 0x0000 的话，数组 CARD_TABLE 的第 0, 1, 2 号元素，
分别对应了地址范围为 0x0000～0x01FF, 0x0200～0x03FF, 0x0400～0x05FF 的卡页内存块。

一个卡页的内存中通常包含不止一个对象，只要卡页内有一个或更多对象的字段存在着跨代指针, 那就将对应卡表的数组元素的值标识为 1, 称为这个元素变
脏(Dirty), 没有则标识为 0。 

在垃圾收集发生时, 只要筛选出卡表中变脏的元素, 就能轻易得出哪些卡页内存块中包含跨代指针, 把它们加入 GC Roots 中一并扫描。 这里是把这个区域
内的对象都加入的。

### 2.1 记忆集的维护

在 HotSpot 虚拟机里是通过写屏障 (Write Barrier) 技术维护卡表状态的 (这里的写屏障不是解决并发的读写屏障), 看作在虚拟机层面对 "引用类型字
段赋值" 这个动作的 AOP 切面，在引用对象赋值时会产生一个环形 （Around）通知, 供程序执行额外的动作, 也就是说赋值的前后都在写屏障的覆盖范畴内。
在赋值前的部分的写屏障叫作写前屏障 (Pre-Write Barrier), 在赋值 后的则叫作写后屏障 (Post-Write Barrier)。 HotSpot 虚拟机只用到了写后屏障。

```C
void oop_field_store(oop* field, oop new_value) { 
    // 引用字段赋值操作 
    *field = new_value; 
    // 写后屏障, 在这里完成卡表状态更新 
    post_write_barrier(field, new_value); 
}
```
应用写屏障后, 虚拟机就会为所有赋值操作生成相应的指令, 一旦收集器在写屏障中增加了更新卡表操作, 无论更新的是不是老年代对新生代对象的引用, 每次
只要对引用进行更新, 就会产生额外的开销, 不过这个开销与 Minor GC 时扫描整个老年代的代价相比还是低得多的。

除了写屏障的开销外, 卡表在高并发场景下还面临着 "伪共享"（False Sharing）问题。什么是伪共享可以看[这里](https://blog.csdn.net/z735640642/article/details/84554706)。 

为了避免伪共享问题，一种简单的解决方案是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏, 即将卡表更新的
逻辑变为以下代码所示:
```C
if (CARD_TABLE [this address >> 9] != 0) 
    CARD_TABLE [this address >> 9] = 0;
```

在 JDK 7 之后，HotSpot 虚拟机增加了一个新的参数 -XX: +UseCondCardMark, 用来决定是否开启卡表更新的条件判断。开启会增加一次额外判断的开销, 
但能够避免伪共享问题, 两者各有性能损耗, 是否打开要根据应用实际运行情况来进行测试权衡。

## 3. 经典垃圾收集器

![Alt 'CollectorInHotSpot'](https://raw.githubusercontent.com/PictureRespository/Java/main/JVM/CollectorInHotSpot.png)

如图, 展示了 7 款 HotSpot 常用的收集器, 收集器所处的区域, 表示了他属于哪个分代的收集器。连线表示 2 个收集器可以搭配使用 (注: JDK8 将 Serial + CMS 和
ParNew + Serial Old 声明为废弃, 并在 JDK9 中完全取消了这 2 个组合的支持)。

### 3.1 Serial 串行收集器-复制算法
Serial 是一个单线程工作的收集器。它的 "单线程" 的意义不是指只会使用一个处理器或一条收集线程去完成垃圾收集工作, 而是强调在它进行垃圾收集时, 
必须暂停其他所有工作线程, 直到它收集结束。




