# 05. 垃圾回收

## 1. 对象存活判断

在 JVM 中, 如果一个对象不被任何对象所引用的话, 那么这个对象就是可回收对象。

如何判断一个对象是可回收的话, 有 2 种方式

* 1. 引用计数算法 (Reference Counting)

在对象中添加一个引用计数器, 每当有一个地方引用它时, 计数器值就加一。当引用失效时, 计数器值就减一。任何时刻计数器为零的对象就是不可能再被使用的, 可以判定为可以回收的对象

优点: 实现简单, 判定的效率也很高  
缺点: 需要占用一下额外的内存空间, 很多复杂的情景没有考虑, 很难解决对象之间相互循环引用的问题。

```java
Obj a = new Obj();
Obj b = new Obj();

a.attr = b;
b.attr = a;
```
上面 2 个对象没有作用了, 但是互相持有对方的引用, 导致他们的引用计数不为 0, 无法回收。

在主流的 Java 虚拟机中没有选用引用计数法作用内存管理的方式。

* 2. 可达性分析算法 (Reachability Analysis)

设定一系列称为 "GC Roots" 的根对象作为起始节点集, 从这些节点开始, 根据引用关系向下搜索, 搜索过程所走过的路径称为 "引用链" （Reference Chain), 如果某个对象到 GC Roots 间没有任何引用链相连, 则证明此对象是不可能再被使用。

![Alt 'JvmRuntimeDataArea'](https://raw.githubusercontent.com/PictureRespository/Java/main/JVM/ReachabilityAnalysis.png)

如图: obj1, obj2, obj3 顺着链路, 可以达到 GC Root, 所以属于不可回收对象, 而 obj4, obj5, obj6 之间虽然有引用关系, 但是没有达到 GC Root 的链路, 所以为可回收对象。

在 Java 中, 固定可作为 GC Roots 的对象有  
1. 在虚拟机栈 (栈帧中的本地局部变量表) 中引用的对象, 比如线程调用的方法堆栈中使用到的参数, 局部变量, 临时变量等

2. 在本地方法栈中 JNI（即通常所说的Native方法）引用的对象

3. 在方法区中类静态属性引用的对象, 比如 Java 类的引用类型静态变量

4. 在方法区中常量引用的对象, 比如字符串常量池 (String Table) 里的引用

5. Java 虚拟机内部的引用, 如基本数据类型对应的 Class 对象, 一些常驻的异常对象 (比如 NullPointException, OutOfMemoryError）等,还有系统类加载器

## 2. 引用类型 - 控制对象的回收

在 JDK 1.2 版之后，Java 对引用的概念进行了扩充, 将引用分为强引用 (Strongly Reference), 软引用 (Soft Reference), 弱引用（Weak Reference）
和虚引用 (Phantom Reference) 4 种, 这 4 种引用强度依次逐渐减弱。

基于这 4 种引用, 可以让用户给间接的控制对象的回收

1. 强引用 (Strongly Reference), 传统的引用关系, 指在程序代码之中普遍存在的引用赋值, 即类似 "Object obj = new Object()" 这种引用关系。 
   无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回 收掉被引用的对象
   
2. 软引用 (Soft Reference), 用来描述一些还有用, 但非必须的对象。 只被软引用关联着的对象，在程序内存不够了, 会先尝试申请内存, 申请不到内
   存时, 才会对这些对象进行回收 (当前对象没有被别的对象强引用) 
   
3. 弱引用 (Weak Reference), 是用来描述那些非必须对象, 当对象回收的时候, 就会对其进行回收 (当前对象没有被别的对象强引用)

4. 虚引用 (Phantom Reference), 最弱的一种引用关系, 一个对象是否有虚引用的存在, 完全不会对其生存时间构成影响, 也无法通过虚引用来取得一个
   对象实例。 为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知
   
## 3. finalize 让对象再活一次

判定一个对象是否需要回收, 可以经过 2 次标记  
1. 对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链, 那它将会被第一次标记
2. 在 1 的基础上, 再进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法, 对象没有覆盖 finalize() 方法，或者 finalize() 方法
   已经被虚拟机调用过 (每个对象的 finalize 方法只会被执行一次), 那么虚拟机将这两种情况都视为 "没有必要执行", 标记为可回收
   
如果对象判定为需要执行 finalize 方法, 该对象将会先被放置在一个名为 **F-Queue** 的队列, 并在稍后由一条由虚拟机自动建立的, 低调度优先级
的 Finalizer 线程去执行它们的 finalize 方法(虚拟机会触发这个方法开始运行, 但不承诺一定会等待它运行结束, 如果某个对象的 finalize方法执行缓慢,
或者死循环等, 这会导致 F-Queue 队列的对象消除的很慢/一直处于等待, 最终可能导致系统崩溃)。

对象可以在 finalize 让自己不被回收。  
收集器将对 F-Queue 中的对象进行第二次小规模的标记时, 判定需要执行 finalize 方法。只要对象将自己和引用链上的任意一个对象进行关联, 比如把
自己 (this关键字) 赋值给某个类变量或者对象的成员变量, 那在第二次标记时它将被移出 "可回收" 的集合。

## 4. 当前垃圾回收算法的理论前提

当前大部分的垃圾收集器都遵循着 "分代收集"(Generational Collection) 的理论进行设计的, 建立在 2 个分代假设之上

1. 弱分代假说 (Weak Generational Hypothesis): 绝大多数对象都是朝生夕灭的
2. 强分代假说 (Strong Generational Hypothesis): 熬过越多次垃圾收集过程的对象就越难以消亡

根据这 2 个假说, 收集器应该将 Java 堆划分出不同的区域, 然后将回收对象依据其年龄 (年龄即对象熬过垃圾收集过程的次数) 分配到不同的区域之中存储。
1. 







