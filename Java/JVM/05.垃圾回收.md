# 05. 垃圾回收

## 1. 对象存活判断

在 JVM 中, 如果一个对象不被任何对象所引用的话, 那么这个对象就是可回收对象。

如何判断一个对象是可回收的话, 有 2 种方式

>1. 引用计数算法 (Reference Counting)

在对象中添加一个引用计数器, 每当有一个地方引用它时, 计数器值就加一。当引用失效时, 计数器值就减一。任何时刻计数器为零的对象就是不可能再被使用的, 可以判定为可以回收的对象

优点: 实现简单, 判定的效率也很高  
缺点: 需要占用一下额外的内存空间, 很多复杂的情景没有考虑, 很难解决对象之间相互循环引用的问题。

```java
Obj a = new Obj();
Obj b = new Obj();

a.attr = b;
b.attr = a;
```
上面 2 个对象没有作用了, 但是互相持有对方的引用, 导致他们的引用计数不为 0, 无法回收。

在主流的 Java 虚拟机中没有选用引用计数法作用内存管理的方式。

>2. 可达性分析算法 (Reachability Analysis)

设定一系列称为 "GC Roots" 的根对象作为起始节点集, 从这些节点开始, 根据引用关系向下搜索, 搜索过程所走过的路径称为 "引用链" （Reference Chain), 如果某个对象到 GC Roots 间没有任何引用链相连, 则证明此对象是不可能再被使用。

![Alt 'JvmRuntimeDataArea'](https://raw.githubusercontent.com/PictureRespository/Java/main/JVM/ReachabilityAnalysis.png)

如图: obj1, obj2, obj3 顺着链路, 可以达到 GC Root, 所以属于不可回收对象, 而 obj4, obj5, obj6 之间虽然有引用关系, 但是没有达到 GC Root 的链路, 所以为可回收对象。

在 Java 中, 固定可作为 GC Roots 的对象有  
1. 在虚拟机栈 (栈帧中的本地局部变量表) 中引用的对象, 比如线程调用的方法堆栈中使用到的参数, 局部变量, 临时变量等

2. 在本地方法栈中 JNI（即通常所说的 Native 方法）引用的对象

3. 在方法区中类静态属性引用的对象, 比如 Java 类的引用类型静态变量

4. 在方法区中常量引用的对象, 比如字符串常量池 (String Table) 里的引用

5. Java 虚拟机内部的引用, 如基本数据类型对应的 Class 对象, 一些常驻的异常对象 (比如 NullPointException, OutOfMemoryError）等,还有系统类加载器


**根节点枚举 (GC Roots Enumeration) - GC Roots 的确定** 

从上面列举的可作为 GC Roots 的对象列表可知, 可以作为 GC Roots 的主要在全局性的引用 (例如常量或类静态属性) 与执行上下文 (例如 栈帧中的本地变量表) 中, 尽管目标明确。但是在程序实际运行中, 真正的 GC Roots 集合会随着程序的运行变更的。所以整个可达性分析的过程, 第一步就是先确定哪些对象的是 GC  Roots, 也就是根节点枚举 (有了GC Roots 就能通过引用链查找可回收对象了)。

注: 现在所有的收集器, 在 GC Roots 这一步骤时都是必须暂停用户线程的, 也就是 “Stop the world”。而耗时更长的查找引用链的过程已经可以做到与用户线程一起并发。

根节点枚举期间要求在一个能保障一致性的快照中才得以进行, 这里的一致性指定是: 在分析过程, 借节点集合的对象引用关系不会发生变化, 所以需要暂停所有的线程。

在根节点枚举的过程, 如果一个个的变量所以符合条件的对象, 将是一个耗时的过程。 现在主流的 Java 虚拟机使用了一组称为 OopMap 的数据结构来达到优化查找的过程, 避免一个不漏的检查所有的的对象。 通过扫描 OopMap, 存储的引用类型的指针, 也就是 GC Roots 集合, 就能通过引用链找到存活的对象。

**OopMap 是怎么样更新的**?

在 HotSpot 中, 对象的类型信息里有记录自己的 OopMap, 记录了在该类型的对象内什么偏移量上是什么类型的数据, 这些数据是在类加载过程中计算得到的, 所以从对象开始向外的扫描可以是准确的。  
方法区内的静态属性引用, 常量, 这些不太会改变的 GC Roots 会在类加载成功后, 就确定好了。

对于方法栈的 GC Roots 的话，则是这样的:  
每个被 JIT 编译过后的方法会在一些**特定的位置**更新处于这个方法栈帧的 OopMap, 将执行到这个位置时, 方法栈上和寄存器里哪些位置是引用。

这些特定的位置主要在：
1、循环的末尾
2、方法临返回前 / 调用方法的 call 指令后
3、可能抛异常的位置

这种位置被称为 “安全点” (safepoint)。之所以要选择一些特定的位置来记录 OopMap, 是因为如果对每条指令（的位置）都记录 OopMap 的话, 这些记录就会比较大, 那么空间开销会显得不值得。选用一些比较关键的点来记录就能有效的缩小需要记录的数据量, 但仍然能达到区分引用的目的。因为这样, HotSpot 中 GC 不是在任意位置都可以进入, 而只能在 safepoint 处进入

对 Java 线程中的 JNI 方法, 它们既不是由 JVM 里的解释器执行的, 也不是由 JVM 的 JIT 编译器生成的, 所以会缺少OopMap 信息。那么GC碰到这样的栈帧该如何维持准确性呢？

平时这些 OopMap 都是压缩了存在内存里的, 在GC的时候才按需解压出来使用。

HotSpot 的解决方法是: 所有经过 JNI 调用边界（调用 JNI 方法传入的参数, 从 JNI 方法传回的返回值）的引用都必须用“句柄”（handle）包装起来。JNI 需要调用 Java API 的时候也必须自己用句柄包装指针。在这种实现中，JNI 方法里写的“jobject” 实际上不是直接指向对象的指针, 而是先指向一个句柄, 通过句柄才能间接访问到对象。这样在扫描到 JNI 方法的时候就不需要扫描它的栈帧了 —— 只要扫描句柄表就可以得到所有从 JNI 方法能访问到的 GC 堆里的对象。
但这也就意味着调用 JNI 方法会有句柄的包装/拆包装的开销，是导致 JNI 方法的调用比较慢的原因之一。


## 2. 引用类型 - 控制对象的回收

在 JDK 1.2 版之后，Java 对引用的概念进行了扩充, 将引用分为强引用 (Strongly Reference), 软引用 (Soft Reference), 弱引用（Weak Reference）
和虚引用 (Phantom Reference) 4 种, 这 4 种引用强度依次逐渐减弱。

基于这 4 种引用, 可以让用户给间接的控制对象的回收

1. 强引用 (Strongly Reference), 传统的引用关系, 指在程序代码之中普遍存在的引用赋值, 即类似 "Object obj = new Object()" 这种引用关系。 
   无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回 收掉被引用的对象
   
2. 软引用 (Soft Reference), 用来描述一些还有用, 但非必须的对象。 只被软引用关联着的对象，在程序内存不够了, 会先尝试申请内存, 申请不到内
   存时, 才会对这些对象进行回收 (当前对象没有被别的对象强引用) 
   
3. 弱引用 (Weak Reference), 是用来描述那些非必须对象, 当对象回收的时候, 就会对其进行回收 (当前对象没有被别的对象强引用)

4. 虚引用 (Phantom Reference), 最弱的一种引用关系, 一个对象是否有虚引用的存在, 完全不会对其生存时间构成影响, 也无法通过虚引用来取得一个
   对象实例。 为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知
   
## 3. finalize 让对象再活一次

判定一个对象是否需要回收, 可以经过 2 次标记  
1. 对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链, 那它将会被第一次标记
2. 在 1 的基础上, 再进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法, 对象没有覆盖 finalize() 方法，或者 finalize() 方法
   已经被虚拟机调用过 (每个对象的 finalize 方法只会被执行一次), 那么虚拟机将这两种情况都视为 "没有必要执行", 标记为可回收
   
如果对象判定为需要执行 finalize 方法, 该对象将会先被放置在一个名为 **F-Queue** 的队列, 并在稍后由一条由虚拟机自动建立的, 低调度优先级
的 Finalizer 线程去执行它们的 finalize 方法(虚拟机会触发这个方法开始运行, 但不承诺一定会等待它运行结束, 如果某个对象的 finalize方法执行缓慢,
或者死循环等, 这会导致 F-Queue 队列的对象消除的很慢/一直处于等待, 最终可能导致系统崩溃)。

对象可以在 finalize 让自己不被回收。  
收集器将对 F-Queue 中的对象进行第二次小规模的标记时, 判定需要执行 finalize 方法。只要对象将自己和引用链上的任意一个对象进行关联, 比如把
自己 (this关键字) 赋值给某个类变量或者对象的成员变量, 那在第二次标记时它将被移出 "可回收" 的集合。

## 4. 当前垃圾回收算法的理论前提

当前大部分的垃圾收集器都遵循着 "分代收集"(Generational Collection) 的理论进行设计的, 建立在 2 个分代假设之上

1. 弱分代假说 (Weak Generational Hypothesis): 绝大多数对象都是朝生夕灭的
2. 强分代假说 (Strong Generational Hypothesis): 熬过越多次垃圾收集过程的对象就越难以消亡

根据这 2 个假说, 收集器将 Java 堆划分出不同的区域, 然后将回收对象依据其年龄 (年龄即对象熬过垃圾收集过程的次数) 分配到不同的区域之中存储。  
1. 新生代 (Young Generation)
2. 老年代 (Old Generation)

分代收集存在的一个问题: 新生代的对象 有可能被老年代所引用, 为了确保新生代中被引用的, 需要在固定的 GC Roots 之外, 在额外变量整个老年代中所有对象来确保可达性分析结果的正确性。
 (同样, 老年代也可能被新生代所引用)。基于这个问题, 有了第三条假设  
3. 跨代引用假说 (Intergenerational Reference Hypothesis): 跨代引用相对于同代引用来说仅占极少数。

依据这条假说, 我们就不应再为了少量的跨代引用去扫描整个老年代, 也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用, 只需在新生代上建立一个全局的数据结构 (该结构被称为 "记忆集", Remembered Set), 这个结构把老年代划分成若干小块, 标识出老年代的哪一块内存会存在跨代引用。此后当发生 Minor GC 时, 只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots 进行扫描。虽然这种方法需要在对象改变引用关系（如将自己或者某个属性赋值）时维护记录数据的正确性, 会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。


## 5. 常用的垃圾回收算法

1. **标记-清除算法**
先标记处所有需要回收的对象, 标记完成后, 统一回收所有标记的对象 (也可以反过来, 标记存活的对象, 回收未标记的对象)。 标记的依据, 通过上面的可达性分析法。

存在 2 个问题:
>1. 执行效率不稳定, 标记和清除的过程会随着 Java 堆中的对象增多而变长
>2. 内存空间碎片化, 回收完成后, 会产生大量不连续的内存碎片, 空间碎片太多的话, 可能会导致后续大对象的分配找不到足够的连线内存。

2. **标记-复制算法**

为了解决**标记-清除算法** 面对大量可回收对象时执行效率低的问题。

将可用内存按容量划分为大小相等的两块, 每次只使用其中的一块。当这一块的内存用完了, 就将还存活着的对象复制到另外一块上面, 然后再把已使用过的内存空间一次清理掉。

如果内存中多数对象都是存活的, 这种算法将会产生大量的内存间复制的开销, 但对于多数对象都是可回收的情况, 算法需要复制的就是占少数的存活对象, 而且每次都是针对整个半区进行内存回收,分配内存时也就不用考虑有空间碎片的复杂情况, 只要移动堆顶指针, 按顺序分配即可。这样实现简单, 运行高效。  
最大的缺点: 是将可用内存缩小为了原来的一半，空间浪费未免太多了。

针对空间浪费大的问题, 有一种更优化的半区复制分代策略 - Appel 式回收。(HotSpot 采用的就是这种策略)。  
Appel 式回收: 将新生代划分为一块较大的 Eden 区域 + 两块较小的 Survivor 空间。每次分配内存只使用 Eden 和其中一块 Survivor。 发生垃圾回收时, 将 Eden 和 Survivor 中存活的对象一次性复制到另外一块 Survivor 上, 然后把 Eden 和 已使用过的那块 Survivor 空间清理掉。 HotSpot 默认 Eden 和 Survivor 的比例是 8:1:1, 也就是每次新生代中可使用的内存占总量的 90%。

当然, 可能一次垃圾回收时, 10 % 的 Survivor 的区域无法存放存活的对象了, Appel 式回收会通过分配担保 (Handle Promotion), 将这些对象直接放入老年代。

当一个对象进入到 Survivor 时, 他的年龄将会 + 1, 后续在 2 个 Survivor 区来回拷贝时, 每拷贝一次, 年龄就 + 1, 当年龄达到了 15 (HotSpot 默认的配置), 这个对象就会被移入到老年代。

3. **标记-整理算法**
**标记-复制算法**在对象存活率较高时就要进行较多的复制操作，效率将会降低。同时无论如何还是会有空间的浪费。所以老年代一般都会会选用这种算法。

针对老年代的特点, 有一种针对性的**标记-整理算法**, 同样的先通过标记, 确定对象是否可回收, 然后让所以存活的对象都想内存空间的一端移动, 然后清理掉边界以外的内存。这种移动式的算法是一项优缺点并存的风险决策。  
如果移动存活对象, 尤其是在老年代这种每次回收都有大量对象存活区域, 移动存活对象并更新 所有引用这些对象的地方将会是一种极为负重的操作, 而且这种对象移动操作必须全程暂停用户应用程序才能进行。  
如果不移动对象, 则会有空间碎片, 这个问题就只能依赖更为复杂的内存分配器和内存访问器来解决。

基于以上两点, 是否移动对象都存在弊端, 移动则内存回收时会更复杂, 不移动则内存分配时会更复杂。
从垃圾收集的停顿时间来看, 不移动对象停顿时间会更短, 甚至可以不需要停顿, 但是从整个程序的性能来看, 移动对象会更划算 (因内存分配和访问相比垃圾收集频率要高得多, 这部分的耗时增加, 最终可能导致性能的下降)。  
HotSpot 里面的 Parallel Scavenge 收集器是基于**标记-整理算法**的, CMS 收集器是基于**标记-清除算法**。
CMS 的实现: 平时多数时间都采用标记-清除算法, 暂时容忍内存碎片的存在, 直到内存空间的碎片化程度已经大到影响对象分配时, 再采用标记-整理算法收集一次, 以获得规整的内存空间。




## 4. 参考
[找出栈上的指针/引用](https://www.iteye.com/blog/rednaxelafx-1044951)










