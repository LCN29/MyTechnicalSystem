# 03. Java 实例对象的创建

## 1. 创建对象的方法有哪些

1. 运用 new 关键字创建实例，这是最常用的创建对象方法
2. 通过反射, 调用 java.lang.Class 的 newInstance 方法, 相当于调用一个类的无参的构造函数创建对象
3. 通过反射, 调用 java.lang.reflect.Constructor 类的 newInstance 方法, 支持无参/有参/私有的构造函数
4. 通过对象的 clone 方法, 对象需要实现 java.lang.Cloneable 接口
5. 通过反序列化, 对象需要实现 java.io.Serializable
6. 通过 sun.misc.Unsafe 的 allocateInstance 方法

其中方法 1, 2, 3 本质都是通过类的构造函数创建对象, 就是 Java 的 new 机制, 而方法 4, 5, 6 不会调用构造函数。

我们这里只讨论正常的构造函数创建对象的方式

## 2. 创建的过程

### 2.1 检查类的加载
虚拟机遇到一条 new 指令时, 首先将去检查这个指令的参数是否能在运行时常量池中定位到一个类的符号引用, 
并且检查这个符号引用代表的类是否已被加载,解析和初始化过。 如果没有, 那必须先执行相应的**类加载**过程。

### 2.2 分配内存
在类加载检查通过后, 接下来虚拟机将为新生对象分配内存。
对象所需内存的大小在类加载完成后便可完全确定, 为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。

#### 2.2.1 内存分配方式
1. 如果 Java 堆中内存是绝对规整的, 所有用过的内存都放在一边, 空闲的内存放在另一边, 中间放着一个指针作为分界点的指示器, 那所分配内存就仅仅是
   把那个指针向空闲空间那边挪动一段与对象大小相等的距离, 这种分配方式称为 "指针碰撞(Bump the Pointer)"
   
2. 如果 Java 堆中的内存并不是规整的, 已使用的内存和空闲的内存相互交错, 那就没有办法简单地进行指针碰撞了, 虚拟机就必须维护一个列表, 记录那些
   内存块是可用的, 在分配的时候从列表中找到一块足够大的空间划分给对象实例, 并更新列表上的记录, 这种分配方式称为 "空闲列表(Free List)"
   
```java
选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理（Compact）功能决定
```

#### 2.2.2 内存分配是的安全问题
对象的创建需要申请内存, 这个过程不是线程安全的, 如果现在正在给对象 A 分配内存, **临界指针/空闲列表的值**还未改变, 这时候又要一个对象 B 进行
内存的申请, 那么就可以导致线程不安全。为了解决这个问题, 有 2 种方式  
1. 是对分配内存空间的动作进行同步处理, 虚拟机是采用 CAS 加上**失败重试**的方式保证更新操作的原子性  
2. 是把内存分配的动作按照线程划分在不同的空间之中进行, 每个线程在 Java 堆中预先分配一小块内存, 称为本地线程分配缓冲 (Thread Local Allocation Buffer，TLAB),
   哪个线程要分配内存, 就在哪个线程的本地缓冲区中分配, 只有本地缓冲区用完了, 分配新的缓存区时才需要同步锁定。
   
### 2.3 空间初始化
内存分配完成后, 虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头), 如果 使用了 TLAB 的话, 这一项工作也可以提前至 TLAB 分配时顺便进行。
这步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用, 使程序能访问到这些字段的数据类型所对应的初始值。

各种数据类型的初始值:

|  类型 | 默认值 |
| :-: | :-: |
| boolean | false(0) |
| char | \u0000(unicode 编码, 转为十进制就是 0) |
| byte | 0 |
| short| 0 |
| int | 0|
| float | 0.0f |
| double | 0.0d |
| long| 0L|
| reference(引用类型) | null |


### 2.4 对象头的属性的设置
接下来, JVM 会对这个对象的对象头相关的属性进行设置, 比如对手是哪个类的实现, 将 klass Pointer 执行对应的类实例, 设置对象的
哈希码, 对象的 GC 分代年龄等。

### 2.5 执行 <init> 方法
在上面的流程, 对于虚拟机来说, 一个对象已经创建成功了。 但是从 Java 程序的视角来看, 对象的创建刚刚开始 -- init 方法未执行, 所有的字段都还是
默认值。 一般来说 init 方法是否执行, 由 new 指令后面是否跟随 invokespecial 指令决定。 Java 编译器会在遇到 new 关键字的地方同时生成这 2 
条指令, 如果不是通过 new 方式创建的, 则不会有。init 方法就是我们的构造函数, 里面按照我们的需要对对象进行初始化。

## 3. <init> 方法 和 <clinit> 方法

`<init>` 和 `<clinit>` 2 个方法是 JVM 在编译器时期, 根据我们的类和其父类生成的 2 个关于类的初始方法。简单来说
1. `<init>` 方法是当前类的代码块和构造函数的合并内容
2. `<clinit>` 则是类的静态代码块的内容

依旧先看一道经典的 Java 题
```java

public class Parent {

   private static int pNum1 = 10;

   private int pNum2 = 10;

   static {
      pNum1 = 11;
   }

   {
      pNum2 = 12;
   }

   public Parent() {
      this.pNum2 = 13;
   }
}

public class Son extends Parent {

   private static int sNum1 = 20;

   private int sNum2 = 20;

   static {
      sNum1 = 21;
   }

   {
      sNum2 = 22;
   }

   public Son() {
      this.sNum2 = 23;
   }
}
```
当我们创建 Son 的实例的时候, 上面的构造函数, 代码块, 静态代码块的执行顺序是这么样的?

上面的执行顺序差不多是这样的
1. Parent 的静态变量赋值
2. Parent 的静态代码块执行
3. Son 的静态变量赋值
4. Son 的静态代码块执行
5. Parent 的实例变量赋值
6. Parent 的代码块执行
7. Parent 的构造函数执行   
7. Son 的实例变量赋值
8. Son 的代码块执行
9. Son 的构造函数执行

出现上面的执行顺序, 主要是由 `<init>` 和 `<clinit>` 造成的。
1. `<clinit>` 主要针对我们当前类的初始化, 而 `<init>` 主要针对我们当前类的实例的初始化, 而且他的初始会先调用父级的无参 `<init>` 方法。  
2. 这里的初始化指定是我们类中的属性直接赋值执行, 代码块执行, 构造函数执行, 这三个执行最终会整合到`<init>`(实例相关的), 或者`<clinit>`(静态相关的), 并按照的执行顺序执行
3. 类加载机制中, 会先加载父类, 再加载子类。

从我们 new Son() 时, 我们先加载 Parent, 然后调用 Parent 的`<clinit>` 方法
1. 在 Parent 的 `<clinit>` 方法
1.1 执行 Parent 的属性直接赋值, 给 pNum1 赋值为 10
2.2 执行 Parent 的静态代码块, 给 pNum2 赋值为 11
2. 调用 Son 的 `<clinit>` 方法
2.1 执行 Son 的属性直接赋值, 给 sNum1 赋值为 20
2.2 执行 Son 的静态代码块, 给  sNum1 赋值为 21
3. 执行 Son 的 `<init>` 方法
3.1 `<init>` 第一步会直接调用他的直接父级的 `<init>` 方法, 也就是 Parent 的 `<init>` 方法, 然后调用自身的代码块执行, 再构造函数执行
3.2 Parent 的 `<init>` 方法, 先执行属性直接赋值, pNum2 赋值为 10
3.3 Parent 的 `<init>` 方法, 执行 Parent 的代码块, pNum2 赋值为 12
3.3 Parent 的 `<init>` 方法, 执行 Parent 的构造函数, pNum2 赋值为 13
3.4 Parent 的 `<init>` 执行完成, 执行 Son 自己的 `<init>` 方法, 直接属性赋值, sNum2 赋值为 20
3.5 Son 的代码块, sNum2 赋值为 22
3.6 Son 的构造函数, sNum3 赋值为 23
   
从上面的例子, 应该可以区分出 `<clinit>` 和 `<init>` 的作用和区别了吧
2 个方法都是 JVm 编译器时, 对我们编写的初始的整合，static 属性赋值和静态代码块整合为 clinit/实例属性赋值,代码块和构造方法整合为 init, 而且
init 方法会先调用直接父级的 init 的方法

## 4. 参考
[Java对象的创建过程详解](https://my.oschina.net/u/4942072/blog/4903326)













