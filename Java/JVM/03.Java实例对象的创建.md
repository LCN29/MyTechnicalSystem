# 03. Java 实例对象的创建

## 1. 创建对象的方法有哪些

1. 运用 new 关键字创建实例，这是最常用的创建对象方法
2. 通过反射, 调用 java.lang.Class 的 newInstance 方法, 相当于调用一个类的无参的构造函数创建对象
3. 通过反射, 调用 java.lang.reflect.Constructor 类的 newInstance 方法, 支持无参/有参/私有的构造函数
4. 通过对象的 clone 方法, 对象需要实现 java.lang.Cloneable 接口
5. 通过反序列化, 对象需要实现 java.io.Serializable
6. 通过 sun.misc.Unsafe 的 allocateInstance 方法

其中方法 1, 2, 3 本质都是通过类的构造函数创建对象, 就是 Java 的 new 机制, 而方法 4, 5, 6 不会调用构造函数。

我们这里只讨论正常的构造函数创建对象的方式

## 2. 创建的过程

### 2.1 检查类的加载
虚拟机遇到一条 new 指令时, 首先将去检查这个指令的参数是否能在运行时常量池中定位到一个类的符号引用, 
并且检查这个符号引用代表的类是否已被加载,解析和初始化过。 如果没有, 那必须先执行相应的**类加载**过程。

### 2.2 分配内存
在类加载检查通过后, 接下来虚拟机将为新生对象分配内存。
对象所需内存的大小在类加载完成后便可完全确定, 为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。

#### 2.2.1 内存分配方式
1. 如果 Java 堆中内存是绝对规整的, 所有用过的内存都放在一边, 空闲的内存放在另一边, 中间放着一个指针作为分界点的指示器, 那所分配内存就仅仅是
   把那个指针向空闲空间那边挪动一段与对象大小相等的距离, 这种分配方式称为 "指针碰撞(Bump the Pointer)"
   
2. 如果 Java 堆中的内存并不是规整的, 已使用的内存和空闲的内存相互交错, 那就没有办法简单地进行指针碰撞了, 虚拟机就必须维护一个列表, 记录那些
   内存块是可用的, 在分配的时候从列表中找到一块足够大的空间划分给对象实例, 并更新列表上的记录, 这种分配方式称为 "空闲列表(Free List)"
   
```java
选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理（Compact）功能决定
```

#### 2.2.2 内存分配是的安全问题
对象的创建需要申请内存, 这个过程不是线程安全的, 如果现在正在给对象 A 分配内存, **临界指针/空闲列表的值**还未改变, 这时候又要一个对象 B 进行
内存的申请, 那么就可以导致线程不安全。为了解决这个问题, 有 2 种方式  
1. 是对分配内存空间的动作进行同步处理, 虚拟机是采用 CAS 加上**失败重试**的方式保证更新操作的原子性  
2. 是把内存分配的动作按照线程划分在不同的空间之中进行, 每个线程在 Java 堆中预先分配一小块内存, 称为本地线程分配缓冲 (Thread Local Allocation Buffer，TLAB),
   哪个线程要分配内存, 就在哪个线程的本地缓冲区中分配, 只有本地缓冲区用完了, 分配新的缓存区时才需要同步锁定。
   
### 2.3 空间初始化
内存分配完成后, 虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头), 如果 使用了 TLAB 的话, 这一项工作也可以提前至 TLAB 分配时顺便进行。
这步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用, 使程序能访问到这些字段的数据类型所对应的初始值。

各种数据类型的初始值:


|  类型 | 默认值 |
| :-: | :-: |
| boolean | false(0) |
| char | \u0000(unicode 编码, 转为十进制就是 0) |
| byte | 0 |
| short| 0 |
| int | 0|
| float | 0.0f |
| double | 0.0d |
| long| 0L|
| reference(引用类型) | null |


### 2.4 对象头的属性的设置
接下来, JVM 会对这个对象的对象头相关的属性进行设置, 比如对手是哪个类的实现, 将 klass Pointer 执行对应的类实例, 设置对象的
哈希码, 对象的 GC 分代年龄等。

### 2.5 执行 <init> 方法
在上面的流程, 对于虚拟机来说, 一个对象已经创建成功了。 但是从 Java 程序的视角来看, 对象的创建刚刚开始 -- init 方法未执行, 所有的字段都还是
默认值。 一般来说 init 方法是否执行, 由 new 指令后面是否跟随 invokespecial 指令决定。 Java 编译器会在遇到 new 关键字的地方同时生成这 2 
条指令, 如果不是通过 new 方式创建的, 则不会有。init 方法就是我们的构造函数, 里面按照我们的需要对对象进行初始化。









