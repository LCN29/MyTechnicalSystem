# 04. synchronized 简单总结

经过上面 4 篇文章的介绍, 大体知道 synchronized 的流程, 这篇主要是对上面流程的简单梳理。


## 4.1 除了锁竞争外, 计算对象的 hashCode 值, 也会导致锁升级

在 Java 语言里面一个对象如果计算过哈希码, 需要维持不变。所以计算过一次的 hashCode 需要找一个地方存储, 而这个地方就是对象的 MarkWord。而在有锁的情况下
>1. 偏向锁, 没有地方存储了, 所以才会导致锁的降级/升级, 无锁的话, 就可以直接存储在无锁状态的 MarkWord 中
>2. 轻量级锁, Mark Word 的内容会复制的 Lock Record 的 displace mark word 中
>3. 重量级锁, Mark Word 的内容会复制的 ObjectMointor 的 _header 

无锁状态, 计算 hashCode, 直接存储在 MarkWord.

偏向锁状态, 当前没有线程持有锁的话, 计算 hashCode, 会降级为无锁。
偏向锁状态, 当前有线程持有锁的话,   计算 hashCode, 会升级为重量级锁。

轻量级锁状态, 当前有线程持有锁的话，计算 hashCode, 会升级为重量级锁。

## 4.2 匿名偏向
无锁状态没法升级为偏向锁。这里涉及到一个偏向锁的机制: 无锁和偏向锁之间, 存在一个中间状态, 匿名偏向 (anonymously biased)。锁的升级途径不存在 无锁 -> 偏向锁的情况, 只有匿名偏向 -> 偏向锁, 无锁 -> 轻量级锁/重量级锁。

在 JVM 启动后的 BiasedLockingStartupDelay 秒内, 所以创建出来的对象都是**无锁状态**, 既这个时间内的使用的锁只能是**轻量级锁和重量级锁**。在 BiasedLockingStartupDelay 秒后, 创建出来的所有的对象默认都是**匿名偏向锁状态**。

## 4.3 偏向锁

偏向锁的获取, 锁对象 lock 为匿名偏向, 在线程尝试 lock 锁, 只需要在栈中申请一个空闲的 Lock Record, 将其 obj 指向锁对象 lock, 然后将当前的线程的线程 ID 设置到 MarkWord 中即可。

偏向锁的释放, 只需要在栈中找到执行当前锁对象的 Lock Record, 将 obj 设置为 null 就行了。

如果不是匿名偏向状态, 而且当前的线程 Id 和锁对象内的线程 Id 不一致, 会导致 **锁撤销**










