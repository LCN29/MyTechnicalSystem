# 02. synchronized 偏向锁 + 轻量级锁

前提说明:

>1. 下面的介绍会以 HotSpot 的字节码解析器进行梳理。虽然 HotSpot 在运行中使用的是用汇编书写的模板解释器, 但是基于 C++ 书写的字节码更容易阅读, 而且 2 者的实现逻辑都是一样的, 所以以字节码的方式进行讲解。

>2. 通过 synchronized 的代码块的方式进行讲解, 既 monitorenter 和 monitorexit 指令。而不是方法级的, 但是 2 这的锁逻辑都是类似的

>3. 下面全部以伪代码的实行进行讲解, 同时会附上源代码的位置, 有兴趣的话, 可以进行了解。

>4. 下面的代码逻辑都基于 JDK 8 的 HotSpot 源码


## 2.1 偏向锁

在大多数情况下，锁是不存在竞争的，而且总是由一个线程持有，所以可以在使用 synchronized 的时候，可以不去真正的获取锁，而减少获取锁的代价。

偏向锁默认当前的锁是无竞争的，他偏向于第一个获得他的线程。在第一次获取这个锁的线程，不进行真正的锁对象（monitor）获取，只是把我们的对象的对象头从无锁状态转为偏向锁状态，并且把这个线程 Id 记录在对象头里，后续只要这个锁没有被其他线程获取，那么这个线程就无需要进行同步，就能进入到同步代码块。

源代码[地址](http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/interpreter/bytecodeInterpreter.cpp#l1816)

OK, 上代码, code-01

```Java
CASE(_monitorenter): {

    //  获取当前锁对象
    Lock lock = getLock();
    // 从栈中获取一个 锁记录
    LockRecord lockRecord = getLockRecordFromStack();

    // 获取不到 Lock Record, 执行执行这个指令
    if (lockRecord == null) {
        // 重新执行
        reExecute();
        return;
    }

    // 下面执行锁逻辑
}
```

从上面的代码可以发现:
1. 无论是什么锁, 进来就会获取到一个 空闲的 LockRecord (LockRecord 的 obj 属性为空的话, 就是空闲的)
2. LockRecord 是从栈中获取的, 而不是从栈帧


* 结论 1 分析  

在源代码中, getLockRecordFromStack 的实现逻辑是这样的

```C++
// find a free monitor or one already allocated for this object
// if we find a matching object then we need a new monitor
// since this is recursive enter
BasicObjectLock* limit = istate->monitor_base();
BasicObjectLock* most_recent = (BasicObjectLock*) istate->stack_base();
BasicObjectLock* entry = NULL;
while (most_recent != limit ) {
    if (most_recent->obj() == NULL) entry = most_recent;
    else if (most_recent->obj() == lockee) break;
    most_recent++;
}
```
上面的 BasicObjectLock 就是我们说的 Lock Record。 


* 通过上面的备注和结合下面的代码逻辑, 可以知道: **进入 monitorenter, 会在私有线程栈找到一个最近并且空闲的区域, 创建一个Lock Record，里面属性为 null**


而且在同步方法的入口处, 源码[位置]()
```C++
if (METHOD->is_synchronized()) {

    oop rcvr;
    if (METHOD->is_static()) {
        // 静态方法锁的是 类
        rcvr = METHOD->constants()->pool_holder()->java_mirror();
    } else {
        // 非静态方法锁的是实例
        rcvr = LOCALS_OBJECT(0);
        VERIFY_OOP(rcvr);
    }

    // The initial monitor is ours for the taking.

    // Monitor not filled in frame manager any longer as this caused race condition with biased locking.
    BasicObjectLock* mon = &istate->monitor_base()[-1];
    mon->set_obj(rcvr);

    // 省略
}
```

The initial monitor is ours for the taking: 最初的 monitor 由我们获取。
可以得知: 在方法的开始, 就已经会有一个初始的 monitor !

综上: 可以得知, Lock Record 在进入方法时就产生了, 而不是在锁升级到轻量锁的时候, 才产生, 每一块 synchronized 代码块都需要一个空闲的 Lock Record.

**上面的结论: 个人基于源码里面的备注分析的, 和当前网上的大部分看法有冲突**

* 结论 2 分析

方法 monitor_base() 返回一个属性 _monitor_base 其备注: base of monitors on the native stack   
方法 stack_base() 返回的是一个属性 _monitor_base 备注: base of expression stack  

2 个参数的备注都是本地方法栈和虚拟机栈, 这是我怀疑 Lock Record 存放在栈的条件之一。  
第二个条件, 同样是在同步方法的入口处的备注: **Monitor not filled in frame manager any longer as this caused race condition with biased locking**。 Moitor 不再填充在帧管理器, 因为这将导致偏向锁的竞态条件。

所以有着 Lock Record 存放在栈, 而是栈帧的结论。网上的普遍看法都是 Lock Record 是存放在栈帧中。个人认为是 synchronized 在不同版本的实现不一致导致的。

在官网的这篇介绍 synchronized 的[文章](https://wiki.openjdk.java.net/display/HotSpot/Synchronization)中, 明确说的了 Record Lock 是存放在栈帧的, 但是文章的编写是**Apr 29, 2008**, 上面的备注在 JDK6 也是没有的, [源码地址](http://hg.openjdk.java.net/jdk6/jdk6/hotspot/file/d9c3790c85c1/src/share/vm/interpreter/bytecodeInterpreter.cpp#l671), 到了 JDK 8 才出现的备注。

在 JDK 8 中, 只有基于上面的 2 点, 才能执行往下分析代码！当然上面都是个人和网上普遍说法不一样的猜测, 不强求认可。






