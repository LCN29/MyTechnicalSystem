# 02. synchronized 偏向锁 + 轻量级锁

前提说明:

>1. 下面的介绍会以 HotSpot 的字节码解析器进行梳理。虽然 HotSpot 在运行中使用的是用汇编书写的模板解释器, 但是基于 C++ 书写的字节码更容易阅读, 而且 2 者的实现逻辑都是一样的, 所以以字节码的方式进行讲解。

>2. 通过 synchronized 的代码块的方式进行讲解, 既 monitorenter 和 monitorexit 指令。而不是方法级的, 但是 2 这的锁逻辑都是类似的

>3. 下面全部以伪代码的实行进行讲解, 同时会附上源代码的位置, 有兴趣的话, 可以进行了解。

>4. 下面的代码逻辑都基于 JDK 8 的 HotSpot 源码


## 2.1 偏向锁

在大多数情况下，锁是不存在竞争的，而且总是由一个线程持有，所以可以在使用 synchronized 的时候，可以不去真正的获取锁，而减少获取锁的代价。

偏向锁默认当前的锁是无竞争的，他偏向于第一个获得他的线程。在第一次获取这个锁的线程，不进行真正的锁对象（monitor）获取，只是把我们的对象的对象头从无锁状态转为偏向锁状态，并且把这个线程 Id 记录在对象头里，后续只要这个锁没有被其他线程获取，那么这个线程就无需要进行同步，就能进入到同步代码块。

源代码[地址](http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/interpreter/bytecodeInterpreter.cpp#l1816)


### 2.1.1 代码分析 - Code-01
```Java
CASE(_monitorenter): {

    //  获取当前锁对象
    Lock lock = getLock();
    // 从栈中获取一个 锁记录
    LockRecord lockRecord = getLockRecordFromStackOrStackFrame();

    // 获取不到 Lock Record, 执行执行这个指令
    if (lockRecord == null) {
        // 重新执行
        reExecute();
        return;
    }

    // 下面执行锁逻辑
}
```

从上面的代码可以发现:
1. 无论是什么锁, 进来就会获取到一个空闲的 LockRecord (LockRecord 的 obj 属性为空的话, 就是空闲的)
2. LockRecord 可能分配在栈中, 现在普遍的说法是分配在栈帧中


**结论 1 分析**  

在源代码中, getLockRecordFromStackOrStackFrame 的实现逻辑是这样的

```C++
// find a free monitor or one already allocated for this object
// if we find a matching object then we need a new monitor
// since this is recursive enter
BasicObjectLock* limit = istate->monitor_base();
BasicObjectLock* most_recent = (BasicObjectLock*) istate->stack_base();
BasicObjectLock* entry = NULL;
while (most_recent != limit ) {
    if (most_recent->obj() == NULL) entry = most_recent;
    else if (most_recent->obj() == lockee) break;
    most_recent++;
}
```
上面的 BasicObjectLock 就是我们说的 Lock Record。 

通过上面的备注和结合下面的代码逻辑, 可以知道: **进入 monitorenter, 会在私有线程栈/栈帧找到一个最近并且空闲的区域, 创建一个Lock Record，里面属性为 null**

而且在同步方法的入口处, 源码[位置](http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/interpreter/bytecodeInterpreter.cpp#l683)
```C++
if (METHOD->is_synchronized()) {

    oop rcvr;
    if (METHOD->is_static()) {
        // 静态方法锁的是 类
        rcvr = METHOD->constants()->pool_holder()->java_mirror();
    } else {
        // 非静态方法锁的是实例
        rcvr = LOCALS_OBJECT(0);
        VERIFY_OOP(rcvr);
    }

    // The initial monitor is ours for the taking.

    // Monitor not filled in frame manager any longer as this caused race condition with biased locking.
    BasicObjectLock* mon = &istate->monitor_base()[-1];
    mon->set_obj(rcvr);

    // 省略
}
```

The initial monitor is ours for the taking: 最初的 monitor 由我们获取。
可以得知: 在方法的开始, 就已经会有一个初始的 monitor !

综上: 可以得知, Lock Record 在进入方法时就产生了, 而不是在锁升级到轻量锁的时候才产生, 每一块 synchronized 代码块都需要一个空闲的 Lock Record。

**上面的结论: 个人基于源码里面的备注分析的, 和当前网上的大部分看法有冲突**

**结论 2 分析**  

同样是在同步方法的入口处的备注: **Monitor not filled in frame manager any longer as this caused race condition with biased locking(Moitor 不再填充在帧管理器, 因为这将导致偏向锁的竞态条件)**。  

这段注释是在 JDK 8 中才出现的, JDK 6, 7 都没有。

所以有着 Lock Record 存放在栈, 而是栈帧的结论。网上的普遍看法都是 Lock Record 是存放在栈帧中。个人认为是 synchronized 在不同版本的实现不一致导致的。

在官网的这篇编写于 2008 年介绍 synchronized 的[文章](https://wiki.openjdk.java.net/display/HotSpot/Synchronization)中, 明确说的了 Record Lock 是存放在栈帧的。上面的备注在 JDK6 也是没有的, [源码地址](http://hg.openjdk.java.net/jdk6/jdk6/hotspot/file/d9c3790c85c1/src/share/vm/interpreter/bytecodeInterpreter.cpp#l671), 而是到了 JDK 8 才出现的备注。

在 Oracle 的官网中另一篇编写于 2006 年介绍 synchronized 的[文章](https://www.oracle.com/technetwork/java/biasedlocking-oopsla2006-wp-149958.pdf) 中对的 Lock Record 做了更详细的介绍:  
**在解释执行过程中, 栈帧中有一块区域用于存储 Lock Record, 这块区域会随着方法的执行变大或缩小**  
**在编译执行过程中, 是没有这块区域的, 而是以一个类似的方式存储在 register spill stack slots**  

说这么多, 就是网上的说法普遍都是对的, 但是可能随着 JDK 的发展, 有了变化, 或者是**个人理解错了**

### 2.1.2 代码分析 - Code-02

```java
CASE(_monitorenter): {

    Lock lock = getLock();
    LockRecord lockRecord = getLockRecordFromStackOrStackFrame();
    if (lockRecord == null) {
        reExecute();
        return;
    }
    // 设置当前的 Lock Record 的 obj 指向当前的锁
    lockRecord.setObj(lock);
    // 获取当前锁对象的 MarkWord
    MarkWord markWord = lock.getMarkWord();
    // 获取当前的 markWord 的 hash 值
    int hash = markWord.getHash();
    // 偏向锁获取结果
    boolean biasLockGetResult = false;

    // 当前对象的 MarkWord 是否为偏向锁状态, 既最后 3 位是否为 101
    if (markWord.hasBiasPattern()) {
        // 尝试获取偏向锁逻辑
    }

    // 偏向锁获取失败, 进行锁升级
    if (!biasLockGetResult) {
        // 轻量级锁逻辑
    }

    // 执行下一条指令
    executeNextInstruction();
}
```

从上面的逻辑走下去, 会发现一个有趣的状态: **无锁状态没法升级为偏向锁**。

这里涉及到一个偏向锁的机制: 无锁和偏向锁之间, 存在一个中间状态, 匿名偏向 (anonymously biased)。既锁升级的途径 无锁 -> 匿名偏向 -> 偏向锁 !

匿名偏向: 就是偏向锁的状态, 但是偏向的线程 ID 为 0, 表示不偏向任何线程

匿名偏向, 涉及一个虚拟机配置 -XX:BiasedLockingStartupDelay=xx 单位毫秒

在 JVM 启动后的 BiasedLockingStartupDelay 秒内, 所以创建出来的对象都是**无锁状态**, 既这个时间内的使用的锁只能是**轻量级锁和重量级锁**。在 BiasedLockingStartupDelay 秒后, 创建出来的所有的对象默认都是**匿名偏向锁状态**。

如图:
![Alt 'AnonymouslyBiasedLock'](https://raw.githubusercontent.com/PictureRespository/Java/main/JUC/AnonymouslyBiasedLock.png)

上面的逻辑可以理通了！在程序运行中的情况, Java 对象都是匿名偏向状态, 不存在无锁的情况！

如果需要关闭这种情况的话, 可以通过下面的几个参数进行设置:
> -XX:+UseHeavyMonitors  只使用重量锁
> -XX:+/-UseBiasedLocking  启用/关闭 偏向锁, JDK 6 后默认为启用状态
> -XX:BiasedLockingStartupDelay=0  关闭延迟开启偏向锁

### 2.1.3 代码分析 - Code-03

```java
CASE(_monitorenter): {

    Lock lock = getLock();
    LockRecord lockRecord = getLockRecordFromStackOrStackFrame();
    if (lockRecord == null) {
        reExecute();
        return;
    }

    lockRecord.setObj(lock);
    MarkWord markWord = lock.getMarkWord();
    int hash = markWord.getHash();
    boolean biasLockGetResult = false;

    if (markWord.hasBiasPattern()) {
        // 尝试获取偏向锁逻辑

        // 当前偏向锁指向的线程等于当前线程和 锁里面的 epoch 等于当前锁对象的类的 PrototyHeader 属性的 epoch
        if (threadIdInBasicLockEqualCurrentThread() 
        && epochInBasicLockEqualEpochInCurrentLockClassPrototypeHeader()) {
            // 当前线程已经持有了偏向锁, 不做任何事情, 结束
            biasLockGetResult = true;
        }

    }

    // 偏向锁获取失败, 进行锁升级
    if (!biasLockGetResult) {
        // 轻量级锁逻辑
    }

    executeNextInstruction();
}
```

**PrototypeHeader**  
在 class 中有 2 个属性, markWord 和 prototypeHeader, 因为 class 也是一个对象, 可以做为锁, 理所当然的也有一个自己的 markWork, 而 prototypeHeader 是 class 另一个属性, 主要用于在启用偏向锁配置的情况下, 创建出来的对象的 markWord 默认属性

```C++
// 根据是否启用偏向锁，设置对象头信息
if (UseBiasedLocking) {
    result->set_mark(ik->prototype_header());
} else {
    result->set_mark(markOopDesc::prototype());
}
```
prototypeHeader 的值
| 持有锁线程 Id | Epoch | 分代年龄 | 是否偏向锁标志| 锁标志位 |
| :-: | :-:  | :-: | :-: | :-: |
| 0 | 当前的 Epoch  | 0  | 1 |  01 |

**线程 Id 和 Epoch 都相同的判断**

在上面的伪代码中将线程 Id 和 Epoch 的判断分成了 2 步, 但是在源码中是通过计算出一个值, 比较预期值判断的

```C++
anticipated_bias_locking_value =
    (((uintptr_t)lockee->klass()->prototype_header() | thread_ident) ^ (uintptr_t)mark) & ~((uintptr_t) markOopDesc::age_mask_in_place);

// 线程 Id 和 epoch 都一样
if(anticipated_bias_locking_value == 0) {

}    
```

上面的代码的可以分为 4 步进行分析

第一步: **((uintptr_t)lockee->klass()->prototype_header() | thread_ident)** 将当前线程 Id 和 class 的 prototype_header 相或。这样得到的值为: 当前的线程 Id + class 的 Epoch + 分代年龄 + 偏向锁标志 + 锁状态, 也就是 **23位的线程 Id + 2 位的 Epoch + 0000101**, class prototypeHeader 的年龄代默认为 0, 4 位

第二步: **^ (uintptr_t)mark**, 将第一步的结果和当前锁的 markWord 进行异或操作(相等的位全部被置为 0)！那么我们能确定的结果只有最后 3 位为 000

第三步: **~((uintptr_t) markOopDesc::age_mask_in_place)** 只获取当前锁对象的年龄待,进行取反(1 变为 0, 0 变为 1), 那么可以知道结果为 25 个 1 + 4 个未知的年龄代 + 3 个 1

第四步: **&** 将第 2 步和第 3 步的结果进行与操作(都为 1, 才为 1)

在第 2 步的年龄代的值, 就是当前锁的年龄代, 第 3 步的年龄代的值, 就是当前年龄代的值的取反, 那么就是在 & 操作后，得到的值最后面 7 位都为 0, 而第 3 步的值前 25 位的值都为 1, 那么最终的结果, 只需要考虑第 2 步的前 25 位。当当前的线程 Id 和 锁里面的线程 Id 相等, 前 23 位都为 0, 当锁里面的 epoch 和 class prototye_header 的 epoch 都相等, 第 24 和 25 为都为 0,

那么在 线程 Id 都相同和 epoch 都相同的情况, 最终的值就是 0 

**偏向锁里面的 Epoch 作用**

epoch 主要用于解决**重偏向**。首先重偏向主要用于处理锁实例的情况, 锁类的情况没法处理的。
重偏向, 从字面意思就能知道了, 某个实例锁当前是偏向了线程 A, 线程 B 获取这个实例锁时, 应该升级为轻量级锁变为偏向自己的偏向锁。

机制的流程
1. 类 C 下有很多个实例被当做锁, 当前都是偏向锁, 类 C 和各个实例的 epoch 都是一样的
2. 这些锁突然出现了多次的锁升级, 每次偏向锁升级为轻量级锁, 会在类 C 内部维护一个数字加 1
3. 线程 A 获取类 C 下一个偏向锁实例 I, 本来应该是会升级为轻量级锁的, 但是类 C 内部维护的上限达到了 X
4. 类 C 的 epoch + 1, 找到所有的类 C 的 **MonitorInfo**, 修改他们的 epoch = 类 C 的 epoch, 此时偏向锁内部的偏向的线程 Id 没有修改, 因为修改了会破坏锁的线程安全性
5. 当前线程 A 获取的实例 I, 从升级轻量级锁变为偏向锁, 偏向的线程为 A
6. 那么这些锁实例, 在线程下次尝试获取锁时, 当前实例的 epoch 和 class 的 epoch 不一致, 会先进入偏向锁, 不会立即升级为轻量级锁

例子:

```java

List<Lock> list = new ArrayList<>();

new Thread(()->{

    for (int i = 0; i < 30; i++) {
        Lock lock =  new Lock();
        list.add(lock);
        // Lock 下有多个实例被偏向锁锁住
        synchronized(lock) {
            // 打印对象头信息, 都是偏向锁
            System.out.println(ClassLayout.parseInstance(lock).toPrintable()); 
        }
    }

}, "thread-01").start();

// 让上面的线程跑一下
Thead.sleep(5000L);


for (int i = 0; i < 30; i++) {

    Lock lock =  list.get(i);

    // Importance 这里打印的结果和上面的线程 thread-01 的完全一样
    System.out.println(ClassLayout.parseInstance(lock).toPrintable()); 

    // 下面的打印情况, 0-18都是轻量级锁, 19 后面都是偏向锁
    synchronized(lock) {
        // 打印对象头信息, 都是偏向锁
        System.out.println(ClassLayout.parseInstance(lock).toPrintable()); 
    }
}
```

下面的可以等到批量重偏向的时候, 过来回顾！

**MonitorInfo**: 源码中的备注为 **MonitorInfos for all objects locked on this thread in youngest to oldest order**。这里的 MonitorInfo, 猜测应该是重量级锁实现的 ObjectMonitor! 而不是**该 klass 的所有锁实例**。

原因: 上面的 Importance 的输出结果, 在 i = 19 后, 重偏向了, 如果所有锁实例的 epoch 应该会 + 1, 但是输出结果却是和一开始的一样, 没变。


上面的上限  X, 默认为 20, 可以通过 **-XX:BiasedLockingBulkRebiasThreshold**, 进行设置

### 2.1.3 代码分析 - Code-04

```java
CASE(_monitorenter): {

    Lock lock = getLock();
    LockRecord lockRecord = getLockRecordFromStackOrStackFrame();
    if (lockRecord == null) {
        reExecute();
        return;
    }

    lockRecord.setObj(lock);
    MarkWord markWord = lock.getMarkWord();
    int hash = markWord.getHash();
    boolean biasLockGetResult = false;
    if (markWord.hasBiasPattern()) {
        // 尝试获取偏向锁逻辑

        if (threadIdInBasicLockEqualCurrentThread() 
        && epochInBasicLockEqualEpochInCurrentLockClassPrototypeHeader()) {

            // 情景 1: 锁当前就是偏向的当前线程, 不做任何事情了

            biasLockGetResult = true;
        } else if (biasedModeInClassHadClose()) {

            // 情景 2:  当前 class 的偏向锁模式关闭了

            // 获取锁对应 class 的 prototypeHeader 属性, 也就是实例创建是默认的 markWord
            MarkWord header = lock.getClass().getPrototypeHeader();
            if (hash != markWord.getHash()) {
                header.copySetHash(hash);
            }
            // TODO 源码这样, 不会导致年龄代信息丢失? 

            // 利用 CAS 操作将 markWord 替换为 class 中的 prototypeHeader 的 markWord
            if (CAS(header, lock.getMarkWord(), markWord) == markWord) {
                // 源码中，做了一些锁操作的分析统计, 不涉及锁逻辑
            }

        } else if (epochInClassInstanceNoEqualEpochInClass()) {

            // 情景 3: 有线程触发了重偏向, 当前锁实例的 epoch 和 class 的 epoch 不一致

            // epoch 不一致了, 先尝试重偏向, 不升级锁

            // 构建一个偏向当前线程的 MarkWord 
            MarkWord newHeader = lock.getClas().getPrototypeHeader() | currentTheadId();
            if (hash != markWord.getHash()) {
                newHeader.copySetHash(hash);
            }
            // TODO 源码这样, 不会导致年龄代信息丢失? 

            if(CAS(newHeader, lock.getMarkWord(), markWord) == markWord) {
                // 源码中，做了一些锁操作的分析统计, 不涉及锁逻辑
            } else {
                // 重偏向失败, 代表存在多线程竞争, 则调用 InterpreterRuntime.monitorenter 方法进行锁升级
                InterpreterRuntime.monitorenter(currentThread(), lockRecord);
            }
            biasLockGetResult = true;
        } else {

            // 情景 4: 走到这里的, 只有锁偏向的线程和当前的线程不一样了, 那么有可能是匿名偏向, 线程 Id 完成不一样
            // 要么就是 线程 Id 真的完全不一样

            // 创建一个和当前锁对象的 MarkWord 一样但是没有线程 ID 的 MarkWord
            MarkWord header = createMarkWordWithoutThreadId(markWord);

            if (hash != markWord.getHash()) {
                header.copySetHash(hash);
            }
            // 构建一个偏向当前线程的 MarkWord 
            MarkWord newHeader = header | currentTheadId();

            if(CAS(newHeader, lock.getMarkWord(), markWord) == markWord) {
                // 源码中，做了一些锁操作的分析统计, 不涉及锁逻辑
            } else {
                // 重偏向失败, 代表存在多线程竞争, 则调用 InterpreterRuntime.monitorenter 方法进行锁升级
                InterpreterRuntime.monitorenter(currentThread(), lockRecord);
            }
            biasLockGetResult = true;
        }

    }

    // 偏向锁获取失败, 进行锁升级
    if (!biasLockGetResult) {
        // 轻量级锁逻辑
    }

    executeNextInstruction();
}
```

上面的伪代码中

**CAS**  
CAS(修改后的值, 要修改的对象, 预期的值(修改前的值)), 返回值为实际的原值

**4 种场景**
上面的 4 种情景应该都不难理解, 有点要说明的, 只有第 4 种情况了, 在第 4 中情况中, header 变量里面是没有线程 Id 的, 所以当前锁对象的匿名偏向锁, 就是简单的偏向锁了,
但是如果已经偏向了别的线程, 那么 CAS 是会失败, 走入到锁升级的情况
















