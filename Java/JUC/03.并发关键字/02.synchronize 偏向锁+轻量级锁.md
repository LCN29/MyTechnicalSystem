# 02. synchronized 偏向锁 + 轻量级锁

前提说明:

>1. 下面的介绍会以 HotSpot 的字节码解析器进行梳理。虽然 HotSpot 在运行中使用的是用汇编书写的模板解释器, 但是基于 C++ 书写的字节码更容易阅读, 而且 2 者的实现逻辑都是一样的, 所以以字节码的方式进行讲解。

>2. 通过 synchronized 的代码块的方式进行讲解, 既 monitorenter 和 monitorexit 指令。而不是方法级的, 但是 2 这的锁逻辑都是类似的

>3. 下面全部以伪代码的实行进行讲解, 同时会附上源代码的位置, 有兴趣的话, 可以进行了解。

>4. 下面的代码逻辑都基于 JDK 8 的 HotSpot 源码


## 2.1 偏向锁

在大多数情况下，锁是不存在竞争的，而且总是由一个线程持有，所以可以在使用 synchronized 的时候，可以不去真正的获取锁，而减少获取锁的代价。

偏向锁默认当前的锁是无竞争的，他偏向于第一个获得他的线程。在第一次获取这个锁的线程，不进行真正的锁对象（monitor）获取，只是把我们的对象的对象头从无锁状态转为偏向锁状态，并且把这个线程 Id 记录在对象头里，后续只要这个锁没有被其他线程获取，那么这个线程就无需要进行同步，就能进入到同步代码块。

源代码[地址](http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/interpreter/bytecodeInterpreter.cpp#l1816)


### 2.1.1 代码分析 - Code-01
```Java
CASE(_monitorenter): {

    //  获取当前锁对象
    Lock lock = getLock();
    // 从栈中获取一个 锁记录
    LockRecord lockRecord = getLockRecordFromStackOrStackFrame();

    // 获取不到 Lock Record, 执行执行这个指令
    if (lockRecord == null) {
        // 重新执行
        reExecute();
        return;
    }

    // 下面执行锁逻辑
}
```

从上面的代码可以发现:
1. 无论是什么锁, 进来就会获取到一个空闲的 LockRecord (LockRecord 的 obj 属性为空的话, 就是空闲的)
2. LockRecord 可能分配在栈中, 现在普遍的说法是分配在栈帧中


**结论 1 分析**  

在源代码中, getLockRecordFromStackOrStackFrame 的实现逻辑是这样的

```C++
// find a free monitor or one already allocated for this object
// if we find a matching object then we need a new monitor
// since this is recursive enter
BasicObjectLock* limit = istate->monitor_base();
BasicObjectLock* most_recent = (BasicObjectLock*) istate->stack_base();
BasicObjectLock* entry = NULL;
while (most_recent != limit ) {
    if (most_recent->obj() == NULL) entry = most_recent;
    else if (most_recent->obj() == lockee) break;
    most_recent++;
}
```
上面的 BasicObjectLock 就是我们说的 Lock Record。 

通过上面的备注和结合下面的代码逻辑, 可以知道: **进入 monitorenter, 会在私有线程栈/栈帧找到一个最近并且空闲的区域, 创建一个Lock Record，里面属性为 null**

而且在同步方法的入口处, 源码[位置](http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/interpreter/bytecodeInterpreter.cpp#l683)
```C++
if (METHOD->is_synchronized()) {

    oop rcvr;
    if (METHOD->is_static()) {
        // 静态方法锁的是 类
        rcvr = METHOD->constants()->pool_holder()->java_mirror();
    } else {
        // 非静态方法锁的是实例
        rcvr = LOCALS_OBJECT(0);
        VERIFY_OOP(rcvr);
    }

    // The initial monitor is ours for the taking.

    // Monitor not filled in frame manager any longer as this caused race condition with biased locking.
    BasicObjectLock* mon = &istate->monitor_base()[-1];
    mon->set_obj(rcvr);

    // 省略
}
```

The initial monitor is ours for the taking: 最初的 monitor 由我们获取。
可以得知: 在方法的开始, 就已经会有一个初始的 monitor !

综上: 可以得知, Lock Record 在进入方法时就产生了, 而不是在锁升级到轻量锁的时候才产生, 每一块 synchronized 代码块都需要一个空闲的 Lock Record。

**上面的结论: 个人基于源码里面的备注分析的, 和当前网上的大部分看法有冲突**

**结论 2 分析**  

同样是在同步方法的入口处的备注: **Monitor not filled in frame manager any longer as this caused race condition with biased locking(Moitor 不再填充在帧管理器, 因为这将导致偏向锁的竞态条件)**。  

这段注释是在 JDK 8 中才出现的, JDK 6, 7 都没有。

所以有着 Lock Record 存放在栈, 而是栈帧的结论。网上的普遍看法都是 Lock Record 是存放在栈帧中。个人认为是 synchronized 在不同版本的实现不一致导致的。

在官网的这篇编写于 2008 年介绍 synchronized 的[文章](https://wiki.openjdk.java.net/display/HotSpot/Synchronization)中, 明确说的了 Record Lock 是存放在栈帧的。上面的备注在 JDK6 也是没有的, [源码地址](http://hg.openjdk.java.net/jdk6/jdk6/hotspot/file/d9c3790c85c1/src/share/vm/interpreter/bytecodeInterpreter.cpp#l671), 而是到了 JDK 8 才出现的备注。

在 Oracle 的官网中另一篇编写于 2006 年介绍 synchronized 的[文章](https://www.oracle.com/technetwork/java/biasedlocking-oopsla2006-wp-149958.pdf) 中对的 Lock Record 做了更详细的介绍:  
**在解释执行过程中, 栈帧中有一块区域用于存储 Lock Record, 这块区域会随着方法的执行变大或缩小**  
**在编译执行过程中, 是没有这块区域的, 而是以一个类似的方式存储在 register spill stack slots**  

说这么多, 就是网上的说法普遍都是对的, 但是可能随着 JDK 的发展, 有了变化, 或者是**个人理解错了**




```Java
CASE(_monitorenter): {

    //  获取当前锁对象
    Lock lock = getLock();
    // 从栈中获取一个 锁记录
    LockRecord lockRecord = getLockRecordFromStackOrStackFrame();

    // 获取不到 Lock Record, 执行执行这个指令
    if (lockRecord == null) {
        // 重新执行
        reExecute();
        return;
    }

    // 下面执行锁逻辑
}
```









### 2.1.2 代码分析 - Code-02

```java
CASE(_monitorenter): {

    Lock lock = getLock();
    LockRecord lockRecord = getLockRecordFromStackOrStackFrame();
    if (lockRecord == null) {
        reExecute();
        return;
    }
    // 设置当前的 Lock Record 的 obj 指向当前的锁
    lockRecord.setObj(lock);
    // 获取当前锁对象的 MarkWord
    MarkWord markWord = lock.getMarkWord();

    // 偏向锁获取结果
    boolean biasLockGetResult = false;

    // 当前对象的 MarkWord 是否为偏向锁状态, 既最后 3 位是否为 101
    if (markWord.hasBiasPattern()) {
        // 尝试获取偏向锁逻辑
    }

    // 偏向锁获取失败, 进行锁升级
    if (!biasLockGetResult) {
        // 轻量级锁逻辑
    }

    // 执行下一条指令
    executeNextInstruction();
}
```

从上面的逻辑走下去, 会发现一个有趣的状态: **无锁状态没法升级为偏向锁**。

这里涉及到一个偏向锁的机制: 无锁和偏向锁之间, 存在一个中间状态, 匿名偏向 (anonymously biased)。既锁升级的途径 无锁 -> 匿名偏向 -> 偏向锁 !

匿名偏向: 就是偏向锁的状态, 但是偏向的线程 ID 为 0, 表示不偏向任何线程

匿名偏向, 涉及一个虚拟机配置 -XX:BiasedLockingStartupDelay=xx 单位毫秒

在 JVM 启动后的 BiasedLockingStartupDelay 秒内, 所以创建出来的对象都是**无锁状态**, 既这个时间内的使用的锁只能是**轻量级锁和重量级锁**。在 BiasedLockingStartupDelay 秒后, 创建出来的所有的对象默认都是**匿名偏向锁状态**。

如图:
![Alt 'AnonymouslyBiasedLock'](https://raw.githubusercontent.com/PictureRespository/Java/main/JUC/AnonymouslyBiasedLock.png)

上面的逻辑可以理通了！在程序运行中的情况, Java 对象都是匿名偏向状态, 不存在无锁的情况！

如果需要关闭这种情况的话, 可以通过下面的几个参数进行设置:
> -XX:+UseHeavyMonitors  只使用重量锁
> -XX:+/-UseBiasedLocking  启用/关闭 偏向锁, JDK 6 后默认为启用状态
> -XX:BiasedLockingStartupDelay=0  关闭延迟开启偏向锁

### 2.1.3 代码分析 - Code-03

```java
CASE(_monitorenter): {

    Lock lock = getLock();
    LockRecord lockRecord = getLockRecordFromStackOrStackFrame();
    if (lockRecord == null) {
        reExecute();
        return;
    }

    lockRecord.setObj(lock);
    MarkWord markWord = lock.getMarkWord();
    boolean biasLockGetResult = false;

    if (markWord.hasBiasPattern()) {
        // 尝试获取偏向锁逻辑

        // 当前偏向锁指向的线程等于当前线程和 锁里面的 epoch 等于当前锁对象的类的 PrototyHeader 属性的 epoch
        if (threadIdInBasicLockEqualCurrentThread() 
        && epochInBasicLockEqualEpochInCurrentLockClassPrototypeHeader()) {
            // 当前线程已经持有了偏向锁, 不做任何事情, 结束
            biasLockGetResult = true;
        }

    }

    // 偏向锁获取失败, 进行锁升级
    if (!biasLockGetResult) {
        // 轻量级锁逻辑
    }

    executeNextInstruction();
}
```

**PrototypeHeader**  
在 class 中有 2 个属性, markWord 和 prototypeHeader, 因为 class 也是一个对象, 可以做为锁, 理所当然的也有一个自己的 markWork, 而 prototypeHeader 是 class 另一个属性, 主要用于在启用偏向锁配置的情况下, 创建出来的对象的 markWord 默认属性

```C++
// 根据是否启用偏向锁，设置对象头信息
if (UseBiasedLocking) {
    result->set_mark(ik->prototype_header());
} else {
    result->set_mark(markOopDesc::prototype());
}
```
prototypeHeader 的值
| 持有锁线程 Id | Epoch | 分代年龄 | 是否偏向锁标志| 锁标志位 |
| :-: | :-:  | :-: | :-: | :-: |
| 0 | 当前的 Epoch  | 0  | 1 |  01 |

**线程 Id 和 Epoch 都相同的判断**

在上面的伪代码中将线程 Id 和 Epoch 的判断分成了 2 步, 但是在源码中是通过计算出一个值, 比较预期值判断的

```C++
anticipated_bias_locking_value =
    (((uintptr_t)lockee->klass()->prototype_header() | thread_ident) ^ (uintptr_t)mark) & ~((uintptr_t) markOopDesc::age_mask_in_place);

// 线程 Id 和 epoch 都一样
if(anticipated_bias_locking_value == 0) {

}    
```

上面的代码的可以分为 4 步进行分析

第一步: **((uintptr_t)lockee->klass()->prototype_header() | thread_ident)** 将当前线程 Id 和 class 的 prototype_header 相或。这样得到的值为: 当前的线程 Id + class 的 Epoch + 分代年龄 + 偏向锁标志 + 锁状态, 也就是 **23位的线程 Id + 2 位的 Epoch + 0000101**, class prototypeHeader 的年龄代默认为 0, 4 位

第二步: **^ (uintptr_t)mark**, 将第一步的结果和当前锁的 markWord 进行异或操作(相等的位全部被置为 0)！那么我们能确定的结果只有最后 3 位为 000

第三步: **~((uintptr_t) markOopDesc::age_mask_in_place)** 只获取当前锁对象的年龄待,进行取反(1 变为 0, 0 变为 1), 那么可以知道结果为 25 个 1 + 4 个未知的年龄代 + 3 个 1

第四步: **&** 将第 2 步和第 3 步的结果进行与操作(都为 1, 才为 1)

在第 2 步的年龄代的值, 就是当前锁的年龄代, 第 3 步的年龄代的值, 就是当前年龄代的值的取反, 那么就是在 & 操作后，得到的值最后面 7 位都为 0, 而第 3 步的值前 25 位的值都为 1, 那么最终的结果, 只需要考虑第 2 步的前 25 位。当当前的线程 Id 和 锁里面的线程 Id 相等, 前 23 位都为 0, 当锁里面的 epoch 和 class prototye_header 的 epoch 都相等, 第 24 和 25 为都为 0,

那么在 线程 Id 都相同和 epoch 都相同的情况, 最终的值就是 0 

**偏向锁里面的 Epoch 作用**

epoch 主要用于解决**重偏向**。首先重偏向主要用于处理锁实例的情况, 锁类的情况没法处理的。
重偏向, 从字面意思就能知道了, 就是将偏向锁偏向的线程从 A 修改为 B 的情况, epoch 就是用来处理线程 A 已经重偏向为自己, 但是线程 B 在重偏向之前拿到的 markWord, 里面不是最新的线程






























