# 02. synchronized 偏向锁

前提说明:

>1. 下面的介绍会以 HotSpot 的字节码解析器进行梳理。虽然 HotSpot 在运行中使用的是用汇编书写的模板解释器, 但是基于 C++ 书写的字节码更容易阅读, 而且 2 者的实现逻辑都是一样的, 所以以字节码的方式进行讲解。

>2. 通过 synchronized 的代码块的方式进行讲解, 既 monitorenter 和 monitorexit 指令。而不是方法级的, 但是 2 这的锁逻辑都是类似的

>3. 下面全部以伪代码的实行进行讲解, 同时会附上源代码的位置, 有兴趣的话, 可以进行了解。

>4. 下面的代码逻辑都基于 JDK 8 的 HotSpot 源码

## 2.1 偏向锁获取流程

在大多数情况下，锁是不存在竞争的，而且总是由一个线程持有，所以可以在使用 synchronized 的时候，可以不去真正的获取锁，而减少获取锁的代价。

偏向锁默认当前的锁是无竞争的，他偏向于第一个获得他的线程。在第一次获取这个锁的线程，不进行真正的锁对象（monitor）获取，只是把我们的对象的对象头从无锁状态转为偏向锁状态，并且把这个线程 Id 记录在对象头里，后续只要这个锁没有被其他线程获取，那么这个线程就无需要进行同步，就能进入到同步代码块。

源代码[地址](http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/interpreter/bytecodeInterpreter.cpp#l1816)

### 2.1.1 代码分析 - Code-01

```Java
CASE(_monitorenter): {

    //  获取当前锁对象
    Lock lock = getLock();
    // 从栈中获取一个 锁记录
    LockRecord lockRecord = getLockRecordFromStackOrStackFrame();

    // 获取不到 Lock Record, 执行执行这个指令
    if (lockRecord == null) {
        // 重新执行
        reExecute();
        return;
    }

    // 下面执行锁逻辑
}
```

从上面的代码可以发现:
1. 无论是什么锁, 进来就会获取到一个空闲的 LockRecord (LockRecord 的 obj 属性为空的话, 就是空闲的)
2. LockRecord 可能分配在栈中, 现在普遍的说法是分配在栈帧中


**结论 1 分析**  

在源代码中, getLockRecordFromStackOrStackFrame 的实现逻辑是这样的

```C++
// find a free monitor or one already allocated for this object
// if we find a matching object then we need a new monitor
// since this is recursive enter
BasicObjectLock* limit = istate->monitor_base();
BasicObjectLock* most_recent = (BasicObjectLock*) istate->stack_base();
BasicObjectLock* entry = NULL;
while (most_recent != limit ) {
    if (most_recent->obj() == NULL) entry = most_recent;
    else if (most_recent->obj() == lockee) break;
    most_recent++;
}
```
上面的 BasicObjectLock 就是我们说的 Lock Record。 

通过上面的备注和结合下面的代码逻辑, 可以知道: **进入 monitorenter, 会在私有线程栈/栈帧找到一个最近并且空闲的区域, 创建一个Lock Record，里面属性为 null**

而且在同步方法的入口处, 源码[位置](http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/interpreter/bytecodeInterpreter.cpp#l683)
```C++
if (METHOD->is_synchronized()) {

    oop rcvr;
    if (METHOD->is_static()) {
        // 静态方法锁的是 类
        rcvr = METHOD->constants()->pool_holder()->java_mirror();
    } else {
        // 非静态方法锁的是实例
        rcvr = LOCALS_OBJECT(0);
        VERIFY_OOP(rcvr);
    }

    // The initial monitor is ours for the taking.

    // Monitor not filled in frame manager any longer as this caused race condition with biased locking.
    BasicObjectLock* mon = &istate->monitor_base()[-1];
    mon->set_obj(rcvr);

    // 省略
}
```

The initial monitor is ours for the taking: 最初的 monitor 由我们获取。
可以得知: 在方法的开始, 就已经会有一个初始的 monitor !

综上: 可以得知, Lock Record 在进入方法时就产生了, 而不是在锁升级到轻量锁的时候才产生, 每一块 synchronized 代码块都需要一个空闲的 Lock Record。

**上面的结论: 个人基于源码里面的备注分析的, 和当前网上的大部分看法有冲突**

**结论 2 分析**  

同样是在同步方法的入口处的备注: **Monitor not filled in frame manager any longer as this caused race condition with biased locking(Moitor 不再填充在帧管理器, 因为这将导致偏向锁的竞态条件)**。  

这段注释是在 JDK 8 中才出现的, JDK 6, 7 都没有。

所以有着 Lock Record 存放在栈, 而是栈帧的结论。网上的普遍看法都是 Lock Record 是存放在栈帧中。个人认为是 synchronized 在不同版本的实现不一致导致的。

在官网的这篇编写于 2008 年介绍 synchronized 的[文章](https://wiki.openjdk.java.net/display/HotSpot/Synchronization)中, 明确说的了 Record Lock 是存放在栈帧的。上面的备注在 JDK6 也是没有的, [源码地址](http://hg.openjdk.java.net/jdk6/jdk6/hotspot/file/d9c3790c85c1/src/share/vm/interpreter/bytecodeInterpreter.cpp#l671), 而是到了 JDK 8 才出现的备注。

在 Oracle 的官网中另一篇编写于 2006 年介绍 synchronized 的[文章](https://www.oracle.com/technetwork/java/biasedlocking-oopsla2006-wp-149958.pdf) 中对的 Lock Record 做了更详细的介绍:  
**在解释执行过程中, 栈帧中有一块区域用于存储 Lock Record, 这块区域会随着方法的执行变大或缩小**  
**在编译执行过程中, 是没有这块区域的, 而是以一个类似的方式存储在 register spill stack slots**  

说这么多, 就是网上的说法普遍都是对的, 但是可能随着 JDK 的发展, 有了变化, 或者是**个人理解错了**

### 2.1.2 代码分析 - Code-02

```java
CASE(_monitorenter): {

    Lock lock = getLock();
    LockRecord lockRecord = getLockRecordFromStackOrStackFrame();
    if (lockRecord == null) {
        reExecute();
        return;
    }
    // 设置当前的 Lock Record 的 obj 指向当前的锁
    lockRecord.setObj(lock);
    // 获取当前锁对象的 MarkWord
    MarkWord markWord = lock.getMarkWord();
    // 获取当前的 markWord 的 hash 值
    int hash = markWord.getHash();
    // 偏向锁获取结果
    boolean biasLockGetResult = false;

    // 当前对象的 MarkWord 是否为偏向锁状态, 既最后 3 位是否为 101
    if (markWord.hasBiasPattern()) {
        // 尝试获取偏向锁逻辑
    }

    // 偏向锁获取失败, 进行锁升级
    if (!biasLockGetResult) {
        // 轻量级锁逻辑
    }

    // 执行下一条指令
    executeNextInstruction();
}
```

从上面的逻辑走下去, 会发现一个有趣的状态: **无锁状态没法升级为偏向锁**。

这里涉及到一个偏向锁的机制: 无锁和偏向锁之间, 存在一个中间状态, 匿名偏向 (anonymously biased)。既锁升级的途径 无锁 -> 匿名偏向 -> 偏向锁 !

匿名偏向: 就是偏向锁的状态, 但是偏向的线程 ID 为 0, 表示不偏向任何线程

匿名偏向, 涉及一个虚拟机配置 -XX:BiasedLockingStartupDelay=xx 单位毫秒

在 JVM 启动后的 BiasedLockingStartupDelay 秒内, 所以创建出来的对象都是**无锁状态**, 既这个时间内的使用的锁只能是**轻量级锁和重量级锁**。在 BiasedLockingStartupDelay 秒后, 创建出来的所有的对象默认都是**匿名偏向锁状态**。

如图:
![Alt 'AnonymouslyBiasedLock'](https://raw.githubusercontent.com/PictureRespository/Java/main/JUC/AnonymouslyBiasedLock.png)

上面的逻辑可以理通了！在程序运行中的情况, Java 对象都是匿名偏向状态, 不存在无锁的情况！

如果需要关闭这种情况的话, 可以通过下面的几个参数进行设置:
> -XX:+UseHeavyMonitors  只使用重量锁
> -XX:+/-UseBiasedLocking  启用/关闭 偏向锁, JDK 6 后默认为启用状态
> -XX:BiasedLockingStartupDelay=0  关闭延迟开启偏向锁

### 2.1.3 代码分析 - Code-03

```java
CASE(_monitorenter): {

    Lock lock = getLock();
    LockRecord lockRecord = getLockRecordFromStackOrStackFrame();
    if (lockRecord == null) {
        reExecute();
        return;
    }

    lockRecord.setObj(lock);
    MarkWord markWord = lock.getMarkWord();
    int hash = markWord.getHash();
    boolean biasLockGetResult = false;

    if (markWord.hasBiasPattern()) {
        // 尝试获取偏向锁逻辑

        // 当前偏向锁指向的线程等于当前线程和 锁里面的 epoch 等于当前锁对象的类的 PrototyHeader 属性的 epoch
        if (threadIdInBasicLockEqualCurrentThread() 
        && epochInBasicLockEqualEpochInCurrentLockClassPrototypeHeader()) {
            // 当前线程已经持有了偏向锁, 不做任何事情, 结束
            biasLockGetResult = true;
        }

    }

    // 偏向锁获取失败, 进行锁升级
    if (!biasLockGetResult) {
        // 轻量级锁逻辑
    }

    executeNextInstruction();
}
```

**PrototypeHeader**  
在 class 中有 2 个属性, markWord 和 prototypeHeader, 因为 class 也是一个对象, 可以做为锁, 理所当然的也有一个自己的 markWork, 而 prototypeHeader 是 class 另一个属性, 主要用于在启用偏向锁配置的情况下, 创建出来的对象的 markWord 默认属性

```C++
// 根据是否启用偏向锁，设置对象头信息
if (UseBiasedLocking) {
    result->set_mark(ik->prototype_header());
} else {
    result->set_mark(markOopDesc::prototype());
}
```
prototypeHeader 的值
| 持有锁线程 Id | Epoch | 分代年龄 | 是否偏向锁标志| 锁标志位 |
| :-: | :-:  | :-: | :-: | :-: |
| 0 | 当前的 Epoch  | 0  | 1 |  01 |

**线程 Id 和 Epoch 都相同的判断**

在上面的伪代码中将线程 Id 和 Epoch 的判断分成了 2 步, 但是在源码中是通过计算出一个值, 比较预期值判断的

```C++
anticipated_bias_locking_value =
    (((uintptr_t)lockee->klass()->prototype_header() | thread_ident) ^ (uintptr_t)mark) & ~((uintptr_t) markOopDesc::age_mask_in_place);

// 线程 Id 和 epoch 都一样
if(anticipated_bias_locking_value == 0) {

}    
```

上面的代码的可以分为 4 步进行分析

第一步: **((uintptr_t)lockee->klass()->prototype_header() | thread_ident)** 将当前线程 Id 和 class 的 prototype_header 相或。这样得到的值为: 当前的线程 Id + class 的 Epoch + 分代年龄 + 偏向锁标志 + 锁状态, 也就是 **23位的线程 Id + 2 位的 Epoch + 0000101**, class prototypeHeader 的年龄代默认为 0, 4 位

第二步: **^ (uintptr_t)mark**, 将第一步的结果和当前锁的 markWord 进行异或操作(相等的位全部被置为 0)！那么我们能确定的结果只有最后 3 位为 000

第三步: **~((uintptr_t) markOopDesc::age_mask_in_place)** 只获取当前锁对象的年龄待,进行取反(1 变为 0, 0 变为 1), 那么可以知道结果为 25 个 1 + 4 个未知的年龄代 + 3 个 1

第四步: **&** 将第 2 步和第 3 步的结果进行与操作(都为 1, 才为 1)

在第 2 步的年龄代的值, 就是当前锁的年龄代, 第 3 步的年龄代的值, 就是当前年龄代的值的取反, 那么就是在 & 操作后，得到的值最后面 7 位都为 0, 而第 3 步的值前 25 位的值都为 1, 那么最终的结果, 只需要考虑第 2 步的前 25 位。当当前的线程 Id 和 锁里面的线程 Id 相等, 前 23 位都为 0, 当锁里面的 epoch 和 class prototye_header 的 epoch 都相等, 第 24 和 25 为都为 0,

那么在 线程 Id 都相同和 epoch 都相同的情况, 最终的值就是 0 

**偏向锁里面的 Epoch 作用**

epoch 主要用于解决**重偏向**。首先重偏向主要用于处理锁实例的情况, 锁类的情况没法处理的。
重偏向, 从字面意思就能知道了, 某个实例锁当前是偏向了线程 A, 线程 B 获取这个实例锁时, 应该升级为轻量级锁变为偏向自己的偏向锁。

机制的流程
1. 类 C 下有很多个实例被当做锁, 当前都是偏向锁, 类 C 和各个实例的 epoch 都是一样的
2. 这些锁突然出现了多次的锁升级, 每次偏向锁升级为轻量级锁, 会在类 C 内部维护一个数字加 1
3. 线程 A 获取类 C 下一个偏向锁实例 I, 本来应该是会升级为轻量级锁的, 但是类 C 内部维护的上限达到了 X
4. 类 C 的 epoch + 1, 找到所有的类 C 的 **MonitorInfo**, 修改他们的 epoch = 类 C 的 epoch, 此时偏向锁内部的偏向的线程 Id 没有修改, 因为修改了会破坏锁的线程安全性
5. 当前线程 A 获取的实例 I, 从升级轻量级锁变为偏向锁, 偏向的线程为 A
6. 那么这些锁实例, 在线程下次尝试获取锁时, 当前实例的 epoch 和 class 的 epoch 不一致, 会先进入偏向锁, 不会立即升级为轻量级锁

例子:

```java

List<Lock> list = new ArrayList<>();

new Thread(()->{

    for (int i = 0; i < 30; i++) {
        Lock lock =  new Lock();
        list.add(lock);
        // Lock 下有多个实例被偏向锁锁住
        synchronized(lock) {
            // 打印对象头信息, 都是偏向锁
            System.out.println(ClassLayout.parseInstance(lock).toPrintable()); 
        }
    }

}, "thread-01").start();

// 让上面的线程跑一下
Thead.sleep(5000L);

for (int i = 0; i < 30; i++) {

    Lock lock =  list.get(i);

    // Importance 这里打印的结果和上面的线程 thread-01 的完全一样
    System.out.println(ClassLayout.parseInstance(lock).toPrintable()); 

    // 下面的打印情况, 0-18都是轻量级锁, 19 后面都是偏向锁
    synchronized(lock) {
        // 打印对象头信息, 都是偏向锁
        System.out.println(ClassLayout.parseInstance(lock).toPrintable()); 
    }
}
```

下面的可以等到批量重偏向的时候, 过来回顾！

**MonitorInfo**: 源码中的备注为 **MonitorInfos for all objects locked on this thread in youngest to oldest order**。这里的 MonitorInfo, 猜测应该是重量级锁实现的 ObjectMonitor! 而不是**该 klass 的所有锁实例**。

原因: 上面的 Importance 的输出结果, 在 i = 19 后, 重偏向了, 如果所有锁实例的 epoch 应该会 + 1, 但是输出结果却是和一开始的一样, 没变。


上面的上限  X, 默认为 20, 可以通过 **-XX:BiasedLockingBulkRebiasThreshold**, 进行设置

### 2.1.4 代码分析 - Code-04

```java
CASE(_monitorenter): {

    Lock lock = getLock();
    LockRecord lockRecord = getLockRecordFromStackOrStackFrame();
    if (lockRecord == null) {
        reExecute();
        return;
    }

    lockRecord.setObj(lock);
    MarkWord markWord = lock.getMarkWord();
    int hash = markWord.getHash();
    boolean biasLockGetResult = false;
    if (markWord.hasBiasPattern()) {
        // 尝试获取偏向锁逻辑

        if (threadIdInBasicLockEqualCurrentThread() 
        && epochInBasicLockEqualEpochInCurrentLockClassPrototypeHeader()) {

            // 情景 1: 锁当前就是偏向的当前线程, 不做任何事情了

            biasLockGetResult = true;
        } else if (biasedModeInClassHadClose()) {

            // 情景 2:  当前 class 的偏向锁模式关闭了

            // 获取锁对应 class 的 prototypeHeader 属性, 也就是实例创建是默认的 markWord
            MarkWord header = lock.getClass().getPrototypeHeader();
            if (hash != markWord.getHash()) {
                header.copySetHash(hash);
            }
            // TODO 源码这样, 不会导致年龄代信息丢失? 

            // 利用 CAS 操作将 markWord 替换为 class 中的 prototypeHeader 的 markWord
            if (CAS(header, lock.getMarkWord(), markWord) == markWord) {
                // 源码中，做了一些锁操作的分析统计, 不涉及锁逻辑
            }

        } else if (epochInClassInstanceNoEqualEpochInClass()) {

            // 情景 3: 有线程触发了重偏向, 当前锁实例的 epoch 和 class 的 epoch 不一致

            // epoch 不一致了, 先尝试重偏向, 不升级锁

            // 构建一个偏向当前线程的 MarkWord 
            MarkWord newHeader = lock.getClas().getPrototypeHeader() | currentTheadId();
            if (hash != markWord.getHash()) {
                newHeader.copySetHash(hash);
            }
            // TODO 源码这样, 不会导致年龄代信息丢失? 

            if(CAS(newHeader, lock.getMarkWord(), markWord) == markWord) {
                // 源码中，做了一些锁操作的分析统计, 不涉及锁逻辑
            } else {
                // 重偏向失败, 代表存在多线程竞争, 则调用 InterpreterRuntime.monitorenter 方法进行锁升级
                InterpreterRuntime.monitorenter(currentThread(), lockRecord);
            }
            biasLockGetResult = true;
        } else {

            // 情景 4: 走到这里的, 只有锁偏向的线程和当前的线程不一样了, 那么有可能是匿名偏向, 线程 Id 完成不一样
            // 要么就是 线程 Id 真的完全不一样

            // 创建一个和当前锁对象的 MarkWord 一样但是没有线程 ID 的 MarkWord
            MarkWord header = createMarkWordWithoutThreadId(markWord);

            if (hash != markWord.getHash()) {
                header.copySetHash(hash);
            }
            // 构建一个偏向当前线程的 MarkWord 
            MarkWord newHeader = header | currentTheadId();

            if(CAS(newHeader, lock.getMarkWord(), markWord) == markWord) {
                // 源码中，做了一些锁操作的分析统计, 不涉及锁逻辑
            } else {
                // 重偏向失败, 代表存在多线程竞争, 则调用 InterpreterRuntime.monitorenter 方法进行锁升级
                InterpreterRuntime.monitorenter(currentThread(), lockRecord);
            }
            biasLockGetResult = true;
        }

    }

    // 偏向锁获取失败, 进行锁升级
    if (!biasLockGetResult) {
        // 轻量级锁逻辑
    }

    executeNextInstruction();
}
```

上面的伪代码中

**CAS**  
CAS(修改后的值, 要修改的对象, 预期的值(修改前的值)), 返回值为实际的原值

**4 种场景**
上面的 4 种情景应该都不难理解, 有点要说明的, 只有第 4 种情况了, 在第 4 中情况中, header 变量里面是没有线程 Id 的, 所以当前锁对象的匿名偏向锁, 就是简单的偏向锁了,
但是如果已经偏向了别的线程, 那么 CAS 是会失败, 走入到锁升级的情况

## 2.2 偏向锁的撤销

撤销: 获取偏向锁的过程因为不满足条件导致要将锁对象改为非偏向锁状态, 最简单的场景: 第一次调用了锁对象的 hashCode() 方法(没有重写), System.identityHashCode() 方法。
处于偏向锁的锁对象, 会撤销为无锁状态。

在 Java 语言里面一个对象如果计算过哈希码, 就应该一直保持该值不变 (强烈推荐但不强制, 因为用户可以重载 hashCode() 方法按自己的意愿返回哈希码), 否则很多依赖对象哈希码的 API 都可能存 在出错风险 (HashMap 里面就是通过 hashcode 确定位置)。一般情况下, 计算过一次的哈希码会存储在实例的对象头中 (无锁状态)! 但是在偏向锁的情况下, 大部分的空间都用于存储线程 Id。所以为了存储哈希码, 偏向锁会降级为无锁状态, 不同的锁状态和当前是否在锁内计算哈希码, 锁可能撤销, 可能升级, 具体的情况, 下面分析！


整条代码链路可以沿着这样走下去
interpreterRuntime.cpp -> InterpreterRuntime::monitorenter 跳转到 synchronizer.cpp -> fast_enter 再跳转到 biasedLocking.cpp -> revoke_and_rebias

源代码[地址](http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/91b61f678a19/src/share/vm/runtime/biasedLocking.cpp#l554)

#### 2.2.1 代码分析 - Code-01

```java
/**
 * 锁撤销/锁偏向
 * 
 * @param obj 一个包装类, 包装了锁对象和当前线程
 * @param attemptRebias 是否允许重偏向
 */
Condition revokeAndRebias(Handle obj, boolean attemptRebias) {

    // 获取锁对象的 markWord
    MarkWord markWord = obj.getLock().getMarkWord();

    // 1. 可以不更新锁撤销次数统计的情况


    // 2. 需要更新锁撤销次数统计的情况
    // 2.1 更新锁撤销次数统计
    // 2.2 根据锁撤销撤销次数分情况
    // 2.2.1 当前锁对象不是偏向锁, 不处理
    // 2.2.2 当前锁撤销统计次数达到了 BiasedLockingBulkRevokeThreshold 次, 默认为 40, 进行批量撤销
    // 2.2.3 当前锁撤销统计次数只是达到了 BiasedLockingBulkRebiasThreshold 次, 默认为 20, 进行批量重偏向
    // 2.2.4 只需要撤销当前锁对象
}
```

这个方法的全部的作用, 如同上面备注了
1. 锁撤销的话, 有一些场景可以直接操作, 不起更新**撤销统计次数**
2. 每个实例锁的 Class 内部有个属性**biased_lock_revocation_count**, 记录着其实例被撤销的次数, 每次撤销 1 次, 这个就自增 1 次。
3. 当**biased_lock_revocation_count** 等于 BiasedLockingBulkRevokeThreshold 时, 会进行锁批量撤销操作, JVM 认为这个锁的撤销次数太多了, 也就是存在竞争, 不适合偏向锁
4. 当**biased_lock_revocation_count** 等于 BiasedLockingBulkRebiasThreshold 时, 会进行锁批量重偏向操作, JVM 会任务当前实例是不是偏向的线程错了, 给这个类当前其他的偏向锁一次重偏向的机会
5. 不在上面的区间的情况, 就直接撤销对应锁实例
6. **BiasedLockingBulkRevokeThreshold** 可以通过 **-XX:BiasedLockingBulkRevokeThreshold** 进行配置, 默认值 40
7. **BiasedLockingBulkRebiasThreshold** 可以通过 **-XX:BiasedLockingBulkRebiasThreshold** 进行配置, 默认值 20

![Alt 'BiasedLockChangeTime'](https://raw.githubusercontent.com/PictureRespository/Java/main/JUC/BiasedLockChangeTime.png)


#### 2.2.2 代码分析 - Code-02

```java

Condition revokeAndRebias(Handle obj, boolean attemptRebias) {

    MarkWord markWord = obj.getLock().getMarkWord();

    // 情况 1: 可以不更新锁重偏向次数统计情景


    // 2. 需要更新锁重偏向次数情景

    // 2.1 更新 class 身上的 biased_lock_revocation_count, 返回当前需要执行的情况
    HeuristicsResult heuristics = updateHeuristics(obj.getLock(), attemptRebias);

    // 2.2 根据 2.1 的返回值进行分情况处理
}

/**
 * @param lock 当前的锁实例
 * @param allowRebia 是否可以重偏向
 */
static HeuristicsResult updateHeuristics(Lock lock, bool allowRebias) {

    MarkWord mark = lock.getMarkWord();

    //如果不是偏向模式直接返回
    if (!mark.hasBiasPattern()) {
        // 不需要做任何事情
        return HR_NOT_BIASED;
    }

    // 获取当前类
    Class class = lock.getClass();
    // 当前时间
    long curTime = getCurrentTime();
    // 上次批量撤销的时间    
    long lastBulkRevocationTime = class.getLastBiasedLockBulkRevocationTime();
    // 当前撤销的次数
    int revocationCount = class.getBiasedLockRevocationCount();
    
    // 偏向的机制: 锁降级
    if ((revocationCount >= BiasedLockingBulkRebiasThreshold) 
        && (revocationCount <  BiasedLockingBulkRevokeThreshold) 
        && (lastBulkRevocationTime != 0) 
        && (curTime - lastBulkRevocationTime >= BiasedLockingDecayTime)) {



        // 下面分析

        // The application is allocating objects in
        // bulk which are biased toward a thread and then handing them off to another thread  
        // 也就是重偏向  

        // 降级操作
        // 经过 1 次批量撤销操作后, 又要对这个类的实例进行撤销    
        // 当前撤销的次数大于等于 20 和 小于 40
        // 当前距离上次撤销的时间差大于 25000 毫秒了
        
        // 这个机制会造成, 批量重偏向和批量撤销发生的时间差在 25000 毫秒内, 重置偏量次数

        class.setBiasedLockRevocationCount(0);
        revocationCount = 0;
    }

    // 没达到重批量撤销的上限, 原子自增
    if (revocationCount <= BiasedLockingBulkRevokeThreshold) {
        revocationCount = class.atomicIncrBiasedLockRevocationCount();
    }

    // 批量撤销
    if (revocationCount == BiasedLockingBulkRevokeThreshold) {
        return HR_BULK_REVOKE;
    }

    // 批量重偏向
    if (revocation_count == BiasedLockingBulkRebiasThreshold) {
        return HR_BULK_REBIAS;
    }

    // 当个撤销
    return HR_SINGLE_REVOKE;
}
```

上面唯一有点问题的应该就是那个撤销次数重置了

#### 2.2.3 代码分析 - Code-03

```java

```java

Condition revokeAndRebias(Handle obj, boolean attemptRebias) {

    MarkWord markWord = obj.getLock().getMarkWord();
    // 情况 1: 可以不更新锁重偏向次数统计情景

    // 当前锁对象是匿名偏向状态
    if (markWord.isBiasedAnonymously() && !attemptRebias) {

        // 匿名偏向锁的重偏向是一个很高效的过程
        // 这种情况, 可以不更新锁偏向次数统计, 因为这样可能会造成大量的不是必要的锁批量重偏向, 这是一个昂贵的操作
    }


}



```



```java
Condition revokeAndRebias(Handle obj, boolean attemptRebias) {

    MarkWord markWord = obj.getLock().getMarkWord();

    // 情况 1: 可以不更新锁重偏向次数统计情景

    // 当前锁对象是可偏向状态
    if (markWord.isBiasedAnonymously() && !attemptRebias) {

        // 匿名偏向锁的重偏向是一个很高效的过程
        // 这种情况, 可以不更新锁偏向次数统计, 因为这样可能会造成大量的不是必要的锁批量重偏向, 这是一个昂贵的操作

        // 如果是匿名偏向且 attempt_rebias==false 会走到这里, 如锁对象的 hashcode 方法被调用会出现这种情况, 需要撤销偏向锁
        MarkWord biasedValue = markWord;

        // 构建一个无锁状态的 MarkWord
        MarkWord unbiasedPrototype = markWord.getPrototype().setAge(markWord.getAge());
        // 通过 CAS 将当前锁替换为无锁状态
        MarkWord resMark = CAS(unbiasedPrototype, obj.getMarkWord(), biasedValue);
        // 替换成功, 结束
        if (resMark == biasedValue) {
            return BIAS_REVOKED;
        }

    } else if (markWord.hasBiasPattern()) {

        // 当前是偏向锁状态
        Class k = obj.getLock().getClass();
        // 获取当前类的初始 MarkWord
        MarkWord prototypeHeader = k.getPrototypeHeader();

        // 并发场景的兼容, 前面已经有线程导致锁升级或撤销了, 

        // 虽然当前锁对象的允许重偏向, 但是类已经关闭了偏向模式, 但是线程在其撤销的过程, 已经跑到了这里, 拦下来, 可以不走下去了
        if (!prototypeHeader.hasBiasPattern()) {

            // 当前锁对象的 Class 已经发生了批量撤销了, 但是锁对象当前是一个有误差的偏向锁状态
            // 这种情况去更新锁偏向次数统计是没有什么意义的, 我们只需要通过 CAS 更新其锁为当前 Class 的锁状态就行了
            // CAS 更新失败了, 说明有另外一个线程已经撤销了这个对象的锁偏向了,
            // 所以, 无论 CAS 更新成功失败, 都无所谓, 直接返回, 让调用方继续执行即可了
            MarkWord biasedValue = markWord;
            MarkWord resMark = CAS(prototypeHeader, obj.getLock().getMarkWord(), markWord);
            return BIAS_REVOKED;
        } else if (prototypeHeader.getEpoch() != markWord.getEpoch()){
            // epoch 不一样了

            // 在这次重偏向的过程中, 锁对象的 epoch 已经过期了, 说明这个实际上是未偏向的
            // 出现这种情况 2 个线程, 同时走进了这个方法, 线程 A 已经先完成了锁的重偏向, 线程 B 这时执行到了上面的 else if 
            // 对于这种情况的话, 我们可以直接通过 CAS 更新这个锁对象的 MarkWord 为新的重偏向状态, 
            // 如果 CAS 更新失败了, 那么就说明此处还有线程在和线程 B 竞争这个锁对象, 那么

            if (attemptRebias) {
                
                MarkWord biasedValue = markWord;
                // 获取一个新的偏向锁 MarkWord
                MarkWord rebiasedPrototype = markWord.encode(currentThreadId(), markWord.getAge(), prototypeHeader.getEpoch());

                MarkWord resMark = CAS(rebiasedPrototype, obj.getLock().getMarkWord(), markWord);
                if (resMark == biasedValue) {
                    return BIAS_REVOKED_AND_REBIASED;
                }
            } else {

                // 不允许重偏向的话, 通过 CAS 将这个锁对象更新为无锁状态,
                // 更新失败的话, 走下面的撤销过程

                MarkWord biasedValue = markWord;
                // 构建一个无锁状态的 MarkWord
                MarkWord unbiasedPrototype = markWord.getPrototype().setAge(markWord.getAge());
                 // 通过 CAS 将当前锁替换为无锁状态
                MarkWord resMark = CAS(unbiasedPrototype, obj.getLock().getMarkWord(), biasedValue);
                // 替换成功, 结束
                if (resMark == biasedValue) {
                    return BIAS_REVOKED;
                }
            }
        }
    }

    // 2. 需要更新锁重偏向次数情景

    // 2.1 更新 class 身上的 biased_lock_revocation_count, 返回当前需要执行的情况
    HeuristicsResult heuristics = updateHeuristics(obj.getLock(), attemptRebias);

    if (heuristics == HR_NOT_BIASED) {
        // 当前锁对象不是偏向锁了, 直接不做任何事情
        return NOT_BIASED;
    } else if (heuristics == HR_SINGLE_REVOKE) {
        // 单个偏向锁撤销
    }

    // 批量撤销、批量重偏向的逻辑  HR_BULK_REBIAS: 批量重偏向标识
    VMBulkRevokeBias bulkRevoke =  bulkRevoke(obj, currentThread(), (heuristics == HR_BULK_REBIAS), attemptRebias);
    VMThread::execute(bulkRevoke);
    return bulkRevoke.statusCode();
}
```

```java



```


https://www.it610.com/article/1296551396493041664.htm