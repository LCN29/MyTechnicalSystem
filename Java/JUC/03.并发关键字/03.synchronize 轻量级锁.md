# 03. synchronized 轻量级锁


## 3.1 偏向锁的简单介绍
轻量级是 synchronized 中算是最简单的一部分的!

偏向锁适用的情景就是锁对象总是由一个线程获取的情况, 而轻量级锁适用的是线程间交替获取锁的情况。所以轻量级锁还是在程序层面进行锁的控制, 为借助操作系统内部的机制。

下面主要介绍
>1. 轻量级锁的获取
>2. 偏向锁到轻量级锁的过程
>3. 轻量级锁的释放

## 3.2 轻量级锁的获取

[源码位置](http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/interpreter/bytecodeInterpreter.cpp#l1816), 和偏向锁的入口是一样的

```C++
CASE(_monitorenter): {

  // 获取当前加锁的对象
  oop lockee = STACK_OBJECT(-1);

  if (entry != NULL) {

    // 将 Lock Record 的 obj 指针指向锁对象
    entry->set_obj(lockee);

    // 省略大部分逻辑
    ...

    //  传统的轻量级锁实现
    if (!success) {

      // 构建一个无锁状态的 Displaced Mark Word, 里面指向的 Lock Record 为空
      markOop displaced = lockee->mark()->set_unlocked();
      // 设置到Lock Record中去
      entry->lock()->set_displaced_header(displaced);

      //如果指定了-XX:+UseHeavyMonitors，则 call_vm=true, 代表禁用偏向锁和轻量级锁
      bool call_vm = UseHeavyMonitors;
      // 如果没有进行定制的话, call_vm 为 false, 那么就会走到后面的 CAS
      // 如果进行了定制的话, call_vm 为 true, 那么后面的 CAS 将会不执行
      
      if (call_vm || Atomic::cmpxchg_ptr(entry, lockee->mark_addr(), displaced) != displaced) {
        // 注意上面的 CAS 判断是 !, 也就是 CAS 失败
        
        // 判断是不是锁重入
        // 应该是通过 displaced 的 obj, 既锁对象的地址, 判断当前线程的栈中是否包含这个地址
        if (!call_vm && THREAD->is_lock_owned((address) displaced->clear_lock_bits())) {
          // 重入的话, 只需要将 Lock Record 的 displace_makr_word 设置为 null  
          entry->lock()->set_displaced_header(NULL);
        } else {
          // 进入锁竞争  
          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);
        }
      }
    }
    // 执行下一个指令
    UPDATE_PC_AND_TOS_AND_CONTINUE(1, -1);
  } else {
    istate->set_msg(more_monitors);
    // 重新执行
    UPDATE_PC_AND_RETURN(0); 
  } 
}
```

通过偏向锁上面相同的代码可以得知, 进入到 _monitorenter 时, 当
>1. 当前锁对象不是偏向锁模式
>2. 当前锁对象是偏向锁模式, 但是锁对应的 Class 已经关闭了偏向锁模式
>3. 当前锁对象是偏向锁模式, 但是在进入到判断代码块后, 变为了无锁模式了  

上面的三种情况, 汇总起来的话, 就是当前锁对象是无锁情况, 直接进入到轻量级锁的获取。

轻量级锁的过程
>1. 通过当前的锁对象创建出一个无锁的 MarkWork
>2. 将这个 MarkWord 设置到 Lock Record 的 displace_mark_word 中
>3. 通过 CAS 尝试设置将 lock 的 MarkWord 的锁记录地址设置为当前的 Lock Record
>4. 第 3 步设置成功了, 结束
>5. 设置失败了, 检查是不是因为重入, 导致的失败, 是的话，直接将当前 Lock Record 的 displace_mark_word 重新设置为 null, 然后结束
>6. 如果不是重入导致的失败, 那么进入锁竞争