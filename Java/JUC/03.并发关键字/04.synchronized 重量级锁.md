# 04. synchronized 重量级锁

## 4.1 重量级锁的简单介绍

偏向锁适用的情景就是锁对象总是由一个线程获取的情况, 而轻量级锁适用的是线程间交替获取锁的情况, 而重量级锁则适合线程并发竞争锁的情况, 同一时刻存在多个线程竞争一个锁的情况。重量级锁就是我们传统意义上的锁, 其利用操作系统底层的同步机制去实现 Java 中的线程同步。重量级锁其底层会调用系统同步机制, 这个过程存在一个用户态到内核态的耗时过程, 这个也是 JDK 6 之前 synchronized 慢的原因。

## 4.2 重量级锁的获取

在上 2 篇中, 可以知道, 在无锁升级轻量级锁中, 通过 CAS 交换头部失败时, 会进入到 **InterpreterRuntime::monitorenter**, 然后进入到 **ObjectSynchronizer::fast_enter**。
在 **ObjectSynchronizer::fast_enter** 中会因为当前锁对象不是偏向模式了, 进入到 **ObjectSynchronizer.slow_enter**, 如果是不是重入, 就会进入到真正的锁膨胀 **ObjectSynchronizer::inflate**。


在 ObjectSynchronizer::inflate 的执行过程

>1. 无锁的话, 尝试设置为轻量级锁, 失败进入重量级锁的处理
>2. 如果是轻量级锁, 同时是重入的话, 直接将 Lock Record 的 displace_mark_word 设置为 null, 代表为重入
>3. 到了这一步, 说明需要进行锁升级了
>4. 先调用 ObjectSynchronizer::inflate, 得到一个 ObjectMonitor
>5. 调用 ObjectMonitor 的 enter 方法

### 4.2.1 ObjectSynchronizer::slow_enter

ObjectSynchronizer::slow_enter [源码位置](http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/runtime/synchronizer.cpp#l226)

```C++
void ObjectSynchronizer::slow_enter(Handle obj, BasicLock* lock, TRAPS) {

  markOop mark = obj->mark();
  assert(!mark->has_bias_pattern(), "should not see bias pattern here");
  // 如果是无锁状态
  if (mark->is_neutral()) {
    lock->set_displaced_header(mark);
    if (mark == (markOop) Atomic::cmpxchg_ptr(lock, obj()->mark_addr(), mark)) {
      TEVENT (slow_enter: release stacklock) ;
      return ;
    }
    // Fall through to inflate() ...
  } else
  // 如果是轻量级锁重入
  if (mark->has_locker() && THREAD->is_lock_owned((address)mark->locker())) {
    assert(lock != mark->locker(), "must not re-lock the same lock");
    assert(lock != (BasicLock*)obj->mark(), "don't relock with same BasicLock");
    lock->set_displaced_header(NULL);
    return;
  }
 ...
 
  // 这时候需要膨胀为重量级锁, 膨胀前, 设置 Displaced Mark Word 为一个特殊值, 代表该锁正在用一个重量级锁的 monitor
  lock->set_displaced_header(markOopDesc::unused_mark());
  // 先调用 inflate 膨胀为重量级锁, 该方法返回一个 ObjectMonitor 对象, 然后调用其 enter 方法
  ObjectSynchronizer::inflate(THREAD, obj())->enter(THREAD);
}
```

这个方法很简单, 没有多少逻辑, 和上面说的一样, 对 2 种可以不导致锁升级的情况进行处理, 如果需要锁升级, 先获取到一个 ObjectMonitor, 然后调用它的 enter 方法。


### 4.2.2 ObjectSynchronizer::inflate

ObjectSynchronizer::inflate [源码位置](http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/runtime/synchronizer.cpp#l1197)

```java
/**
 * 获取 ObjectMonitor
 * @param Self  获取锁线程
 * @param object 锁对象
 */
ObjectMonitor * ATTR ObjectSynchronizer::inflate (Thread * Self, oop object) {
  ...

  for (;;) {

      const markOop mark = object->mark() ;
      assert (!mark->has_bias_pattern(), "invariant") ;

      // mark 是以下状态中的一种：
      // *  Inflated（重量级锁状态）         - 直接返回
      // *  Stack-locked（轻量级锁状态）     - 进行锁膨胀
      // *  INFLATING（膨胀中）             - 忙等待直到膨胀完成
      // *  Neutral（无锁状态）             - 进行锁膨胀
      // *  BIASED（偏向锁）                - 非法状态，在这里不会出现

      // 已经是重量级锁
      if (mark->has_monitor()) {
          // 已经是重量级锁状态了，直接返回
          ObjectMonitor * inf = mark->monitor() ;
          ...
          return inf ;
      }

      // 膨胀中
      if (mark == markOopDesc::INFLATING()) {
         // 正在膨胀中，说明另一个线程正在进行锁膨胀，continue 重试
         TEVENT (Inflate: spin while INFLATING) ;
         // 在该方法中会进行 spin/yield/park 等操作完成自旋动作
         ReadStableMark(object) ;
         continue ;
      }

      // 轻量级锁
      if (mark->has_locker()) {

        // 当前轻量级锁状态，先分配一个 ObjectMonitor 对象，并初始化值
        ObjectMonitor * m = omAlloc (Self) ;
        m->Recycle();
        m->_Responsible  = NULL ;
        m->OwnerIsThread = 0 ;
        m->_recursions   = 0 ;
        m->_SpinDuration = ObjectMonitor::Knob_SpinLimit;
        // 将锁对象的 mark word 设置为 INFLATING (0)状态 
        markOop cmp = (markOop) Atomic::cmpxchg_ptr (markOopDesc::INFLATING(), object->mark_addr(), mark) ;
        if (cmp != mark) {
          // 释放 ObjectMonitor, 以最新是数据进行重新一次  
          omRelease (Self, m, true) ;
          continue ;
        }
      }
      // 栈中的displaced mark word
      markOop dmw = mark->displaced_mark_helper() ;
      assert (dmw->is_neutral(), "invariant") ;

      // 设置 monitor 的字段
      m->set_header(dmw) ;
      // owner 为Lock Record
      m->set_owner(mark->locker());
      // 锁对象
      m->set_object(object);

      ...

      // 将锁对象头设置为重量级锁状态
      object->release_set_mark(markOopDesc::encode(m));

      ...
      return m ;
  }

  // 无锁状态处理
  // 分配以及初始化ObjectMonitor对象
  ObjectMonitor * m = omAlloc (Self) ;
  // prepare m for installation - set monitor to initial state
  m->Recycle();
  m->set_header(mark);
  // owner为NULL
  m->set_owner(NULL);
  m->set_object(object);
  m->OwnerIsThread = 1 ;
  m->_recursions   = 0 ;
  m->_Responsible  = NULL ;
  m->_SpinDuration = ObjectMonitor::Knob_SpinLimit;

  // 用CAS替换对象头的 mark word 为重量级锁状态
  if (Atomic::cmpxchg_ptr (markOopDesc::encode(m), object->mark_addr(), mark) != mark) {
    // 不成功说明有另外一个线程在执行 inflate, 释放 monitor 对象
    m->set_object (NULL) ;
    m->set_owner  (NULL) ;
    m->OwnerIsThread = 0 ;
    m->Recycle() ;
    omRelease (Self, m, true) ;
    m = NULL ;
    continue ;
  } 

   ...
   return m ;      
}
```

inflate 中是一个死循环，主要是为了处理多线程同时调用 inflate 的情况。然后会根据锁对象的状态进行不同的处理:
>1. 已经是重量级状态，说明膨胀已经完成，直接返回
>2. 如果是轻量级锁则需要进行膨胀操作
>3. 如果是膨胀中状态，则进行忙等待
>4. 如果是无锁状态则需要进行膨胀操作

锁膨胀的过程
>1. 调用 omAlloc 分配一个 ObjectMonitor 对象 (以下简称 monitor), 在 omAlloc 方法中会先从线程私有的 monitor 集合 omFreeList 中分配对象, 如果 omFreeList 中已经没有monitor 对象, 则从 JVM 全局的 gFreeList 中分配一批 monitor 到 omFreeList 中。
>2. 初始化 monitor 对象
>3. 将状态设置为膨胀中 (INFLATING）状态
>4. 设置 monitor 的 header 字段为 displaced mark word, owner 字段为 Lock Record, obj 字段为锁对象
>5. 设置锁对象头的 mark word 为重量级锁状态, 指向第一步分配的 monitor 对象

重点, 轻量级锁到重量级锁包含上面的 5 个步骤, 但是无锁到重量级锁不需要第 3 步操作。

轻量级锁需要一个膨胀中 (INFLATING) 状态的原因: 代码中的注释中有解释

```
// Why do we CAS a 0 into the mark-word instead of just CASing the
// mark-word from the stack-locked value directly to the new inflated state?
// Consider what happens when a thread unlocks a stack-locked object.
// It attempts to use CAS to swing the displaced header value from the
// on-stack basiclock back into the object header.  Recall also that the
// header value (hashcode, etc) can reside in (a) the object header, or
// (b) a displaced header associated with the stack-lock, or (c) a displaced
// header in an objectMonitor.  The inflate() routine must copy the header
// value from the basiclock on the owner's stack to the objectMonitor, all
// the while preserving the hashCode stability invariants.  If the owner
// decides to release the lock while the value is 0, the unlock will fail
// and control will eventually pass from slow_exit() to inflate.  The owner
// will then spin, waiting for the 0 value to disappear.   Put another way,
// the 0 causes the owner to stall if the owner happens to try to
// drop the lock (restoring the header from the basiclock to the object)
// while inflation is in-progress.  This protocol avoids races that might
// would otherwise permit hashCode values to change or "flicker" for an object.
// Critically, while object->mark is 0 mark->displaced_mark_helper() is stable.
// 0 serves as a "BUSY" inflate-in-progress indicator.
```


### 4.2.3 ObjectMonitor::enter

ObjectMonitor::enter [源码位置](http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/runtime/objectMonitor.cpp#l318)

```C++
void ATTR ObjectMonitor::enter(TRAPS) {

  Thread * const Self = THREAD ;
  void * cur ;

  cur = Atomic::cmpxchg_ptr (Self, &_owner, NULL) ;
  if (cur == NULL) {
     // Either ASSERT _recursions == 0 or explicitly set _recursions = 0.
     assert (_recursions == 0   , "invariant") ;
     assert (_owner      == Self, "invariant") ;
     // CONSIDER: set or assert OwnerIsThread == 1
     return ;
  }

  if (cur == Self) {
     _recursions ++ ;
     return ;
  }

  if (Self->is_lock_owned ((address)cur)) {
    assert (_recursions == 0, "internal state error");
    _recursions = 1 ;
    // Commute owner from a thread-specific on-stack BasicLockObject address to
    // a full-fledged "Thread *".
    _owner = Self ;
    OwnerIsThread = 1 ;
    return ;
  }

  assert (Self->_Stalled == 0, "invariant") ;
  Self->_Stalled = intptr_t(this) ;

  if (Knob_SpinEarly && TrySpin (Self) > 0) {
    ...
    
    Self->_Stalled = 0 ;
    return ;
  }

  ...

  { 
    ...

    for (;;) {
      jt->set_suspend_equivalent();
      // 在该方法中调用系统同步操作
      EnterI (THREAD) ;
      ...
    }
    Self->set_current_pending_monitor(NULL);

  }
  ...
}
```









