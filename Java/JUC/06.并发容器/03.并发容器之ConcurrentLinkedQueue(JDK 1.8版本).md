#  17. 并发容器之 ConcurrentLinkedQueue (JDK 1.8版本)

## 1. ConcurrentLinkedQueue 简介

在日常中，我们用到的数据结构有很多: 数组，链表，树等，而在这些结构中，还有一个叫做队列的存在。 而在 Java 中, 同时 Collection 下的 Queue 和 List 一样，不同的实现存在线程安全问题。 而如果我们需要一个线程安全的队列的话，可以基于实际的场景进行选择，比如基于数组实现同时操作上会阻塞的 ArrayBlockingQueue，基于链表同时也会阻塞的 LinkedBlockingDeque。 而今天我们聊的
同样也是基于链表实现的 ConcurrentLinkedQueue

## 2. ConcurrentLinkedQueue 中存储数据的节点 Node

```java
private static class Node<E> {

	/**
	 * 节点的数据 
	 */
	volatile E item;

	/**
	 * 下一个节点
	 */
    volatile Node<E> next;
}
```

Node 里面的 2 个属性, item 和 next 都是用 volatile 修饰的, 保证了其可见性。

另外 ConcurrentLinkedQueue 还有 2 个 Node 类型的节点

```java
	
	private transient volatile Node<E> head;
	
	private transient volatile Node<E> tail;
```
这 2 个节点分别代表了链表的头和尾。 而 ConcurrentLinkedQueue 就是通过这 2 个节点对队列进行管理的。 当我们调用无参的构造函数时，其源码为

```java
	public ConcurrentLinkedQueue() {
	    head = tail = new Node<E>(null);
	}
```

head 和 tail 指针会指向一个 item 域为 null 的节点,此时 ConcurrentLinkedQueue 状态如下图所示：

![Alt '创建示意图'](https://s1.ax1x.com/2020/06/22/NY2jZq.png)


## 参考
[ConcurrentLinkedQueue简介](https://github.com/CL0610/Java-concurrency/blob/master/15.%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BConcurrentLinkedQueue/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BConcurrentLinkedQueue.md)