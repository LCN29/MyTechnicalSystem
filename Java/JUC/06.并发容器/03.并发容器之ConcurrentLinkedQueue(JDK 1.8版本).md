#  17. 并发容器之 ConcurrentLinkedQueue (JDK 1.8版本)

## 1. ConcurrentLinkedQueue 简介

在日常中，我们用到的数据结构有很多: 数组，链表，树等，而在这些结构中，还有一个叫做队列的存在。 而在 Java 中, 同时 Collection 下的 Queue 和 List 一样，不同的实现存在线程安全问题。 而如果我们需要一个线程安全的队列的话，可以基于实际的场景进行选择，比如基于数组实现同时操作上会阻塞的 ArrayBlockingQueue，基于链表同时也会阻塞的 LinkedBlockingDeque。 而今天我们聊的
同样也是基于链表实现的 ConcurrentLinkedQueue

## 2. ConcurrentLinkedQueue 中存储数据的节点 Node

### 2.1 Node 的属性
```java
private static class Node<E> {

	/**
	 * 节点的数据 
	 */
	volatile E item;

	/**
	 * 下一个节点
	 */
    volatile Node<E> next;
}
```

Node 里面的 2 个属性, item 和 next 都是用 volatile 修饰的, 保证了其可见性。

另外 ConcurrentLinkedQueue 还有 2 个 Node 类型的节点

```java

	/** 头结点 */
	private transient volatile Node<E> head;

	/** 尾结点 */	
	private transient volatile Node<E> tail;
```
这 2 个节点分别代表了链表的头和尾。 而 ConcurrentLinkedQueue 就是通过这 2 个节点对队列进行管理的。 当我们调用无参的构造函数时，其源码为

```java
	public ConcurrentLinkedQueue() {
	    head = tail = new Node<E>(null);
	}
```

head 和 tail 指针会指向一个 item 域为 null 的节点,此时 ConcurrentLinkedQueue 状态如下图所示：

![Alt '创建示意图'](https://s1.ax1x.com/2020/06/22/NY2jZq.png)

## 2.2 Node 的 方法

```java
/**
 * CAS 更改 Node 中的数据域 item
 * @param cmp  旧值
 * @param val  新值
 */
boolean casItem(E cmp, E val) {
	return UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val);
}

/**
 * CAS 更改 Node 中的指针域 next
 * @param val 新的值
 */
void lazySetNext(Node<E> val) {
	UNSAFE.putOrderedObject(this, nextOffset, val);
}

/**
 * CAS 更改 Node 中的指针域 
 * @param cmp 旧值
 * @param val 新值
 */
boolean casNext(Node<E> cmp, Node<E> val) {
	return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);
}
```
可以看出这些方法实际上是通过调用 UNSAFE 实例的方法，UNSAFE 为 sun.misc.Unsafe 类，该类是 hotspot 底层方法，目前为止了解即可，知道 CAS 的操作归根结底是由该类提供就好

## 3. ConcurrentLinkedQueue 的创建

ConcurrentLinkedQueue 的声明有 2 种 方式

>1.  无参的构造方法

```java
public ConcurrentLinkedQueue() {
	head = tail = new Node<E>(null);
}
```
声明了一个值为空的节点，并将头尾指针都执行这个节点, 如图
![Alt ''](https://s1.ax1x.com/2020/07/01/N7bOx0.png)

>2. 带集合参数的构造方法

```java
public ConcurrentLinkedQueue(Collection<? extends E> c) {

	// 临时的头尾指针
	Node<E> h = null, t = null;

	// 遍历入参的集合
	for (E e : c) {
		checkNotNull(e);
		Node<E> newNode = new Node<E>(e);
		if (h == null)
			h = t = newNode;
		else {
			// 把 t 节点的 next 设置为 newNode
			t.lazySetNext(newNode);
			// 更新 t 的指向，也就是更新临时尾指针的位置
			t = newNode;
		}
	}

	// 头指针为空的话，创建一个新的空值节点，并将其赋给临时头尾指针
	if (h == null)
		h = t = new Node<E>(null);
	// 更新头指针		
	head = h;
	// 更新尾指针
	tail = t;
}
```

## 3. 新增元素 offer 方法

ConcurrentLinkedQueue 做为一个队列来说，需要满足 FIFO 特性, 既插入元素总是在队列最末尾的地方进行插入，而取（移除）元素总是从队列的队头。那么可以从 offer(新增) 和 poll(取出) 2 个方法理解
ConcurrentLinkedQueue。

```java
public boolean offer(E e) {

    // 非空判断，为空会抛出空指针异常
    checkNotNull(e);
 // 把数据封装为 Node 节点
    final Node<E> newNode = new Node<E>(e);

    // 死循环,  将封装好的 Node 节点放到当前队列的尾部, 直到成功，返回 true
    for (Node<E> t = tail, p = t;;) {
        // q = p 的下一个节点
        Node<E> q = p.next;
        // 如果 q 为空，说明当前队列的尾部节点为空
        if (q == null) {

            // 通过 cas 将新增的节点设置在 p 的后面
            // 因为 p 的后一个节点 q 为空，所以将 p 的下一个节点设置为 newNode 成功后，这时候 newNode 就是队列的尾部了
            if (p.casNext(null, newNode)) {
                // 当前节点设置在尾部成功了，当 p != t 时，将创建的节点更新为尾部
                // 什么时候会出现 p 不等于 t? 可以从放入第二个元素时开始考虑
                if (p != t)
                    // 通过 cas 尝试将 tail 从 t 设置为 newNode
                    // 设置成功/失败都没关系,  即使失败了，在后续的循环进行重新更新
                    casTail(t, newNode);
                // 返回 true, 结束死循环
                return true;
            }
        }
        // 当前的 p 的 next 节点 q，等于 q 自身，
		// 这种情况一般会出现在有线程新增和有线程进行删除的情况，我们可以在了解了 poll 后，在回来看
        else if (p == q)
            // 尾结点变了? 取新的尾结点 ： 头结点
            p = (t != (t = tail)) ? t : head;
        else
            // p 不等于 t, 同时 tail 被别的线程修改了，  直接取修改后的尾结点 t， 没有的话，取下一个节点
            p = (p != t && t != (t = tail)) ? t : q;
    }
}


/**
 * CAS 操作, 将当前队列的 tail 从 cmp 设置为 val
 *
 * @param cmp 旧值
 * @param val 新值
 */
private boolean casTail(Node<E> cmp, Node<E> val) {
	return UNSAFE.compareAndSwapObject(this, tailOffset, cmp, val);
}
```

**offer 方法里面的 for 循环分析**  


注：规定 ConcurrentLinkedQueue 是通过无参的构造方法声明的，初始的节点为 Node-0

>1. 第一次往里面放数据时(存放的值为 e)

第一步: Node p = Node t = tail,  tail 指向的是一个值为 null, next 为 null 的初始节点 Node-0 
第二步：Node q = p.next, 因为 tail.next = null, 所以 q = null  
第三步: 走进 if 里面的判断，通过 CAS 操作，将 p.next 从 null 设置为 newNode 节点  
第四步：CAS 设置成功了，进入到第二个 if, 这时候 p 还是等于 t 的，所以直接返回 true.

这时候的样子为  
![Alt 'first-offer'](https://s1.ax1x.com/2020/07/01/N7XVs0.png)

如图，此时队列的尾节点应该为 Node-1, 而 tail 指向的节点依然还是 Node-0, 所以 ConcurrentLinkedQueue 内的 tail 并不一定都是指向尾指针，具有延迟性。

>2. 第二次往里面放数据时(存放的值为 f)

第一步: Node p = Node t = tail,  tail 指向的是一个值为 e, next 为 Node-1 的初始节点 Node-0  
第二步：Node q = p.next, 这时候因为 p = tail, tail.next = Node-1, 所以 q = Node-1  
第三步：有因为 p != q, 所以走到了 else 里面的逻辑，这时候 p == t 的，所以 p = q, 也就是 p = Node-1 了  
第四步：回到循环体的第一步，Node q = p.next = Node-1.next = null, 所以 q = null
第五步：走进 if 里面的判断，通过 CAS 操作，将 p.next 从设置为 newNode 节点
第六步：这时 p != t 了, 通过 CAS 操作将 tail 从 t 设置到 newNode，更新尾结点 tail

这时候的样子为  
![Alt 'second-offer'](https://s1.ax1x.com/2020/07/06/UiLl5D.png)

通过分析，我们可以整理出 poll 的执行逻辑为

>1. 如果 tail 指向的节点的下一个节点（next 域）为 null 的话，说明 tail 指向的节点即为队列真正的队尾节点，因此可以通过 casNext 插入当前待插入的节点,但此时 tail 并未变化
>2. 如果 tail 指向的节点的下一个节点（next 域）不为 null 的话，说明 tail 指向的节点不是队列的真正队尾节点。通过q（Node<E> q = p.next）指针往前递进去找到队尾节点，然后通过 casNext 插入当前待插入的节点，并通过 casTail 方式更改 tail

留意到 `p = (p != t && t != (t = tail)) ? t : q;` 这行代码了吗，按照我们上面一步一步的分析下去，p 不可恨被赋值为 t 的。 那么我们需要从多线程的角度思考了

**从多线程分析 offer 方法**

其实在多线程环境下这行代码很有意思的。**t != (t = tail)** 这个操作并非一个原子操作, 这个可以看出 2 个效果
>1. t = tail
>2. 赋值前 t != tail

在循环中一开始 t = tail, 那么在多线程的情况下可能存在另一个线程将 tail 修改了，导致了 t != tail， 

至于为什么 **t != (t = tail)** 是旧的 t 值和修改后的 tail 进行比较，可以看一下下文的附录


## 4. 删除元素 poll 方法

```java
public E poll() {
	restartFromHead: for (;;) {
		// 取到头结点，赋值给 p，h, q = null,
		for (Node<E> h = head, p = h, q;; p = q) {
			final E item;
			if ((item = p.item) != null && p.casItem(item, null)) {
				// Successful CAS is the linearization point
				// for item to be removed from this queue.
				if (p != h) // hop two nodes at a time
					updateHead(h, ((q = p.next) != null) ? q : p);
				return item;
			}
			else if ((q = p.next) == null) {
				updateHead(h, p);
				return null;
			}
			else if (p == q)
				continue restartFromHead;
		}
	}
}
```
一看到这段代码，第一眼应该是感觉到奇怪吧
`restartFromHead:` 的 Java 的一个标签语法支持，搭配 break, continue, 可以直接跳出循环什么的。类型于 goto 的特性。

ok，进入代码的分析

**poll 方法里面的 for 循环分析**




## 5. offer 方法中的部分线程offer部分线程poll




## 6. HOPS的设计


## 7. 附录

`(p != t && t != (t = tail))` 代码的分析，需要从字节码的形式进行分析 

了解 JVM 的**操作数栈**和**局部变量表**

几个等一下需要用到的指令

| 直接指令 | 说明|
| :-: | :-|
| bipush | 将单字节的常量值（-128~127）推送至栈顶|
| istore_{n} | 将栈顶的整数弹出，并且赋值给局部变量表中的 index 为 n 的元素|
| iload_{n} | 局部变量表中的 index 为 n 的元素放到栈顶|
| if_icmpeq | 比较栈顶两 int 型数值大小，当结果等于 0 时跳转|
| dup | 复制栈顶数值并将复制值压入栈顶|
| iconst_{0} | 将 int 型 n 推送至栈顶|


使 p, t 不相同的情况，这时候

```java
public class Main {
    public static void main(String[] args) {
        int t = 8;
        int p = t;
        int tail = 9;
        // p = t = 8 
        // 所以第一步 p != t 就是 false, 不进行后面的比较了
        boolean result = (p != t && t != (t = tail));
        System.out.println("p=" + p + ", t=" + t + ", result=" + result);
    }
}
```

上面的代码修改为字节码的形式如下:
```
public class Main {

    public static void main(String[] args) {
		// 在栈顶 放入 8
        0: bipush        8     
        // 将栈顶（8）弹出，放到局部变量表第二个的位置(t)
        2: istore_1
        // 将局部变量表第二个的位置(t)的值(8)，压到栈顶
        3: iload_1
        // 将栈顶（8）弹出，放到局部变量表第三个的位置(p)
        4: istore_2
        // 在栈顶 放入 9
        5: bipush        9
        // 将栈顶（9）弹出，放到局部变量表第四个的位置(tail)
        7: istore_3
        // 将局部变量表第三个的位置(p)的值，压到栈顶
        8: iload_2
        // 将局部变量表第二个的位置(t)的值，压到栈顶
        9: iload_1
        // p = 8, t = 8  2个的比较结果等于 false(0) , 跳转到 24
        10: if_icmpeq     24
        13: iload_1
        14: iload_3
        15: dup
        16: istore_1
        17: if_icmpeq     24
        20: iconst_1
        21: goto          25
        // 在栈顶压入 0 这里的 0 可以看为 false
        24: iconst_0
        // 将栈顶（0）弹出，放到局部变量表第五个的位置(result)
        25: istore        4
        // 输出
        27: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;
        30: iload_2
        31: iload_1
        32: iload         4
        34: invokedynamic #13,  0             // InvokeDynamic #0:makeConcatWithConstants:(IIZ)Ljava/lang/String;
        39: invokevirtual #17                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        42: return
	}
}
```

使 p, t 相同的情况，这时候

```java
public class Main {
    public static void main(String[] args) {
        int t = 8;
        int p = t;
        int tail = 9;
        // p = t = 8 
        // 所以第一步 p != t 就是 false, 不进行后面的比较了
        boolean result = (p == t && t != (t = tail));
        System.out.println("p=" + p + ", t=" + t + ", result=" + result);
    }
}
```

上面的代码修改为字节码的形式如下:
``` 
public class Main {

    public static void main(String[] args) {
		0: bipush        8
        2: istore_1
        3: iload_1
        4: istore_2
        5: bipush        9
        7: istore_3
        8: iload_2
        9: iload_1
        // 上面的流程差不多，省略
        // 比较 p == t  结果为true(1) 不跳转，走下一步
        10: if_icmpne     24
        // 将局部变量表第二个的位置(t)的值，压到栈顶
        13: iload_1
        // 将局部变量表第四个的位置(tail)的值，压到栈顶
        14: iload_3
        // 复制栈顶数值并将复制值压入栈顶。即复制 tail 变量值并压入栈顶(9)
        15: dup
        // 将栈顶（9）弹出, 将栈顶数值存入局部变量表第二个的位置(t), 此时 t = 9
        16: istore_1
        // 比较栈顶两 int 型数值大小，也就是赋值前的 t 和 tail, 此时 8 != 9 结果为 true(1) 所以不会跳转到24行，继续执行下一行
        17: if_icmpeq     24
        // 将 int 型 1 压入栈顶
        20: iconst_1
        // 无条件跳转到 25 行
        21: goto          25
        24: iconst_0
        // 将栈顶 1 存入局部变量表第五个的位置，同时出栈 result = 1
        25: istore        4
        // 内容输出
        27: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;
        30: iload_2
        31: iload_1
        32: iload         4
        34: invokedynamic #13,  0             // InvokeDynamic #0:makeConcatWithConstants:(IIZ)Ljava/lang/String;
        39: invokevirtual #17                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        42: return
	}
}
```

通过上面字节码的逐步分析，我们可以得出 `t != (t = tail)` 实际的效果为
>1. t = tail
>2. 未改变值前的 t != tail

一旦有另一个线程将 tail 修改了，就会出现 t != tail 为 true


## 参考
[ConcurrentLinkedQueue简介](https://github.com/CL0610/Java-concurrency/blob/master/15.%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BConcurrentLinkedQueue/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BConcurrentLinkedQueue.md)

[Java并发容器--ConcurrentLinkedQueue](https://www.cnblogs.com/zaizhoumo/p/7726218.html)