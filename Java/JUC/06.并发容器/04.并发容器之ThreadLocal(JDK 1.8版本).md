# 18. ThreadLocal 

## 1. 简介
在多线程编程中通常解决线程安全的问题我们会利用 synchronzed 或者 lock 控制线程对临界区资源的同步顺序从而解决线程安全的问题，但是这
种加锁的方式会让未获取到锁的线程进行阻塞等待，很显然这种方式的时间效率并不是很好。**线程安全问题的核心在于多个线程会对同一个临界
区共享资源进行操作**。那么，如果每个线程都使用自己的“共享资源”，各自使用各自的，又互相不影响到彼此即让多个线程间达到隔离的状态，
这样就不会出现线程安全的问题。事实上，这就是一种**空间换时间**的方案，每个线程都会都拥有自己的“共享资源”无疑内存会大很多，但是由于不
需要同步也就减少了线程可能存在的阻塞等待的情况从而提高的时间效率。

虽然 ThreadLocal 并不在 java.util.concurrent 包中而在 java.lang 包中，但我更倾向于把它当作是一种并发容器(虽然真正存放数据的是 
ThreadLocalMap)进行归类。从 ThreadLocal 这个类名可以顾名思义的进行理解，表示线程的"本地变量"，即每个线程都拥有该变量副本，达到人
手一份的效果，各用各的这样就可以避免共享资源的竞争。

## 2. ThreadLocal 的实现原理

要想学习到 ThreadLocal 的实现原理，就必须了解它的几个核心方法，包括怎样存怎样取等等，下面我们一个个来看。

> void set(T value) 将 value 存到 ThreadLocal 中
```java
public void set(T value) {
    // 获取当前的线程
    Thread t = Thread.currentThread();
    // 通过当前线程实例获取到ThreadLocalMap对象
    ThreadLocalMap map = getMap(t);
    if (map != null)
        // 如果Map不为null,则以当前threadLocl实例为key,值为value进行存入
        map.set(this, value);
    else
        // map为null,则新建ThreadLocalMap并存入value
        createMap(t, value);
}

/**
 * 返回指定线程自身的 ThreadLocalMap 对象
 */
ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}

/**
 * 为指定的线程创建一个 ThreadLocal 对象
 */
void createMap(Thread t, T firstValue) {
    t.threadLocals = new ThreadLocalMap(this, firstValue);
}
```

从上面的代码，我们可以知道

>1. ThreadLocal 实际的数据是存在每个线程自身的 ThreadLocalMap 对象中。
```java
public class Thread {
    // 每个线程内部都有一个 ThreadLocalMap 属性
    ThreadLocal.ThreadLocalMap threadLocals = null;
}
```

>2. ThreadLocal 的创建是通过 ThreadLocal 的 createMap(Thread t, T firstValue)

>3. 向 ThreadLocal 放数据，也就是 set 过程
>>1. 获取当前线程的所维护的 threadLocalMap
>>2. 若 threadLocalMap 不为 null, 则以 ThreadLocal 实例为 key,值为 value 的键值对存入 threadLocalMap
>>3. 若 threadLocalMap 为 null 的话，就新建 threadLocalMap 然后在以 threadLocal 为key，值为 value 的键值对存入即可

> T get() 从 ThreadLocal 中获取值

```java

public T get() {
    // 获取当前的线程
    Thread t = Thread.currentThread();

    //2. 获取当前线程的 threadLocalMap
    ThreadLocalMap map = getMap(t);

    // 当前线程的 ThreadLocalMap 为空
    if (map != null) {
        // 获取 map 中 key 为 当前实例的 Entry
        ThreadLocalMap.Entry e = map.getEntry(this);
    
        // 获取到了需要的Entry
        if (e != null) {
            @SuppressWarnings("unchecked")
            T result = (T)e.value;
            return result;
        }
    }
    //若 map 为 null 或者 entry 为 null 的话通过该方法初始化，并返回该方法返回的 value
    return setInitialValue();
}

/**
 * 为当前的线程设置一个 value 为 null 的 ThreadLocalMap 
 */ 
private T setInitialValue() {
    // 获取一个 null 的 value
    T value = initialValue();
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
    return value;
}

/**
 * 默认返回一个 null
 */
protected T initialValue() {
    return null;
}
```

从上面的代码，我们可以知道

>1. 从 ThreadLocal 去数据，也就是 get 的过程

>>1. 获取当前线程的所维护的 threadLocalMap
>>2. 若 threadLocalMap 不为 null, 通过 threadLocalMap 中获取 Entry, Entry 不为 null, 就是找到需要的值了，返回
>>3. threadLocalMap 为 null, 或者从 threadLocalMap 获取到的 Entry 为空，声明一个初始的 value 默认为 null
>>4. 走 set 的逻辑

> void remove() 从 ThreadLocal 中移除值
```java
public void remove() {
    ThreadLocalMap m = getMap(Thread.currentThread());
    if (m != null)
        // 从 map 中删除以当前 threadLocal 实例为 key 的键值对
        // ThreadLocalMap 的 remove 后面在讲
        m.remove(this);
}
```
remove 的方法很简单的，就是从从当前线程获取到 ThreadLocalMap, 不为 null 的话，调用 ThreadLocal 的 remove 进行移除数据

## 3. ThreadLocalMap 的实现原理

从上面的分析我们已经知道，数据其实都放在了 threadLocalMap 中，threadLocal 的 get，set 和 remove 方法实际上具体是通过 threadLocalMap 
的 getEntry, set 和 remove 方法实现的。如果想真正全方位的弄懂 threadLocal, 势必得在对 threadLocalMap 做一番理解。

### 3.1 Entry 数据结构

ThreadLocalMap 是threadLocal 一个静态内部类，和大多数容器一样内部维护了一个数组，同样的 threadLocalMap 内部维护了一个 Entry 类
型的 table 数组

```java
/**
 * The table, resized as necessary.
 * table.length MUST always be a power of two.
 */
private Entry[] table;
```
通过注释可以看出，table 数组的长度为 2 的幂次方。接下来看下 Entry 是什么:

```java
static class Entry extends WeakReference<ThreadLocal<?>> {
    
    Object value;

    Entry(ThreadLocal<?> k, Object v) {
        super(k);
        value = v;
    }
}
```
Entry 是一个以 ThreadLocal 为 key, Object 为 value 的键值对。同时注意，这里的 **threadLocal** 是一个弱引用。 因为 Entry 继承
了 WeakReference，在 Entry 的构造方法中，调用了 super(k) 方法就会将 threadLocal 实例包装成一个 WeakReference。

Thread, ThreadLocal, ThreadLocalMap, Entry 之间的关系
![Alt 'ThreadLocal之间的引用关系'](https://s1.ax1x.com/2020/07/13/UY3P0O.png)

实线表示强引用，虚线表示弱引用。

每个线程实例中可以通过 threadLocals 获取到 threadLocalMap, 而 threadLocalMap 实际上就是一个以 threadLocal 实例为 key，任意对
象为 value 的 Entry 数组。  

当我们为 threadLocal 变量赋值时，就是给对应的线程的 ThreadLocalMap 中放入一个当前 threadLocal 实例为 key，值为 value 的 Entry, 

需要注意的是 **Entry中的 key 是弱引用**, 当 threadLocal 外部强引用被置为 null(threadLocalInstance = null)时, 那么系统 GC 的时
候，根据可达性分析，这个 threadLocal 实例就没有任何一条链路能够引用到它，这个 ThreadLocal 势必会被回收, 这样一来，ThreadLocalMap 
中就会出现 key 为 null 的 Entry, 就没有办法访问这些 key 为 null 的 Entry 的 value。如果当前线程再迟迟不结束的话, 这些 key 为 null
的 Entry 的 value 就会一直存在一条强引用链: Thread Ref -> Thread -> ThreadLocalMap -> Entry -> value 永远无法回收，造成内存泄漏,
当然, 如果当前 thread 运行结束, threadLocal, threadLocalMap, Entry 没有引用链可达，在垃圾回收的时候都会被系统进行回收。在实际开
发中, 会使用线程池去维护线程的创建和复用，比如固定大小的线程池，线程为了复用是不会主动结束的。所以, threadLocal 的内存泄漏问题, 
是应该值得我们思考和注意的问题。

### 3.2 ThreadLocalMap 的创建

创建方式 1
```java
ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {

    // INITIAL_CAPACITY = 16;
    table = new Entry[INITIAL_CAPACITY];
    // 调用 ThreadLocal 的 threadLocalHashCode 的 threadLocalHashCode 属性值, 然后 & (16 - 1) 
    // 得到这个 firstKey 应该存在数组的哪个位置
    int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);
    // 在数组对应的位置存入 Entry
    table[i] = new Entry(firstKey, firstValue);
    // 当前容量设置为 1 
    size = 1;
    // 设置阈值 = 长度 * 2/3
    setThreshold(INITIAL_CAPACITY);
}
```

创建方式 2
```java
private ThreadLocalMap(ThreadLocalMap parentMap) {

    // 取到入参 ThreadLocalMap 的数组
    Entry[] parentTable = parentMap.table;
    // 数组的长度, 这里的长度不用做任何处理，因为这里的长度必定为 2 的 n 次方
    int len = parentTable.length;
    // 设置阈值
    setThreshold(len);
    // 设置新的数组    
    table = new Entry[len];
    
    for (int j = 0; j < len; j++) {
        // 获取到 table 数组的第 j 个位置
        Entry e = parentTable[j];
        if (e != null) {
            // 从 e 中获取对应的 key  ThreadLocal 
            ThreadLocal<Object> key = (ThreadLocal<Object>) e.get();
            if (key != null) {
                // 调用 ThreadLocal 的 childValue 方法，在 ThreadLocal 中这个方法会抛异常
                Object value = key.childValue(e.value);
                // 把 key 和 value 封装为 Entry
                Entry c = new Entry(key, value);
                // 定位到放在数组的位置
                int h = key.threadLocalHashCode & (len - 1);
                // 对应的位置不为空，查询后面的一个位置，到了尾部，回到头部继续往后找
                while (table[h] != null)
                    h = nextIndex(h, len);
                // 对应的位置 设置为当前的 Entry
                table[h] = c;
                // 个数加 1
                size++;
            }
        }
    }
}

/**
 * 位置的定位
 */
private static int nextIndex(int i, int len) {
    // 当前的位置 + 1 小于当前的长度, 取 + 1 的位置，否则取 0, 既头部的位置
    return ((i + 1 < len) ? i + 1 : 0);
}
```

hashCode 的计算, 既 ThreadLocal.threadLocalHashCode

```java
public class ThreadLocal {

    private final int threadLocalHashCode = nextHashCode();
    
    private static AtomicInteger nextHashCode = new AtomicInteger();
    
    // 这个值为 1640531527
    private static final int HASH_INCREMENT = 0x61c88647;
    
    private static int nextHashCode() {
        return nextHashCode.getAndAdd(HASH_INCREMENT);
    }
}
```

结论:  
每个 ThreadLocal 对象的 threadLocalHashCode 都是不一样的，同时 ThreadLocal 声明的时候，threadLocalHashCode
就确定不会变了。

1. nextHashCode 在 ThreadLocal 中被 static 修饰了，说明所有的 ThreadLocal 的实例共用 1 个 AtomicInteger。
2. 当我们声明第 1 个 ThreadLocal，调用唯一的 nextHashCode， 得到了当前的 threadLocalHashCode 值, 值为 0, 同时让唯一的
AtomicInteger 的值增加 1640531527
3. 声明第 2 个 ThreadLocal, 又调用了唯一的 nextHashCode, 得到了当前的 threadLocalHashCode 值, 值为 1640531527, 然后又让
AtomicInteger 的值增加 1640531527, 这样每创建一个 ThreadLocal 的 nextHashCode 都是不一样的。不要忽略了 int 值的取值范围，
导致值的变化
4. 为什么每个 ThreadLocal 之间的的 nextHashCode 的差值为 1640531527? 这个和斐波那契散列有关, 它可以使 hashcode 均匀的分布在大小
为 2 的 N 次方的数组里。至于为什么, 涉及到数学相关的知识，pass !
 

### 3.2 set 方法

threadLocalMap 是采用散列表进行实现的, 在了解 set 方法前, 我们先来回顾下关于散列表相关的知识。

* 散列表  
在 HashMap 中, 内部是通过一个数组存放我们的数据的, 我们通过调用 put(key, value) 的时候, 就能把数据放到数组中。  
内部的逻辑是通过 key 取到对应的 hashCode, 然后通过 `hashCode & (数组的长度 - 1)` 得到了我们是 value 放在数组的哪个位置。  
其中存放数据的数组就是散列表, 一个包含关键字的固定大小的数组。得到对应的关键字得到存放在数组的位置的函数就是散列(哈希)函数。

在理想状态下, 哈希函数可以将关键字均匀的分散到数组的不同位置, 不会出现两个关键字散列值相同(假设关键字数量小于数组的大小)的情况。
但是在实际使用中, 经常会出现多个关键字散列值相同的情况(被映射到数组的同一个位置), 我们将这种情况称为散列冲突。为了解决散列冲突，主要
采用下面两种方式: **分离链表法 (separate chaining)** 和**开放定址法 (open addressing)**

* 分离链表法 (separate chaining)  
分离链表法使用链表解决冲突, 将散列值相同的元素都保存到一个链表中。当查询的时候，首先找到元素所在的链表, 然后遍历链表查找对应的元素, 
典型实现为 HashMap, ConcurrentHashMap 的拉链法。下面是一个示意图
![Alt 'SeparateChaining'](https://s1.ax1x.com/2020/07/15/UdXr8J.gif)

* 开放定址法 (open addressing)    
开放定址法不会创建链表, 当关键字散列到的数组单元已经被另外一个关键字占用的时候，就会尝试在数组中寻找其他的单元，直到找到一个空的单元。
探测数组空单元的方式有很多, 这里介绍一种最简单的 -- 线性探测法。线性探测法就是从冲突的数组单元开始，依次往后搜索空单元，如果到数组尾部，
再从头开始搜索（环形查找）。如下图所示
![Alt 'OpenAddressing'](https://s1.ax1x.com/2020/07/15/UwoWnO.jpg)

**ThreadLocalMap 中使用开放地址法来处理散列冲突**, 而 HashMap 中使用的分离链表法。之所以采用不同的方式主要是因为：在 ThreadLocalMap 
中的散列值分散的十分均匀, 很少会出现冲突。并且 ThreadLocalMap 经常需要清除无用的对象, 使用纯数组更加方便。

在了解这些相关知识后我们再回过头来看一下 set 方法。set 方法的源码为：
```java
private void set(ThreadLocal<?> key, Object value) {
    
    // 获取到当前存数据的数组引用
    Entry[] tab = table;
    // 数组长度
    int len = tab.length;
    
    // 当前 ThreadLocal 的 threadLocalHasCode & (数组的长度 - 1), 得到当前
    int i = key.threadLocalHashCode & (len-1);

    // 取到对应位置的元素,  但 i 位置的 key 不为 null, 同时不等于当前的 key, 找下一个位置
    for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) {
        // 这时候的 e 一定不会是 null
        // 再向 ThreadLocal 放数据的时候, 如果线程的 ThreadLocal 为空，做创建逻辑，
        // 会在 当前的 ThreadLocal 的 key & (当前数组的长度 - 1) 的位置放入数据
        // 第二次向 ThreadLocal 放数据，首先也是先寻找从当前的 ThreadLocal 的 key & (当前数组的长度 - 1) 
        // 的位置放入数据
        ThreadLocal<?> k = e.get();
        // 对应的 k == 输入的 key, 替换新值，结束
        if (k == key) {
            e.value = value;
            return;
        }
        // 对应的位置的 k 为 null, 将当前的 value 设置到 ThreadLocalMap 的数组
        if (k == null) {
            // 具体逻辑见附录
            // 将当前的 value 放到数组里面, 进行 table 数组的重新整理，即对数组中, 无效的 Entity(key 移除)
            // 然后重新对数组中的 key 是容错的处理的，重新走一遍位置定位，进行位置的重新修改
            replaceStaleEntry(key, value, i);
            return;
        }
    }
    
    // i 位置为 null, 创建一个新的 Entry 放到数组的 i 位置
    tab[i] = new Entry(key, value);
    // 容量加 1
    int sz = ++size;

    // 插入后再次清除一些 key 为 null 的 "脏" entry, 如果大于阈值还是需要扩容
    if (!cleanSomeSlots(i, sz) && sz >= threshold)
        rehash();
}
```

## 附录

### 引用
在 Java 中，我们声明了一个对象，这个对象一般情况下是在堆中，而创建的线程只是持有对象的引用, 通过这个引用调用创建的对象。  

而对于这个对象的内存分配和内存回收，都不需要程序员负责，都是由 JVM 去负责。一个对象是否可以被回收，主要看是否有引用指向此对象，说的
专业点，叫可达性分析。所以,引用对应 JVM 有着重要的作用。

Java 设计这四种引用的主要目的有两个
>1. 可以让程序员通过代码的方式来决定某个对象的生命周期
>2. 有利用垃圾回收

### Java 的四种引用

> 强引用
> 软引用
> 弱引用
> 虚引用

 https://www.javazhiyin.com/60330.html
 
### 数组数据整理 replaceStaleEntry

```java
/**
 * @param key ThreadLocal 的 key
 * @param value 需要存储的值
 * @param staleSlot 位置
 */
private void replaceStaleEntry(ThreadLocal<?> key, Object value, int staleSlot) {
    
    Entry[] tab = table;
    int len = tab.length;
    Entry e;

    // 需要清除的位置
    int slotToExpunge = staleSlot;
    
    // 从当前的 staleSlot 位置向前(如果到了头部, 则从尾部继续往前找)找到第一个为空的位置
    // 往前找的过程中，slotToExpunge 时刻更新为无效 Entity 的位置
    for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len))
      // 对应对象的 key 为 null, 变更 slotToExpunge
      if (e.get() == null)
          slotToExpunge = i;
    
    // 从 staleSlot 开始向后找(下一个位置为空，从头部继续找)，直到找到无效 Entity
    for (int i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) {
      // 获取 entity 的 key,
      ThreadLocal<?> k = e.get();
      // 如果 key 一样
      if (k == key) {
         // 对应 entity 的 value 更新
         e.value = value;
         // 将 i 和一开始无效的位置 staleSlot 替换
         tab[i] = tab[staleSlot];
         tab[staleSlot] = e;
    
         //如果上面的向前查找没有找到无效entry，则更新 slotToExpunge 为当前值 i
         if (slotToExpunge == staleSlot)
             slotToExpunge = i;
         // expungeStaleEntry 的作用: 
         // 1. 将 slotToExpunge 的位置置为空
         // 2. 从 slotToExpunge 向后找，如果 key 为空的，进行删除
         // 3. 向后找的时候，如果 key 不为空，但是他的位置不是直接计算出来的
         // (冲突解决，可能导致计算出来的位置，不一定就是实际的位置)
         // 将当前的位置置为空，按照以前的规则重新计算位置
         // 4. 最后返回 slotToExpunge 往后的第一个无效 Entity 的位置
      
         // cleanSomeSlots 的作用
         // 循环执行, 从 expungeStaleEntry 返回的第一个无效 Entity 的位置开始向后找
         // 遇到的 Entity 不为空，但是他的 key 为空，走一遍 expungeStaleEntry, 然后继续从 expungeStaleEntry 的返回值
         // 继续重新找,
         // 直到 n/2 == 0 循环接收, 控制扫描次数在log2(n)
         cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);
         return; 
      }
      if (k == null && slotToExpunge == staleSlot)
          slotToExpunge = i;
    }
    
    tab[staleSlot].value = null;
    tab[staleSlot] = new Entry(key, value);
    
    if (slotToExpunge != staleSlot)
      cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);  
}
```

```java
private int expungeStaleEntry(int staleSlot) {
    Entry[] tab = table;
    int len = tab.length;

    // expunge entry at staleSlot
    tab[staleSlot].value = null;
    tab[staleSlot] = null;
    size--;

    // Rehash until we encounter null
    Entry e;
    int i;
    for (i = nextIndex(staleSlot, len);
         (e = tab[i]) != null;
         i = nextIndex(i, len)) {
        ThreadLocal<?> k = e.get();
        if (k == null) {
            e.value = null;
            tab[i] = null;
            size--;
        } else {
            int h = k.threadLocalHashCode & (len - 1);
            if (h != i) {
                tab[i] = null;

                // Unlike Knuth 6.4 Algorithm R, we must scan until
                // null because multiple entries could have been stale.
                while (tab[h] != null)
                    h = nextIndex(h, len);
                tab[h] = e;
            }
        }
    }
    return i;
}
```


cleanSomeSlots 的逻辑
```java
private boolean cleanSomeSlots(int i, int n) {
    boolean removed = false;
    Entry[] tab = table;
    int len = tab.length;
    do {
        i = nextIndex(i, len);
        Entry e = tab[i];
        if (e != null && e.get() == null) {
            n = len;
            removed = true;
            i = expungeStaleEntry(i);
        }
    } while ( (n >>>= 1) != 0);
    return removed;
}
```
 
 

## 参考

[并发容器之ThreadLocal](https://github.com/CL0610/Java-concurrency/blob/master/17.%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BThreadLocal/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BThreadLocal.md)  
[ThreadLocal源码深入剖析](https://www.jianshu.com/p/acfd2239c9f4)  
[强软弱虚引用，只有体会过了，才能记住](https://www.javazhiyin.com/60330.html)  
