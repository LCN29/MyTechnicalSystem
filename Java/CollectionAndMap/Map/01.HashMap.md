# 1 HashMap

HashMap 是 Map 接口中基于哈希表的非同步实现, 自身也可以自动扩容。使用时可以通过 key 快速定位到对应的 value。key 和 value 同时可以都为 null。

## 1.2 HashMap 的结构定义

JDK1.8 对 HashMap 进行了比较大的优化, 底层实现由之前的 "数组 + 链表" 改为 "数组 + 链表 + 红黑树"。 在链表的长度大于等于 8 并且数组的长度大于等于 64 时, 将对应的链表转为红黑树。
(本文不涉及红黑树部分的分析, 涉及到时, 只会提一下, 然后跳过)。

首先数组是整个数据的存储真正实体, 数组中的存储的数据是链表或者红黑树, 当链表的长度达到了条件, 就变成了红黑树, 大体的情况如下:

![Alt 'HashMapDataStructure'](https://raw.githubusercontent.com/PictureRespository/Java/main/CollectionAndMap/HashMapDataStructure.png)

### 1.2.1  数组的定义

```java
public class HashMap<K,V>  {

    transient Node<K,V>[] table;
}
```
从上面的代码就是 HashMap 中数据存储的地方 : 数组。 数组存储的数据类型为 Node, 这个 Node 是链表的定义。  
而 红黑树的定义是继承了 Node, 所以通过向上转型的方式, 就能通过一个 Node 的类型表示链表和红黑树。

### 1.2.2 链表的定义

```java
public class HashMap<K,V> {

    /**
	 * 链表定义
     * Map.Entry 行为接口, 定义了一堆操作方法, 比如 getValue, setValue 等
	 */
    static class Node<K,V> implements Map.Entry<K,V> {

        // 当前节点的 hash 值
        final int hash;

        // 当前节点的 key
        final K key;

        // 当前节点的 value
        V value;

        // 下一个节点, 这个属性决定了 Node 为链表
        Node<K,V> next;

        Node(int hash, K key, V value, Node<K,V> next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }

        /**
         * 计算当前节点 hashCode
         */
        public final int hashCode() {
        	// Objects.hashCode 本质就是调用对象的 o.hashCode()
        	// 当前节点的 hashCode 值 等于 key 的 hashCode  异或 value 的 hashCode 值
            return Objects.hashCode(key) ^ Objects.hashCode(value);
        }

        /**
         * 节点比较
         */
        public final boolean equals(Object o) {

            if (o == this)
                return true;

            // 都是 Map.Entry 节点
            if (o instanceof Map.Entry) {

                Map.Entry<?,?> e = (Map.Entry<?,?>)o;

                // Objects.equals 会先比较一下 2 者的内存地址， 一样直接返回 true
                // 不一样，调用 key.equals(e.getKey) 进行比较
                if (Objects.equals(key, e.getKey()) && Objects.equals(value, e.getValue()))
                    return true;
            }

            return false;
        }

    }

}

```

### 1.2.3 红黑树的定义

```java

public class HashMap<K, V> {

    	// 继承了 LinkedHashMap.Entry, Entry 继承了 HashMap.Node  所以 TreeNode 具有 链表的特点

    /** 
     * 红黑树的定义
     * LinkedHashMap.Entry 继承了 HashMap.Node 节点, 所以 TreeNode 是 Node 的子类, 也具备链表的特点
     */    
	static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {

        /**
         * 红黑树的根节点
         */
        TreeNode<K,V> parent;
        
        /**
         * 当前节点的左节点
         */
        TreeNode<K,V> left;

        /**
         * 当前节点的右节点
         */
        TreeNode<K,V> right;

        /**
         * 删除后需要解决连接的节点
         */
        TreeNode<K,V> prev;  

        /**
         * 是否为红色节点
         */
        boolean red;


        // ... 后面 省略 红黑树的操作
    }

}
```

## 1.3 HashMap 中的几个重要属性

```java
transient Node<K,V>[] table;
```

HashMap 中存储数据的数组

```java
transient int size;
```

HashMap 中已经存储的数据个数

```java
transient int modCount;
```

HashMap 已经被修改了多少次, 用于支撑 fail-fast 机制

```java
final float loadFactor;
```

负载因子： 默认等于  DEFAULT_LOAD_FACTOR = 0.75f;  
作用：一般情况都是在容器满了才会进行扩容, 但是在 HashMap 中, 数据量达到了**数组的长度 * 负载因子**的值，就会进行扩容了。  
原因： HashMap 在数组中插入一个数据，是先通过一个 hash 方法转换为一个 hash 值, 通过这个 hash 值计算得到存储在数组的位置, 通过 hash 计算, 就可能存在 hash 冲突。  
数据越密集，冲突的可能性越大, 所以 HashMap 中的数组是不会完成存满的, 通过空留一部分, 减少冲突等。  

负载因子默认值为 0.75 的原因： 太大冲突可能性变大，太小浪费了空间，同时会导致数组扩容等耗时操作。  
所以 0.75 应该是一个经验值的估算, 或者是因为 HashMap的数组长度为 2^n, 乘以 0.75, 能获得一个整数。

```java
private int threshold;
```
当前数组的阈值, 即数组实际应该放多少数据

下面是**几个常量值**

```java
// 1 左移多少位, 就是相当于 2 的 多少次方， 这里就是 2^4 = 16
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;
```
声明 HashMap, 不指定容量时, 默认为 16


```java
// 2^30
static final int MAXIMUM_CAPACITY = 1 << 30;
```
HashMap 最大容量, 容量必须是 2 的 n 次方, 涉及到通过 key 的 hash 值定位到数组的位置中的一个配合， 后面讲解。

```java
static final int TREEIFY_THRESHOLD = 8;
```

HashMap 中链表变为红黑树的长度配置, 链表长度达到了 8 满足了链表变为红黑树的条件之一。

```java
static final int UNTREEIFY_THRESHOLD = 6;
```

HashMap 中红黑树重新变为链表的长度配置, 红黑树的节点个数达到了 6, 满足了红黑树变为链表的条件之一。

```java
static final int MIN_TREEIFY_CAPACITY = 64;
```

HashMap 中链表变为红黑树的的另外一个条件, 当前数组的长度达到了 64。


## 1.4 HashMap 的构造方法

### 1.4.1 无参的构造函数

```java

public HashMap() {
    // 设置负载因子为 0.75
    this.loadFactor = DEFAULT_LOAD_FACTOR; 
}
```

### 1.4.2 指定初始容量 (和负载因子) 的构造函数

```java
public HashMap(int initialCapacity) {

    // 调用到自身的指定容量 和负载因子的构造函数, 传入的负载因子为默认值 0.75
    this(initialCapacity, DEFAULT_LOAD_FACTOR);
}

/** 指定 初始容量 和 负载因子  */
public HashMap(int initialCapacity, float loadFactor) {

    // 指定的容量小于 0, 格式不正确
    if (initialCapacity < 0)
        throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity);

    // 指定的容量超过了最大容量, 设置为支持的最大容量值
    if (initialCapacity > MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;

        
}
```