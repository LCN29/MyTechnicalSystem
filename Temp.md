## 高并发涉及

数据库上面的设计

1. 分库分表 ---> 网点 hash 不一致, 录入时间 
2. 维度不同 ---> 寄件派件拆分
3. 扩展表 ---> 分主字段拆分都扩展表
4. 数据冷热处理, 业务上控制 ----> 保留半年的数据，也就是差不多 180 天的数据, 经由大数据转存到 HBase

辅助上的设计
1. 高压力的接口, 基本都是系统之间的定时批量处理等, 针对这些接口, 将对应的查询条件和数据, 通过 cannel 同步到 es, 走到 es
将原本将原本 200 的字段 缩减到 30
2. 用户常用的接口, 如分页接口 ---> 2 个接口, 分页信息相关的接口, 数据相关的接口, 接口带上上次记录的最大索引值，后台防止深度分页
3. 接口中出现汇总相关的, 如果业务允许的情况下， 通过定时器进行延迟汇总，入 es

## 动态扩容

我们现在的系统的理论上是不支持临时的动态的扩容的，路由规则是我们的运单的录入时间，也就是每天能收到的运单量，基本不会出现突然的业务飙升。

但是我们这边是支持提前规划扩容的, 利用分片键是时间的特性，可以很简单的实现规划扩容的。
我们现在明天的单量是 2000 万， 在今年的双十一后扩扩容到 4000 万, 那么重写 sharding 的 路由规则，在 11 号之前依旧是旧的路由规则，
但是 11 号之后 按照新的路由规则

## MQ 堆积

1. 确定是否为 消费者的问题

在 消费者没问题的情况下， 增加节点。

在增加消费者的情况下, RabbitMq 的堆积速度不降乃至还在提升。

迁移到另一个队列或者死信队列，后面的消费者进行消费，消费的逻辑，直接入库, 写日志等，尽快帮助生产 RabbitMq 的正常。

RabbitMq 内部有个限流的机制, 消息占用了分配的内存的百分之50 左右，会阻塞消费者发送消息，这个会影响到的基本系统上的所有系统。

后续的话，在有消费者进行消费。

设置了超时时间的消息, 超过了一定时间后, 会被自动清除。


## MQ 持久化

rabbitmq 在启动时会创建 msg_store_persistent, msg_store_transient 两个进程，
一个用于持久消息的存储，一个用于内存不够时，将存储在内存中的非持久化数据转存到磁盘中。

消息都以追加的方式写到一个文件中，当这个文件的大小超过指定的限制大小后，关闭这个文件再创建一个新的文件供消息的写入

在进行消息的存储时，rabbitmq会在ets表中记录消息在文件中的映射，以及文件的相关信息。消息读取时，根据消息ID找到该消息所存储的文件，在文件中的偏移量，然后打开文件进行读取。消息的删除只是从ets表删除指定消息的相关信息，同时更新消息对应存储的文件的相关信息（更新文件有效数据大小）。

由于执行消息删除操作时，并不立即对在文件中对消息进行删除，也就是说消息依然在文件中，仅仅是垃圾数据而已。当垃圾数据超过一定比例后（默认比例为50%），并且至少有三个及以上的文件时，rabbitmq触发垃圾回收。

垃圾回收会先找到符合要求的两个文件 然后锁定这两个文件，并先对左边文件的有效数据进行整理，再将右边文件的有效数据写入到左边文件，同时更新消息的相关信息
最后将右边的文件删除

消息持久化的时机
消息本身在publish的时候就要求消息写入磁盘；
内存紧张，需要将部分内存中的消息转移到磁盘

写入文件前会有一个Buffer，大小为1M（1048576），数据在写入文件时，首先会写入到这个Buffer，如果Buffer已满，则会将Buffer写入到文件（未必刷到磁盘）

有个固定的刷盘时间：25ms，也就是不管Buffer满不满，每隔25ms，Buffer里的数据及未刷新到磁盘的文件内容必定会刷到磁盘；
每次消息写入后，如果没有后续写入请求，则会直接将已写入的消息刷到磁盘


## Redis 跳表的实现

```C++

typedef struct zskiplist {

    /** 头结点 */
    struct zskiplistNode *header;

    /** 尾结点 */
    struct zskiplistNode *tail;

    /** 元素个数 */
    unsigned long length;

    /** 跳表最大的层数, 默认最大为 32 层  */
    int level;

} zskiplist;


typedef struct zskiplistNode {

    /** 节点数据  */
    sds ele;

    /** 节点的分值 */
    double score;

    /** 后向指针, 指向上一个节点 */
    struct zskiplistNode *backward; 

    /** 节点上的层, 数组  */
    struct zskiplistLevel {
        
        /** 前向指针, 指向下一个节点 */
        struct zskiplistNode *forward; 
        
        /** 这个前向指针跳跃过了多少个节点 (不包括当前节点) */
        unsigned int span;      

    } level[]; 

} zskiplistNode;


```

实现简单
跳表不是内存密集型, 将节点的概率参数更改为具体的数字, 这样跳表比 btree 占用更少的内存

排序集大部分都是为 ZRANGE, ZREVRANGE 的操作。 这些操作, 跳跃表的缓存局部性至少与其他类型的平衡树一样好。


## aop 注解执行顺序

@Around
@Before
原方法
@Around
@After
@AfterReturning

出现异常

@Around
@Brfore
原方法
@After
@AfterThrowing

## AQS 

AQS 抽象队列同步器, 提供了一种实现阻塞锁和一系列依赖 FIFO 等待队列的同步器。 Java 中, AQS 是一个抽象类, 内部通过维护一个状态 volatile int state (共享资源)，一个 FIFO 线程等待队列, 通过这 2 个属性实现了 同步状态的管理, 以及对阻塞线程进行排队, 等待通知等一些底层的了分装。同时基于一个模板方法的模式, 提供出了一系列操作共享资源 state 的方法。这样，让子类实现这些方法，来决定共享资源的获取和释放结果，在 AQS 中根据提供出去的方法的返回值，进行锁的获取，进入阻塞队列等底层的操作。最终达到了屏蔽锁操作等底层工作, 而子类自行决定共享资源的情况，就能进行一系列的阻塞锁等功能的同步器。

Redis 锁自动续约


## Redis 

跳表实现

https://segmentfault.com/a/1190000037526623

