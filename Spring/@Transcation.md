# @Transcation

在了解 Spirng Transcation 之前，先讲解一点事务相关的知识。

### 1. 事务的实现方式
在 Spring 中实现事务的方式大体可以分为 2 种
>1. 编程式事务管理  
手动通过代码的形式进行事务的控制, 通过 Spring 提供的 TransactionTemplate 或者底层的 TransactionManager 的实现类进行事务的控制。

>2. 声明式事务管理  
通过 AOP 的方式, 就是在方法的前后进行拦截。在方法的开始的地方，创建/加入一个事务，在方法的结束的地方根据执行的情况，进行事务的提交/回滚。在 Spring 中，可以通过 @Transcation 或者通过通过配置 AOP 的方式，不需要进行代码的侵入，简洁而且简单，推荐使用。

### 2. 事务提交方式
Spring 的事务说到底还是借助于数据库的事务机制，也就是如果没做什么处理的话，Spring 的事务会和数据库的保持一致。

默认情况下，数据库处于自动提交模式。每一条语句处于一个单独的事务中，在这条语句执行完毕时，如果执行成功则隐式的提交事务，如果执行失败则隐式的回滚事务。即使是单独的一条查询语句，也是一个事务。

对于正常的事务管理，一般情况下是一组相关的操作, 需要将他们放在一个事务之中，因此必须关闭数据库的自动提交模式。不过，这个我们不用担心，Spring 会将底层连接的自动提交特性设置为 false。也就是在使用 Spring 进行事物管理的时候，Spring 会将是否自动提交设置为 false，等价于 JDBC 中的 `connection.setAutoCommit(false);`，在执行完之后在进行提交，`connection.commit();`。

### 3. 事务隔离级别
隔离级别是指若干个并发的事务之间的隔离程度, 比如 2 个事务同时存在, 这是事务 A 修改了表中的 A 列, 那么事务 B 读取表中的 A 列, 应该取修改前的值，还是当前的值。TransactionDefinition 接口中定义了五个表示隔离级别的常量：
>1. ISOLATION_DEFAULT: 是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是 ISOLATION_READ_COMMITTED
>2. ISOLATION_READ_UNCOMMITTED: 该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读，不可重复读和幻读，因此很少使用该隔离级别
>3. ISOLATION_READ_COMMITTED: 该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值
>4. ISOLATION_REPEATABLE_READ: 该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。该级别可以防止脏读和不可重复读
>5. ISOLATION_SERIALIZABLE: 所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别