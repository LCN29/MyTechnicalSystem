# 01. Spring源码 - XML 文件的读取


涉及到的类主要为 **XmlBeanDefinitionReader**, 主要涉及到 2 个功能
>1. 读取 XML
>2. 将 XML 里面的内容解析为 BeanDefinition, 用于后面的 bean 实例创建




## 1. Spring 中的对应入口
下面是 Spring 解析 Xml 文件的一个入口, 暂时忽略他的调用方，从这个方法开始, 向下研究 Spring 解析和加载 XML 的过程
```java
public class AbstractXmlApplicationContext {

    protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {

        // 传入一个 BeanDefinitionRegistry 的实现类，只有用于 BeanDefinition 的操作
        XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);
        // 设置当前的环境
        beanDefinitionReader.setEnvironment(this.getEnvironment());
        // 设置 资源加载器为当前类
        beanDefinitionReader.setResourceLoader(this);
        // 设置 EntityResolver 为 ResourceEntityResolver 
        beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));

        // 设置 XmlBeanDefinitionReader 的 validationMode 为 true, namespaceAware 为 false
        initBeanDefinitionReader(beanDefinitionReader);
        // 使用 XmlBeanDefinitionReader 开始解析资源
        loadBeanDefinitions(beanDefinitionReader);
    }
}
```

第一步:
```java
protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException {
    // 获取配置 Resource (本质和 configLocation 一样都是配置文件)
    Resource[] configResources = getConfigResources();
    if (configResources != null) {
        reader.loadBeanDefinitions(configResources);
    }
    // 获取配置文件，正常情况获取到的就是我们配置的文件
    String[] configLocations = getConfigLocations();
    if (configLocations != null) {
        // 调用 XmlBeanDefinitionReader 的不定参数 loadBeanDefinitions 方法
        reader.loadBeanDefinitions(configLocations);
    }
}

public int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException {
    Assert.notNull(locations, "Location array must not be null");
    int count = 0;
    for (String location : locations) {
        // 还是调用到自身的 loadBeanDefinitions 方法
        count += loadBeanDefinitions(location);
    }
    return count;
}

public int loadBeanDefinitions(String location) throws BeanDefinitionStoreException {
    return loadBeanDefinitions(location, null);
}
```

第二步:
```java

public int loadBeanDefinitions(String location, @Nullable Set<Resource> actualResources) throws BeanDefinitionStoreException {

    // 获取资源加载器
    ResourceLoader resourceLoader = getResourceLoader();
    if (resourceLoader == null) {
        throw new BeanDefinitionStoreException(
                "Cannot load bean definitions from location [" + location + "]: no ResourceLoader available");
    }

    // ResourcePatternResolver 和 ResourceLoader 之间的区别
    if (resourceLoader instanceof ResourcePatternResolver) {
        // Resource pattern matching available.
        try {
            Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);
            int count = loadBeanDefinitions(resources);
            if (actualResources != null) {
                Collections.addAll(actualResources, resources);
            }
            if (logger.isTraceEnabled()) {
                logger.trace("Loaded " + count + " bean definitions from location pattern [" + location + "]");
            }
            return count;
        }
        catch (IOException ex) {
            throw new BeanDefinitionStoreException(
                    "Could not resolve bean definition resource pattern [" + location + "]", ex);
        }
    }
    else {
        // Can only load single resources by absolute URL.
        Resource resource = resourceLoader.getResource(location);
        int count = loadBeanDefinitions(resource);
        if (actualResources != null) {
            actualResources.add(resource);
        }
        if (logger.isTraceEnabled()) {
            logger.trace("Loaded " + count + " bean definitions from location [" + location + "]");
        }
        return count;
    }

}

```

问题 1: ResourceLoader 的作用



问题 2: ResourcePatternResolver 和 ResourceLoader 有什么区别




## 1. 读取 XML

我们传入的配置文件的, 会在前面被封装为 Resource
```java
public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {
    return loadBeanDefinitions(new EncodedResource(resource));
}
```

1. 首先将 Resource 对象封装为 EncodedResource, 从名字就可以知道，这个主要用于编码, 内部可以指定编码方式和字符集
2. 从 EncodedResource 获取到输入流 InputStream
3. 再将 InputStream 封装为 InputSource，这个应该和熟悉了吧, SAX 解析的数据源对象






接口
```java
public interface DocumentLoader {
    Document loadDocument(InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception;
}
```

从接口名就能知道, 这个接口就是定义用来获取 XML 文件解析为 Document 的。

默认的实现
```java
public class DefaultDocumentLoader implements DocumentLoader {

}
```
同样的通过类名，可以指定这个类是 DocumentLoader 的默认实现。























## 参考
[XML 验证](https://www.runoob.com/xml/xml-dtd.html)
[Spring5源码分析(008)——IoC篇之获取XML的验证模式](https://www.cnblogs.com/wpbxin/p/13207581.html#label-2-1)
[Android之SAX、DOM和Pull解析XML](https://blog.csdn.net/qq_16628781/article/details/70147230)