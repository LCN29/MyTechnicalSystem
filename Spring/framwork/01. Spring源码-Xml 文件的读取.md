# 01. Spring源码 - XML 文件的读取


## XML 文件的校验

在开始了解 Spring 读取 XML 文件的过程, 我们可以先了解一下 XML 的验证模式, 这个有助于后面 XML 读取的了解

* XML 文件 1
```xml
<?xml version="1.0" encoding="UTF-8"?>
<bean>
    <id>beanName</id>
    <class>com.can.Bean</class>
    <scope>singleton</scope>
</bean>
```

* XML 文件 2
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE bean PUBLIC "-//Spring//DTD BEAN 2.0//EN" "http://www.Springframework.org/dtd/Spring-beans-2.O.dtd">
<bean>
    <id>beanName</id>
    <class>com.can.Bean</class>
    <scope>singleton</scope>
</bean>
```

* XML 文件 3
```xml
<?xml version="1.0" encoding="UTF-8"?>
<xs:element name="bean">
    <xs:complexType>
        <xs:sequence>
            <xs:element name="id" type="xs:string" value="beanName"/>
            <xs:element name="class" type="xs:string" value="com.can.Bean"/>
            <xs:element name="scope" type="xs:string" value="singleton"/>
        </xs:sequence>
    </xs:complexType>
</xs:element>
```
第一个文件, 就是普通的一个 XML 文件。  
而我们知道普通的 XML 的书写是很随意的, 元素名, 元素之间的嵌套都是没有约束的。

第二个文件, 则是一个加了 DTD(Document Type Definition) 校验的 XML 文件。  
DTD 是一种保证 XML 文档格式正确的有效验证机制, 可以通过比较 XML 文档和 DTD 文件来看文档是否符合规范, 元素和标签使用是否正确。  
一个 DTD 文档包含：元素的定义规则、元素间关系的定义规则、元素可使用的属性、可使用的实体或符号规则。它定义了 XML 文档相关的元素、  
属性、实体、排列方式、元素的内容类型以及元素的层次结构。它和普通的 XML 文件的最大的区别就是文件的开头有一个 **DOCTYPE** 的关键字。

虽然 DTD 可以校验 XML 文件的, 但是其本身有一定的缺陷
>1. DTD 不遵守 XML 语法, 这导致解析策略（解析器, DOM、XPath等）难以重用
>2. DTD 对元素类型支持有限, 不能自由扩充, 扩展性差
>3. DTD 不支持命名空间
>4. DTD 中所有元素、属性都是全局的, 无法声明仅与上下文位置相关的元素或属性

第三个文件, 则是一个遵循 XSD(XML Schemas Definition) 校验的 XML 文件。
XSD 是一种用来替代 DTD 的方案。相对于 DTD, XSD 具有如下优势
>1. 基于 XML 没有专门的语法, 可以象其他 XML 文件一样解析和处理
>2. 提供可扩充的数据模型
>3. 支持综合命名空间, 支持属性组

介绍上面的主要是想说明一下, XML 文件的内容可以进行校验的, 在 Spring 对 XML 解析中就有用到

## XML 文件的解析方式

现在主流的解析 xml 的方式有 SAX, DOM, PULL

SAX(Simple API for XML) 使用流式处理的方式, 逐行读取文件内容, 然后基于回调的方式进行通知  
DOM(Document Object Model) 一次性全部将内容加载在内存中，生成一个树状结构,它没有涉及回调和复杂的状态管理
Pull 内置于 Android 系统中, 用于解析布局文件所使用的方式。 Pull 与 SAX有点类似，都提供了类似的事件, Pull 解析器并没有强制要求提
供触发的方法。因为他触发的事件不是一个方法，而是一个数字

Spring 内部使用的是 SAX 进行文件的解析

```java
public static void saxReadXml(String xmlFilePath) throws Exception {
    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
    // 不使用命名空间
    factory.setNamespaceAware(false);
    // 不启用校验
    factory.setValidating(false);
    MyHandler handler = new MyHandler();
    DocumentBuilder docBuilder = factory.newDocumentBuilder();
    docBuilder.setEntityResolver(handler);
    docBuilder.setErrorHandler(handler);
    // 这一步就开始解析文件内容了
    Document doc = docBuilder.parse(new InputSource(xmlFilePath));
    
    // 获取根节点
    Element root = doc.getDocumentElement();
    // 读取跟节点下的所有节点列表
    NodeList nodeList = root.getChildNodes();
    for (int i = 0; i < nodeList.getLength(); i++) {
        Node node = nodeList.item(i);
        if (!(node instanceof Element)) continue;
        Element ele = (Element) node;
        if (!"bean".equals(ele.getNodeName())) continue;
        String id = ele.getAttribute("id");
        String clazz = ele.getAttribute("class");
        String scope = ele.getAttribute("scope");
        System.out.println("Result: beanName: " + id + ", beanClass: "+ clazz +", scope: " + scope);
    }
}

/**
 * 自定义事件实现类, DefaultHandler 是 SAX 提供的一个事件适配器, 可以继承这个, 实现自己关心的事件
 */
public static class MyHandler extends DefaultHandler {
    
    // 读取到 2 个标签的中间内容
    public void characters(char ch[], int start, int length) throws SAXException {
        String s = new String(ch, start, length);
        System.out.println(s);
    }

    // 开始读取到标签
    public void startElement(String uri, String localName, String qName, Attributes attrs) {
        System.out.println(localName + "///" + qName + "///" + uri + "////" + attrs.getValue("id"));
    }
}
```

到这一步, 前提的知识点基本完成了, 下面进行 Spring 读取 XML 的分析

## Spring 读取 XML 

涉及到的类主要为 **XmlBeanDefinitionReader** 主要涉及到 2 个功能
>1. 读取 XML
>2. 将 XML 里面的内容解析为 BeanDefinition, 用于后面的 bean 实例创建

### 1. 读取 XML

我们传入的配置文件的, 会在前面被封装为 Resource
```java
public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {
    return loadBeanDefinitions(new EncodedResource(resource));
}
```

1. 首先将 Resource 对象封装为 EncodedResource, 从名字就可以知道，这个主要用于编码, 内部可以指定编码方式和字符集
2. 从 EncodedResource 获取到输入流 InputStream
3. 再将 InputStream 封装为 InputSource，这个应该和熟悉了吧, SAX 解析的数据源对象






接口
```java
public interface DocumentLoader {
    Document loadDocument(InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception;
}
```

从接口名就能知道, 这个接口就是定义用来获取 XML 文件解析为 Document 的。

默认的实现
```java
public class DefaultDocumentLoader implements DocumentLoader {

}
```
同样的通过类名，可以指定这个类是 DocumentLoader 的默认实现。























## 参考
[XML 验证](https://www.runoob.com/xml/xml-dtd.html)
[Spring5源码分析(008)——IoC篇之获取XML的验证模式](https://www.cnblogs.com/wpbxin/p/13207581.html#label-2-1)
[Android之SAX、DOM和Pull解析XML](https://blog.csdn.net/qq_16628781/article/details/70147230)