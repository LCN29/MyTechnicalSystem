# Redis - 数据一致性


## 1.1 缓存一致性问题

使用 Redis 作为缓存的时候, 一般流程是这样的

应用发起请求, 后台应用拿着 key 到 Redis 查询, (1) **命中缓存**, 返回 Redis 的存储结果, (2) **未命中缓存**, 到数据库查询, 查询到结果的话, 将结果写入 Redis, 返回数据库的存储结果。

因为这些数据是很少修改的, 所以在绝大部分的情况下可以命中缓存。  
但是, 一旦被缓存的数据发生变化的时候, 既要操作数据库的数据, 也要操作 Redis 的数据。  
现在我们有两种选择
> 1. 先操作 Redis 的数据再操作数据库的数据
> 2. 先操作数据库的数据再操作 Redis 的数据

无论哪种选择, 需要达到的效果都是 2 个操作同时成功。   
但是 Redis 的数据和数据库的数据是不可能通过事务达到统一的, 我们只能根据**相应的场景**和**所需要付出的代价**来采取一些措施降低数据不一致的问题出现的概率, 在数据一致性和性能之间取得一个权衡。




操作 Redis 数据的话, 可以在细分为 2 种
> 1. 直接更新 Redis
> 2. 直接删除 Redis, 后续在访问的时候, 进行填充

考虑更新缓存的代价

更新缓存之前, 是不是要经过其他表的查询, 接口调用, 计算才能得到最新的数据, 而不是直接从数据库拿到的值。  
如果是的话, 建议直接删除缓存, 这种方案更加简单, 而且避免了数据库的数据和缓存不一致的情况。 在一般情况下, 也推荐使用删除的方案。

### 先更新数据库，再删除缓存

异常情况: 
> 1. 更新数据库失败，程序捕获异常，不会走到下一步，所以数据不会出现不一致
> 2. 更新数据库成功，删除缓存失败。数据库是新数据，缓存是旧数据，发生了不一 致的情况

解决: **重试的机制**

1. 如果删除缓存失败，我们捕获这个异常，把需要删除的 key 发送到消息队列。 让后自己创建一个消费者消费，尝试再次删除这个 key, 会对业务代码造成入侵。
2. 异步更新缓存, 因为更新数据库时会往 binlog 写入日志，所以我们可以通过一个服务来监听 binlog 的变化（比如阿里的 canal），然后在客户端完成删除 key 的操作。如果删除失败的话， 再发送到消息队列


### 先删除缓存，再更新数据库

异常情况: 
> 1. 删除缓存，程序捕获异常，不会走到下一步，所以数据不会出现不一致
> 2. 删除缓存成功，更新数据库失败。 因为以数据库的数据为准，所以不存在数据 不一致的情况

线程 A 需要更新数据，首先删除了 Redis 缓存
线程 B 查询数据，发现缓存不存在，到数据库查询旧值，写入 Redis，返回
线程 A 更新了数据库

这个时候，Redis 是旧的值，数据库是新的值，发生了数据不一致的情况。

能不能让对同一条数据的访问串行化呢？  
代码肯定保证不了，因 为有多个线程，即使做了任务队列也可能有多个服务实例。数据库也保证不了，因为会有多个数据库的连接。只有一个数据库只提供一个连接的情况下，才能保证读写的操作是串行的，或者我们把所有的读写请求放到同一个内存队列当中，但是这种情况吞吐量太低了。

所以我们有一种延时双删的策略，在写入数据之后，再删除一次缓存。

删除缓存
更新数据库
休眠 500ms（这个时间，依据读取数据的耗时而定）
再次删除缓存


