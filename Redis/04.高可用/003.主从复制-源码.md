# 3 主从复制 - 源码

因为主从复制的过程很复杂, 同时集中在 **replication.c** 这个文件中, 所以为了篇幅, 单独的把功能中涉及的大部分代码都集中到了另一篇文章。
这篇文章中, 这篇主要涉及主从复制的大体代码逻辑, 如果需要了解整体的过程, 可以配合 [03.主从复制-replication源码分析](https://www.baidu.com/) 这篇文章。

## 3.1 主从节点建立连接

Redis 主从节点建立连接的 3 种方式, 本质都是从节点执行 **slaveof** 命令, 和父节点建立初步的关联关系。   
这个命令执行的方法为 **replicaofCommand**。(高版本的 Redis 可以通过 replicaof 达到 slaveof 的效果)

```C
void replicaofCommand(client *c) {

    // 开启了集群功能, 直接返回, 集群模式不允许执行 slaveof 
    if (server.cluster_enabled) {
        addReplyError(c,"REPLICAOF not allowed in cluster mode.");
        return;
    }

    // 第一参数为 no, 第二个参数为 one
    // slaveof no one, 可以让从节点和主节点断开连接, 停止主从复制 
    if (!strcasecmp(c->argv[1]->ptr,"no") && !strcasecmp(c->argv[2]->ptr,"one")) {

        // 如果保存了主节点 IP, 当前节点为某个节点的从节点
        if (server.masterhost) {
            
            // 取消复制操作, 同时设置当前节点为主节点
            // 1. 置空 server.masterhost 
            // 2. 将第一组 replid 和 offset 赋值到第二组, 重试生成一个 replid
            // 3. 置空 server.cached_server
            // 4. 如果在传输 RDB 文件中或者处于握手阶段, 进行取消, 同时取消和主节点的连接
            // 5. 如果有从节点, 释放所有的从节点客户端, 也就是断开从节点的连接
            // 6. 当前节点的状态变为 REPL_STATE_NONE (普通状态, 无主从复制状态)
            replicationUnsetMaster();

            // 获取 client 的每种信息, 并以 sds 形式返回, 并打印到日志中
            sds client = catClientInfoString(sdsempty(),c);
            serverLog(LL_NOTICE,"MASTER MODE enabled (user request from '%s')", client);
            sdsfree(client);
        }

    } else {

        // 当前的客户端的标识为从节点标识
        // 本身是一个从节点了, 无法在执行 salveof ip 端口
        if (c->flags & CLIENT_SLAVE) {

            addReplyError(c, "Command is not valid when client is a replica.");
            return;
        }

        // 从入参中获取端口
        if ((getLongFromObjectOrReply(c, c->argv[2], &port, NULL) != C_OK))
            return;

        // 已经有主节点了, 同时主节点的的 host 和 ip 和入参的相同
        if (server.masterhost && !strcasecmp(server.masterhost,c->argv[1]->ptr) && server.masterport == port) {    

            serverLog(LL_NOTICE,"REPLICAOF would result into synchronization with the master we are already connected with. No operation performed.");
            addReplySds(c,sdsnew("+OK Already connected to specified master\r\n"));
            return;
        }

        // 1. 保存主节点的 IP 和 端口到 server.masterhost 和 server.masterport
        // 2. 解除所有阻塞状态的客户端
        // 3. 释放所有的从节点信息
        // 4. 取消主从复制的握手操作
        // 5. 上次有主节点了, 为 server.cached_server 赋值一个默认生成的 client
        // 6. 设置当前的节点的状态为 REPL_STATE_CONNECT (待连接上主节点)
        replicationSetMaster(c->argv[1]->ptr, port);

        // 生成当前客户端的信息的字符串
        sds client = catClientInfoString(sdsempty(),c);
        serverLog(LL_NOTICE,"REPLICAOF %s:%d enabled (user request from '%s')", server.masterhost, server.masterport, client);
        sdsfree(client);    
    }

    addReply(c,shared.ok);
}
```

当前第一步主要的逻辑就是将当前的主节点的 IP 和 Post 保存起来, 同时经过这一步, 当前实例的复制状态设置为 REPL_STATE_CONNECT。
执行完上的逻辑后, salveof (replicaof) 就结束的, 但是整个的主从复制还没有开始, 可以得出 salveof 是一个异步的命令。 接下来的步骤则是由定时函数 serverCron 定时的调用。

## 3.2 主从网络连接建立

在第一步中, 只是将主节点的信息保存到从节点中就结束了, 之间还是没有建立起相关的网络连接的, 第二步就是完成这个网络连接的操作。
而这个网络连接建立的触发是通过定时函数执行的

```C
int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {

    // 省略

    // 定时 1 秒执行一次
    run_with_period(1000) replicationCron();

    // 省略
}
```

replicationCron 里面涉及到了大量的逻辑, 基本整个复制运行阶段的状态判断等都是在里面判断的, 这里只截取了涉及到当前步骤相关的逻辑。
在第一步操作完成后, 可以知道从节点当前的状态为 **REPL_STATE_CONNECT**。

```C
void replicationCron(void) {

    // 省略

    // 当前的状态为 REPL_STATE_CONNECT (开启了主从复制, 但是还没连接上主节点), 顺利执行了 salveof 后, 从节点的默认状态
    if (server.repl_state == REPL_STATE_CONNECT) {

        // 尝试连接主节点, 连接成功后, 从节点的状态会变为 REPL_STATE_CONNECTING (正在连接主节点)

        // 1. 通过保存的 IP 和 Port 和主节点建立一个 TCP 连接
        // 2. 向事件轮询添加对应的 Socket 通道的读写事件
        // 3. 更新当前节点的状态为 REPL_STATE_CONNECTING (正在连接主节点)
        if (connectWithMaster() == C_OK) {
            serverLog(LL_NOTICE, "MASTER <-> REPLICA sync started");
        }
    }

    // 省略
}
```


第二步的逻辑很简单, 和主节点建立起了 Socket 连接, 同时将当前节点的状态更新为 REPL_STATE_CONNECTING

## 3.3 发送 PING 命令

在第二步的步骤中, 通过保存的主节点 IP 和端口建立起连接后, 会向事件轮询中注册一个 AE_READABLE|AE_WRITABLE 的事件, 
在底层的 epollo 中就是同时注册了一个 EPOLLIN | EPOLLOUT 事件, 这样会触发一次 EPOLLOUT 事件, 也就是触发一次  AE_WRITABLE 事件,
也就是在下次事件轮询中会执行到其注册的函数 syncWithMaster 函数, 所以第三步的入口就是这个函数了。

同样的这个方法涉及到了大量的主从通信复制相关的逻辑, 整个逻辑很复杂, 所以也截取了相关的代码

```C
// 入参中的 fd 就是和主节点建立的 Socket 连接的文件描述符
void syncWithMaster(aeEventLoop *el, int fd, void *privdata, int mask) {



}
```