# 4 主从复制 - 源码

## 4.1 replicationUnsetMaster -  断开主从关系

```C
/**
 * 断开主从关系
 */ 
void replicationUnsetMaster(void) {

     // 没有设置主节点的, 直接返回
    if (server.masterhost == NULL) 
        return;

    // 释放主节点的 host 配置
    sdsfree(server.masterhost);
    server.masterhost = NULL;

    // 把当前的 replid 复制到 replid2
    // 重新生成一个新的 40 位随机 id 并赋值到 replid
    shiftReplicationId();

    // 释放代表主节点的 client 对象
    if (server.master) 
        freeClient(server.master);

    // 将 server.cached_server 设置为空, 同时设置释放对应的内存
    replicationDiscardCachedMaster();

    // 取消主从复制的握手
    cancelReplicationHandshake();

    // 关闭所有的从节点客户端
    disconnectSlaves();

    // 当前节点的主从复制状态设置为 none
    server.repl_state = REPL_STATE_NONE;

    // 从节点选中的数据库为 - 1
    server.slaveseldb = -1;
    server.repl_no_slaves_since = server.unixtime;
}
```

### 4.1.1 shiftReplicationId - 切换第一组 replid 和 offset 到第二组

```C
/**
 * 将第一组 replid 和  offset 复制到第二组
 * 重新生成一个新的 replid, 赋值给第一组的 replid 
 */
void shiftReplicationId(void) {

    // 将 replid 复制到 replid2
    memcpy(server.replid2,server.replid,sizeof(server.replid));

    // second_replid_offset = master_repl_offset + 1;
    server.second_replid_offset = server.master_repl_offset+1;
    
    // 重新生成一个 runId, 并赋值到 server.replid
    changeReplicationId();
    serverLog(LL_WARNING,"Setting secondary replication ID to %s, valid up to offset: %lld. New replication ID is %s", server.replid2, server.second_replid_offset, server.replid);
}
```

### 4.1.2 changeReplicationId - 重新生成一个 replid

```C
/**
 * 重新生成一个 40 位的 id, 并赋值到 replid
 */  
void changeReplicationId(void) {

    // CONFIG_RUN_ID_SIZE = 40, 重新随机生成一个 40 位的 id 并赋值到 replid
    getRandomHexChars(server.replid, CONFIG_RUN_ID_SIZE);
    server.replid[CONFIG_RUN_ID_SIZE] = '\0';
}
```

### 4.1.3 replicationDiscardCachedMaster - 清空缓存的 cached_master 

```C
/**
 * 置空 server.cached_master 
 */
void replicationDiscardCachedMaster(void) {

    if (server.cached_master == NULL) 
        return;

    serverLog(LL_NOTICE,"Discarding previously cached master state.");

    // 先设置为 cashed_master 的 flags = flag & (~CLIENT_MASTER), 其中 CLIENT_MASTER = 1<<1 = 1
    server.cached_master->flags &= ~CLIENT_MASTER;

    // 然后再释放 cached_master
    freeClient(server.cached_master);
    server.cached_master = NULL;
}
```

### 4.1.4 cancelReplicationHandshake -  取消主从复制的握手

```C
/**
 *  如果在传输 RDB 文件或者握手阶段, 进行操作的中断
 */ 
int cancelReplicationHandshake(void) {

    if (server.repl_state == REPL_STATE_TRANSFER) {
        // 1. 当前从节点的状态为 REPL_STATE_TRANSFER (正在接收从主节点发送过来的 RDB 文件)

        // 停止同步传输
        // 关闭从节点同步主节点的 socket 和临时文件描述符 repl_transfer_tmpfile
        replicationAbortSyncTransfer();

        // 更新状态为 REPL_STATE_CONNECT (未连接上主节点)
        server.repl_state = REPL_STATE_CONNECT;

    } else if (server.repl_state == REPL_STATE_CONNECTING || slaveIsInHandshakeState()) {
        // 2. 当前的状态为 REPL_STATE_CONNECTING (正在建立连接) 或者处于握手阶段

        // 关闭从节点同步主节点信息的 Socket, 对应的 Socket 文件描述符为 repl_transfer_s
        undoConnectWithMaster();

        // 更新状态为 REPL_STATE_CONNECT (未连接上主节点)
        server.repl_state = REPL_STATE_CONNECT;

    } else {
        // 3. 其他的情况 

        // 其他状态返回 0
        return 0;
    }

    return 1;
}
```

### 4.1.5 replicationAbortSyncTransfer - 停止文件同步传输

```C
/**
 * 停止同步传输, 
 * 关闭从节点同步主节点的 socket 和临时文件描述符 repl_transfer_tmpfile
 */ 
void replicationAbortSyncTransfer(void) {

    serverAssert(server.repl_state == REPL_STATE_TRANSFER);

    // 关闭从节点同步主节点信息的 Socket repl_transfer_s 和对应的文件描述符 repl_transfer_tmpfile
    undoConnectWithMaster();
    close(server.repl_transfer_fd);
    unlink(server.repl_transfer_tmpfile);
    zfree(server.repl_transfer_tmpfile);
}
```

### 4.1.6 undoConnectWithMaster - 断开和主节点的连接

```C
/**
 *  停止监听主节点 socket 的信息
 */ 
void undoConnectWithMaster(void) {

    int fd = server.repl_transfer_s;

    // 删除 repl_transfer_s 这个文件描述符的事件
    aeDeleteFileEvent(server.el,fd,AE_READABLE|AE_WRITABLE);

    // 关闭这个文件描述符
    close(fd);

    // 重置为 - 1 
    server.repl_transfer_s = -1;
}
```

### 4.1.7 slaveIsInHandshakeState - 判断当前从节点是否处于握手阶段

```C
// 判断当前的从节点的状态是否处于握手阶段中
int slaveIsInHandshakeState(void) {

    // 3 <= server.repl_state <= 13 
    return server.repl_state >= REPL_STATE_RECEIVE_PONG && server.repl_state <= REPL_STATE_RECEIVE_PSYNC;
}
```

### 4.1.8 disconnectSlaves - 关闭所有的从节点

```C
/**
 * 关闭所有的从节点客户端 
 */
void disconnectSlaves(void) {

    while (listLength(server.slaves)) {

        listNode *ln = listFirst(server.slaves);
        freeClient((client*)ln->value);
    }
}
```

## 4.2 replicationSetMaster - 保存主节点信息

```C
/**
 * 保存主节点信息
 */ 
void replicationSetMaster(char *ip, int port) {

    / 获取旧的主节点 IP 配置
    int was_master = server.masterhost == NULL;

    // 将入参的 IP 和 端口赋值给对应的字段
    sdsfree(server.masterhost);
    server.masterhost = sdsnew(ip);
    server.masterport = port;

    // 旧的主节点客户端存在, 进行释放
    if (server.master) {
        freeClient(server.master);
    }

    // 解除所有阻塞状态的客户端
    disconnectAllBlockedClients(); 

    // 释放所有的从节点信息 
    disconnectSlaves();

    //  取消主从复制的握手
    cancelReplicationHandshake();

    // 上次有主节点了, 可能的情景 (假设 A 原本是 B 的从节点, 现在通过 salveof 将 A 变成 C 的从节点)
    // 第一次执行时, 是不会走到这一步的
    if (was_master) {

        // 将 server.cached_server 设置为空, 同时设置释放对应的内存
        replicationDiscardCachedMaster();

        // 根据当前参数合成出一个 client, 同时将其放到 cached_master
        replicationCacheMasterUsingMyself();
    }

    // 设置当前的主从复制状态为待连接上主节点 (REPL_STATE_CONNECT)
    server.repl_state = REPL_STATE_CONNECT;
}
```

### 4.2.1 disconnectAllBlockedClients - 释放所有阻塞状态的客户端

```C
/**
 * 释放所有阻塞状态的客户端
 */ 
void disconnectAllBlockedClients(void) {

    listNode *ln;
    listIter li;

    // 将 server.clients 的信息转移到 li 上
    listRewind(server.clients,&li);

    // 遍历 li
    while((ln = listNext(&li))) {

        client *c = listNodeValue(ln);

        // 客户端为阻塞状态
        if (c->flags & CLIENT_BLOCKED) {
            
            addReplySds(c,sdsnew("-UNBLOCKED force unblock from blocking operation, instance state changed (master -> replica?)\r\n"));

            // 解除所有阻塞状态的客户端
            // unblockClient 会先将入参的 client 的标识 flag 进行，然后放到 server.unblocked_clients 这个列表中, 
            // 在下次事件循环中进行处理, 发送缓存区数据同时从列表中删除
            unblockClient(c);
            c->flags |= CLIENT_CLOSE_AFTER_REPLY;
        }
    }
}
```

### 4.2.2 replicationCacheMasterUsingMyself - 为 server.cached_master 赋值一个默认合成的客户端

```C
/**
 *  为 server.cached_master 赋值一个默认合成的客户端
 */ 
void replicationCacheMasterUsingMyself(void) {

    // 设置当前的 master_initial_offset 等于 master_repl_offset
    server.master_initial_offset = server.master_repl_offset;

    // 创建一个新的主节点客户端, 并存放发到 server.master 中
    replicationCreateMasterClient(-1,-1);

    // 将 server.replid 拷贝到创建出来的节点的 replid
    memcpy(server.master->replid, server.replid, sizeof(server.replid));

    // 通过 replicationCreateMasterClient 创建出来的客户端, unlinkClient 里面的逻辑都不符合条件, 直接结束了
    // 可以看成是没有这个方法的逻辑
    unlinkClient(server.master);

    // 设置 cached_master = master, 同时置空 master 
    server.cached_master = server.master;
    server.master = NULL;
    serverLog(LL_NOTICE,"Before turning into a replica, using my master parameters to synthesize a cached master: I may be able to synchronize with the new master with just a partial transfer.");
}
```

### 4.2.3 replicationCreateMasterClient - 创建主节点客户端

```C
/**
 *  创建主节点客户端
 */
void replicationCreateMasterClient(int fd, int dbid) {

    // 创建新的客户端, 赋值到 master, createClient 创建出来的 flag 默认为 0 
    // 具体的创建逻辑可以查看 networking.c 中的 createClient 函数
    server.master = createClient(fd);

    // 此时 flag = CLIENT_MASTER = 1
    server.master->flags |= CLIENT_MASTER;
    server.master->authenticated = 1;
    server.master->reploff = server.master_initial_offset;
    server.master->read_reploff = server.master->reploff;
    memcpy(server.master->replid, server.master_replid, sizeof(server.master_replid));

    // 如果一个主节点的偏移量为 -1, 那么这个主节点是旧的, 并且是无法进行 psync 的, 所以将其设置为 CLIENT_PRE_PSYNC (1 << 16, 65536)
    if (server.master->reploff == -1)
        // | CLIENT_PRE_PSYNC 后, flags 等于 65537
        server.master->flags |= CLIENT_PRE_PSYNC;

    if (dbid != -1) 
        selectDb(server.master, dbid);
}
```

## 4.3 connectWithMaster -  尝试和主节点建立 TCP 连接

```C
/**
 * 尝试和主节点建立 TCP 连接
 */ 
int connectWithMaster(void) {

    int fd;

    // 建立非阻塞的 Tcp 连接
    fd = anetTcpNonBlockBestEffortBindConnect(NULL,server.masterhost,server.masterport,NET_FIRST_BIND_ADDR);

    // 文件描述符为 -1, 建立连接失败
    if (fd == -1) {
        serverLog(LL_WARNING,"Unable to connect to MASTER: %s", strerror(errno));
        return C_ERR;
    }

    // 添加 fd 的可读和可写事件, 处理的逻辑函数为 syncWithMaster
    // 注意这里注册的类型为 AE_READABLE|AE_WRITABLE, 在 epoll 中, 底层注册的是 EPOLLIN | EPOLLOUT
    // epoll 有个机制, 同时注册 EPOLLIN | EPOLLOUT 事件, 会触发一次 EPOLLOUT 事件, 也就是 AE_WRITABLE 事件
    // 也就是在下次事件轮询中会执行一次 syncWithMaster 函数

    if (aeCreateFileEvent(server.el,fd,AE_READABLE|AE_WRITABLE, syncWithMaster,NULL) == AE_ERR) {
        close(fd);
        serverLog(LL_WARNING,"Can't create readable event for SYNC");
        return C_ERR;
    }

    // 更新从节点和主节点最近一次进行数据同步的时间, 默认为当前时间
    server.repl_transfer_lastio = server.unixtime;
    server.repl_transfer_s = fd;
    server.repl_state = REPL_STATE_CONNECTING;
    return C_OK;
}
```

## 4.4 sendSynchronousCommand - 发送命令到主节点

```C
/**
 * 发送命令到主节点
 */ 
char *sendSynchronousCommand(int flags, int fd, ...) {

    // 发送写命令
    if (flags & SYNC_CMD_WRITE) {

        // 发送 ping 命令时, 入参为 (SYNC_CMD_WRITE,fd,"PING",NULL)
        // flags = SYNC_CMD_WRITE
        
        char *arg;

        // 下面的 va_ 开头的函数, 都是用来处理动态入参的
        va_list ap;
        sds cmd = sdsempty();
        sds cmdargs = sdsempty();
        size_t argslen = 0;
        va_start(ap,fd);

        while(1) {
            arg = va_arg(ap, char*);

            if (arg == NULL) 
                break;
            // 拼接 cmd 命令的参数
            cmdargs = sdscatprintf(cmdargs,"$%zu\r\n%s\r\n",strlen(arg),arg);
            argslen++;
        }

        va_end(ap);

        cmd = sdscatprintf(cmd,"*%zu\r\n",argslen);
        cmd = sdscatsds(cmd,cmdargs);
        sdsfree(cmdargs);

        // 发送给对应的文件描述符, 这里的 fd 是 Socket 通道
        if (syncWrite(fd, cmd, sdslen(cmd), server.repl_syncio_timeout*1000) == -1) {
            sdsfree(cmd);
            return sdscatprintf(sdsempty(),"-Writing to master: %s",strerror(errno));
        }

        sdsfree(cmd);
    }

    // 接受读操作
    if (flags & SYNC_CMD_READ) {

        char buf[256];
        // 读取数据到 buf 中
        if (syncReadLine(fd,buf,sizeof(buf),server.repl_syncio_timeout*1000) == -1) {
            return sdscatprintf(sdsempty(),"-Reading from master: %s", strerror(errno));
        }
        server.repl_transfer_lastio = server.unixtime;
        return sdsnew(buf);
    }
    return NULL;
}
```

## 4.5 slaveTryPartialResynchronization - 根据条件判断是发送部分同步复制还是全量同步复制, 同时支持读取主节点发送信息

```C
/** 
 * 入参的 fd 操作的 Socket 文件描述符
 * 入参的 read_reply 0: 表示向主节点写读取 1: 表示读取主节点的数据
 */
int slaveTryPartialResynchronization(int fd, int read_reply) {

    char *psync_replid;
    char psync_offset[32];
    sds reply;

    // 写操作
    if (!read_reply) {

        // 设置初始的偏移量为 -1
        // -1 表示示主节点的 replid 和全局复制偏移量是无效的
        server.master_initial_offset = -1;

        // 主节点的缓存不为空，可以尝试进行部分重同步
        if (server.cached_master) {

            // psync_replid 为缓存的主节点的 replid
            psync_replid = server.cached_master->replid;

            // 获取部分同步的开始位置 , 赋值给 psync_offset
            snprintf(psync_offset,sizeof(psync_offset),"%lld", server.cached_master->reploff+1);

            serverLog(LL_NOTICE,"Trying a partial resynchronization (request %s:%s).", psync_replid, psync_offset);
        } else {
            // 没有主节点缓存, 进行全量同步
            serverLog(LL_NOTICE,"Partial resynchronization not possible (no cached master)");
            psync_replid = "?";
            memcpy(psync_offset,"-1",3);
        }

        // 部分同步, 最终发送的命令 psync replid repl_offset
        // 全量同步, 最终发送的命令 psync ? -1
        reply = sendSynchronousCommand(SYNC_CMD_WRITE,fd,"PSYNC",psync_replid,psync_offset,NULL);

        // 写失败, 删除对应的文件描述符的读监听
        if (reply != NULL) {
            serverLog(LL_WARNING,"Unable to send PSYNC to master: %s",reply);
            sdsfree(reply);
            aeDeleteFileEvent(server.el,fd,AE_READABLE);
            return PSYNC_WRITE_ERROR;
        }
        return PSYNC_WAIT_REPLY;
    }

    // 下面的读操作可以等待下面的 psync 命令应答在回来看, 现在下面不影响整个的流程

    // 读操作
    reply = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);

    if (sdslen(reply) == 0) {
        // 没有响应数据
        sdsfree(reply);
        return PSYNC_WAIT_REPLY;
    }

    // 比较 reply 前 11 个字符是否为 +FULLRESYNC, 返回 0, 表示一样, 否则不一样
    if (!strncmp(reply,"+FULLRESYNC",11)) {

        // 响应的数据前面的内容为 +FULLRESYNC

        char *replid = NULL, *offset = NULL;

        // 这个是 psync 命令, 全量复制的响应 

        // 定位到第一个空格的位置
        replid = strchr(reply,' ');

        // 获取响应的 replid
        if (replid) {
            // 定位到 replid 的位置
            replid++;
            offset = strchr(replid,' ');
            if (offset) 
                // 定位到 offset 的位置
                offset++;
        }

        // replid 为  0 || offset 为 0 || offset - replid - 1 不等于 40 (replid 的长度为 40)
        if (!replid || !offset || (offset-replid-1) != CONFIG_RUN_ID_SIZE) {

            // 异常处理
            serverLog(LL_WARNING, "Master replied with wrong +FULLRESYNC syntax.");
            // 设置 replid 为 0
            memset(server.master_replid,0,CONFIG_RUN_ID_SIZE+1);

        } else {

            // 将 replid 复制给 server.master_replid 
            memcpy(server.master_replid, replid, offset-replid-1);
            server.master_replid[CONFIG_RUN_ID_SIZE] = '\0';

            // server.master_initial_offset = 获取到的 offset
            server.master_initial_offset = strtoll(offset,NULL,10);

            serverLog(LL_NOTICE,"Full resync from master: %s:%lld", server.master_replid, server.master_initial_offset);
        }

        // 全量复制了, 缓存的主节点没有意义, 清空了
        // 将 server.cached_server 设置为空, 同时设置释放对应的内存
        replicationDiscardCachedMaster();
        sdsfree(reply);
        return PSYNC_FULLRESYNC;
    }

    // 响应的前面的数据为 +CONTINUE
    if (!strncmp(reply,"+CONTINUE",9)) {

        serverLog(LL_NOTICE, "Successful partial resynchronization with master.");

        char *start = reply+10;
        char *end = reply+9;
        while(end[0] != '\r' && end[0] != '\n' && end[0] != '\0') 
            end++;

        
        // 结束的位置 - 开始的位置 = 40 
        if (end-start == CONFIG_RUN_ID_SIZE) {

            // 新的 replid 
            char new[CONFIG_RUN_ID_SIZE+1];
            memcpy(new,start,CONFIG_RUN_ID_SIZE);
            new[CONFIG_RUN_ID_SIZE] = '\0';

            // replid 和当前的缓存主节点 cached_master 的 replid 不一致
            // 只能进行全量复制
            if (strcmp(new,server.cached_master->replid)) {

                // 主节点的 replid 改变了
                serverLog(LL_WARNING,"Master replication ID changed to %s",new);

                // 将当前的 cached_master 的 replid 赋值给 replid2
                memcpy(server.replid2,server.cached_master->replid, sizeof(server.replid2));
                server.second_replid_offset = server.master_repl_offset+1;

                // 新的 replid 赋值到 replidid
                memcpy(server.replid,new,sizeof(server.replid));
                // 设置缓存的客户端的 cached_master 的 replid = server.replid
                memcpy(server.cached_master->replid,new,sizeof(server.replid));

                // 释放从节点
                disconnectSlaves();
            }
        }    

        sdsfree(reply);

        // 重新将 cached_master 作为主节点使用
        replicationResurrectCachedMaster(fd);  

        if (server.repl_backlog == NULL) 
            // 没有复制积压缓冲区, 进行创建
            createReplicationBacklog();
        return PSYNC_CONTINUE;
    }

    // 主节点无法响应 psync 命令
    // 主节点处于一个特殊的状态, 无法处理对应的请求
    if (!strncmp(reply,"-NOMASTERLINK",13) || !strncmp(reply,"-LOADING",8)){
        serverLog(LL_NOTICE, "Master is currently unable to PSYNC but should be in the future: %s", reply);
        sdsfree(reply);
        return PSYNC_TRY_LATER;
    }

    // 响应了异常
    if (strncmp(reply,"-ERR",4)) {
        serverLog(LL_WARNING, "Unexpected reply to PSYNC from master: %s", reply);
    } else {
        serverLog(LL_NOTICE, "Master does not support PSYNC or is in error state (reply: %s)", reply);
    }

    sdsfree(reply);
    // 将 server.cached_server 设置为空, 同时设置释放对应的内存
    replicationDiscardCachedMaster();
    return PSYNC_NOT_SUPPORTED;

}
```

### 4.5.1 replicationResurrectCachedMaster - 重新将缓存的主节点作为真正的主节点使用

```C
/**
 * 重新将缓存的主节点作为真正的主节点使用
 */ 
void replicationResurrectCachedMaster(int newfd) {

    server.master = server.cached_master;
    server.cached_master = NULL;
    server.master->fd = newfd;
    server.master->flags &= ~(CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP);
    server.master->authenticated = 1;
    server.master->lastinteraction = server.unixtime;
    server.repl_state = REPL_STATE_CONNECTED;
    server.repl_down_since = 0;

    linkClient(server.master);

    // 添加事件
    if (aeCreateFileEvent(server.el, newfd, AE_READABLE, readQueryFromClient, server.master)) {
        serverLog(LL_WARNING,"Error resurrecting the cached master, impossible to add the readable handler: %s", strerror(errno));
        freeClientAsync(server.master);
    }

    // 当前的主节点有数据需要发送 
    if (clientHasPendingReplies(server.master)) {
        // 添加一个写事件
        if (aeCreateFileEvent(server.el, newfd, AE_WRITABLE,  sendReplyToClient, server.master)) {
            serverLog(LL_WARNING,"Error resurrecting the cached master, impossible to add the writable handler: %s", strerror(errno));
            freeClientAsync(server.master);
        }
    }
}
```

### 4.5.2 clientHasPendingReplies - 判断当前的入参的客户端是否有数据需要发送

```C
/**
 *   判断入参的客户端释放有数据需要发送出去
 */ 
int clientHasPendingReplies(client *c) {
    // 固定缓存区有数据 或者 回复列表有数据
    return c->bufpos || listLength(c->reply);
}
```

### 4.5.3 createReplicationBacklog - 创建复制积压缓冲区

```C
// 创建复制积压缓冲区 
void createReplicationBacklog(void) {

    serverAssert(server.repl_backlog == NULL);

    server.repl_backlog = zmalloc(server.repl_backlog_size);
    server.repl_backlog_histlen = 0;
    server.repl_backlog_idx = 0;
    
    // 虽然没有任何数据, 但是第一个字节是数据写入的位置
    server.repl_backlog_off = server.master_repl_offset+1;
}
```


##



### 