
# 1 主从复制

## 1.1 主从节点运行数据的存储

在主从复制中, 对于主节点, 从节点就是自身的一个客户端, 所以和普通的客户端一样, 会被组织为一个 client 的结构体。 

```C
typedef struct client {
    // 省略
} client;
```

同时无论是从节点, 还是主节点, 在运行中, 都是用一个 redisServer 的结构体表示

```C
struct redisServer {
    // 省略
};
```

在主从复制中的 client 和 redisServer 都是可以用来存储运行中的一些数据。
具体里面存储的数据是什么, 在后面分析。

## 1.2 主从节点复制中的状态枚举

### 1.2.1 从节点自身状态的状态枚举

```C

// 没有开启主从复制功能, 默认的状态
#define REPL_STATE_NONE 0

// 开启了主从复制, 但是还没连接上主节点
// 执行了 slaveof/replicaof 命令时, 从节点的切换成的状态 
#define REPL_STATE_CONNECT 1

// 正在连接主节点, 从节点开始连接主节点
#define REPL_STATE_CONNECTING 2

/* --- 握手阶段的状态开始, 整个握手过程必须按照下面的顺序进行 --- */

// 从节点发送了 ping, 等待主节点 pong  应答 (正常情况, 主节点会回复一个 pong)
#define REPL_STATE_RECEIVE_PONG 3

// 准备发送认证密码给主节点
#define REPL_STATE_SEND_AUTH 4

// 等待主节点响应认证结果应答
#define REPL_STATE_RECEIVE_AUTH 5

// 准备发送从节点的监听的端口
#define REPL_STATE_SEND_PORT 6 

// 等待主节点响应收到从节点端口
#define REPL_STATE_RECEIVE_PORT 7

// 发送主从复制配置的监听的 IP 地址
#define REPL_STATE_SEND_IP 8 

// 等待主节点响应收到从节点的 IP 地址
#define REPL_STATE_RECEIVE_IP 9

// 准备发送从节点支持的同步能力 
#define REPL_STATE_SEND_CAPA 10 

// 等待主节点响应收到支持的同步能力的应答
#define REPL_STATE_RECEIVE_CAPA 11

// 向主节点发送 psync 命令, 请求同步复制
#define REPL_STATE_SEND_PSYNC 12 

// 等待 psync 应答
#define REPL_STATE_RECEIVE_PSYNC 13

/* --- 握手阶段的状态结束 --- */

// 正在接收从主节点发送过来的 RDB 文件
#define REPL_STATE_TRANSFER 14 

// 已经连接状态
#define REPL_STATE_CONNECTED 15 

```

### 1.2.2 主节点保存从节点的状态枚举

对于主节点而言, 也是需要知道从节点当前的状态的, 好进行对应的操作, 但是不需要那么详细, 主节点保存的从节点状态如下

```C

// 等待 bgsave (生成 RDB 文件的函数) 的开始
#define SLAVE_STATE_WAIT_BGSAVE_START 6

// 等待 bgsave 的结束, 也就是 RDB 文件的创建结束
#define SLAVE_STATE_WAIT_BGSAVE_END 7

// 发送一个 RDB 文件到从节点
#define SLAVE_STATE_SEND_BULK 8

// 从节点在线
#define SLAVE_STATE_ONLINE 9
```

## 1.3 从节点复制能力

在主从节点运行中, 主节点处理完了命令, 会将其同步到从节点, 达到主从节点数据的一致性。  

但是当主从节点之间出现网络波动, 中断等情况, 那么主节点就需要重新将所用的数据同步给从节点, 这个全部数据的同步的操作叫做**全量复制**。
这个全量复制本质是生成一个 RDB 的文件, 然后以 **EOF** 的流格式发送给从节点的。

可以看出一旦出现了全量复制, 将是一个耗时, 占资源的过程, fork 子进程, RDB 文件生成, 数据发送。  

为了尽量避免全量复制的出现, 在 Redis 2.8 版本, 引入了一个**复制积压缓冲区**的缓存区, 主节点执行的命令, 会先保存一份到这个缓存区,  
在发送给从节点。在主从节点出现断开连接又重新连接上时, 会先尝试从复制积压缓冲区将这段时间丢失的命令重新发送给从节点, 这样就能避免全量复制。
这种方式叫做**部分复制**。复制积压缓冲区的容量不是无限的, 会自动淘汰旧的数据, 和从节点从那个位置开始同步等, 所以这个部分复制还是涉及很多东西的, 后面再展开。

在 Redis 2.8 版本引入的部分复制, 还是有些问题, 如从节点重启, 主节点故障切换等, 从节点还是需要全量复制。  
所以在 Redis 4.0 版本对部分复制又做了加强, 使其可以支持更多的场景。

上面说的 3 个版本的复制能力, 在代码中分别叫做 **EOF**, **psync1**, **psync2**。

复制能力的定义如下:  
```C
// 什么能力都不支持
#define SLAVE_CAPA_NONE 0

// 支持 EOF, 支持全量复制, 可以解析 RDB EOF 流式处理格式
#define SLAVE_CAPA_EOF (1<<0) 

// 支持 psync2, 支持部分复制
#define SLAVE_CAPA_PSYNC2 (1<<1)
```

对于 Redis 从节点, 可能因为版本问题, 存在着复制能力不一致的情况, 所以在主从复制开始的阶段, 从节点需要将自身支持的复制能力发送给主节点,
主节点才能以正确的方式同步数据给从节点。




