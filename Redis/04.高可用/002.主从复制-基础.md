
# 2 主从复制 - 基础

## 2.1 主从节点运行数据的存储

在主从复制中, 对于主节点, 从节点就是自身的一个客户端, 所以和普通的客户端一样, 会被组织为一个 client 的结构体。 

```C
typedef struct client {
    // 省略
} client;
```

同时无论是从节点, 还是主节点, 在运行中, 都是用一个 redisServer 的结构体表示

```C
struct redisServer {
    // 省略
};
```

在主从复制中的 client 和 redisServer 都是用来存储运行中的一些数据。
具体里面存储的数据是什么, 在后面的源码分析中, 逐渐了解。

## 2.2 主从节点复制中的状态枚举

### 2.2.1 从节点自身状态的状态枚举

整个主从复制是一个复杂的过程, 所以在从节点中, 维护了一套状态, 通过状态来判断下一步的流程

```C
// 没有开启主从复制功能, 默认的状态
#define REPL_STATE_NONE 0

// 开启了主从复制, 但是还没连接上主节点
// 执行了 slaveof/replicaof 命令时, 从节点的切换成的状态 
#define REPL_STATE_CONNECT 1

// 正在连接主节点, 从节点开始连接主节点
#define REPL_STATE_CONNECTING 2

/* --- 握手阶段的状态开始, 整个握手过程必须按照下面的顺序进行 --- */

// 从节点发送了 ping, 等待主节点 pong  应答 (正常情况, 主节点会回复一个 pong)
#define REPL_STATE_RECEIVE_PONG 3

// 准备发送认证密码给主节点
#define REPL_STATE_SEND_AUTH 4

// 等待主节点响应认证结果应答
#define REPL_STATE_RECEIVE_AUTH 5

// 准备发送从节点的监听的端口
#define REPL_STATE_SEND_PORT 6 

// 等待主节点响应收到从节点端口
#define REPL_STATE_RECEIVE_PORT 7

// 发送主从复制配置的监听的 IP 地址
#define REPL_STATE_SEND_IP 8 

// 等待主节点响应收到从节点的 IP 地址
#define REPL_STATE_RECEIVE_IP 9

// 准备发送从节点支持的同步能力 
#define REPL_STATE_SEND_CAPA 10 

// 等待主节点响应收到支持的同步能力的应答
#define REPL_STATE_RECEIVE_CAPA 11

// 向主节点发送 psync 命令, 请求同步复制
#define REPL_STATE_SEND_PSYNC 12 

// 等待 psync 应答
#define REPL_STATE_RECEIVE_PSYNC 13

/* --- 握手阶段的状态结束 --- */

// 正在接收从主节点发送过来的 RDB 文件
#define REPL_STATE_TRANSFER 14 

// 已经连接状态
#define REPL_STATE_CONNECTED 15 

```

### 2.2.2 主节点保存从节点的状态枚举

对于主节点而言, 需要知道从节点当前的状态的, 好进行对应的操作, 但是不需要那么详细, 主节点维护了一套从节点运行时的状态

```C

// 等待 bgsave (生成 RDB 文件的函数) 的开始
#define SLAVE_STATE_WAIT_BGSAVE_START 6

// 等待 bgsave 的结束, 也就是 RDB 文件的创建结束
#define SLAVE_STATE_WAIT_BGSAVE_END 7

// 发送一个 RDB 文件到从节点
#define SLAVE_STATE_SEND_BULK 8

// 从节点在线
#define SLAVE_STATE_ONLINE 9
```

## 1.3 从节点复制能力

整个主从复制, 大体可以概括为 3 种情况
> 1. 一开始, 主从节点建立连接, 这时候主节点需要将自身所有的数据全部同步给从节点
> 2. 运行中, 主节点需要将自己处理的命令, 发送一份给从节点, 这样才能保证主从的一致
> 3. 运行中, 出现了网络波动, 服务重启等情况, 重新恢复正常时, 主从需要重新通过**复制**, 让彼此的数据重新保持一致

**第一步**, 主从建立了连接, 主节点会将自身所有的数据生成为一个 RDB 的文件, 然后以 **EOF** 的流格式发送给从节点。  
当然, Redis 在 2.8.18 版本开始支持**无盘复制**, 子进程直接将 RDB 通过网络发送给从服务器, 不使用磁盘作为中间存储。  
主要是防止比较低速的磁盘, 写入缓慢, 影响到整个应用。  
这个主节点将所有数据发送给从节点的操作, 叫做**全量复制**。  

**第二步**, 在运行中, 主节点处理完了命令, 会遍历自身维护的所有的从节点, 将自身执行的命令发送给所有状态符合的从节点, 保证数据的一致。

可以看出来, 第一, 二步的操作是一个比较简单的过程, 而第三步, 在兼容性能的情况下, 将会是一个复杂的过程。

**第三步**, 主从节点之间出现网络波动, 从节点重启等行为后, 主从之间就可能出现数据不一致。  
在 Reids 2.8 版本之前, Reids 的操作就是通过在来一次**全量复制**, 保证了主从节点数据的一致性。
但是从上面的行为可以看出来, **全量复制**是一个耗时, 耗资源的过程, 比如 fork 子进程, RDB 文件生成, 数据发送。

为了尽量避免**全量复制**的出现, 在 Redis 2.8 版本, 引入了一个**复制积压缓冲区**的缓存区, 主节点执行的命令, 会先保存一份到这个缓存区  
(这个缓存区是一个环形的数组, 从头写到尾, 写满了, 重新回到头, 继续写, 新的数据覆盖掉旧的, 同时所有的从节点共用一个缓冲区)。



https://blog.csdn.net/qq_42409788/article/details/104246731





在主从节点运行中, 主节点处理完了命令, 会将其同步到从节点, 达到主从节点数据的一致性。  

但是当主从节点之间出现网络波动, 中断等情况, 那么主节点就需要重新将所用的数据同步给从节点, 这个全部数据的同步的操作叫做**全量复制**。
这个全量复制本质是生成一个 RDB 的文件, 然后以 **EOF** 的流格式发送给从节点的。

可以看出一旦出现了全量复制, 将是一个耗时, 占资源的过程, fork 子进程, RDB 文件生成, 数据发送。  

为了尽量避免全量复制的出现, 在 Redis 2.8 版本, 引入了一个**复制积压缓冲区**的缓存区, 主节点执行的命令, 会先保存一份到这个缓存区,  
在发送给从节点。在主从节点出现断开连接又重新连接上时, 会先尝试从复制积压缓冲区将这段时间丢失的命令重新发送给从节点, 这样就能避免全量复制。
这种方式叫做**部分复制**。复制积压缓冲区的容量不是无限的, 会自动淘汰旧的数据, 和从节点从那个位置开始同步等, 所以这个部分复制还是涉及很多东西的, 后面再展开。

在 Redis 2.8 版本引入的部分复制, 还是有些问题, 如从节点重启, 主节点故障切换等, 从节点还是需要全量复制。  
所以在 Redis 4.0 版本对部分复制又做了加强, 使其可以支持更多的场景。

上面说的 3 个版本的复制能力, 在代码中分别叫做 **EOF**, **psync1**, **psync2**。

复制能力的定义如下:  
```C
// 什么能力都不支持
#define SLAVE_CAPA_NONE 0

// 支持 EOF, 支持全量复制, 可以解析 RDB EOF 流式处理格式
#define SLAVE_CAPA_EOF (1<<0) 

// 支持 psync2, 支持部分复制
#define SLAVE_CAPA_PSYNC2 (1<<1)
```

对于 Redis 从节点, 可能因为版本问题, 存在着复制能力不一致的情况, 所以在主从复制开始的阶段, 从节点需要将自身支持的复制能力发送给主节点,
主节点才能以正确的方式同步数据给从节点。




