# 2 主从复制 - 源码

因为主从复制的过程很复杂, 同时集中在 replication.c 这个文件中, 所以为了篇幅, 单独的把功能中涉及的大部分代码都集中到了 [03.主从复制-replication源码分析] 这篇文章中,  
这篇主要涉及主从复制的大体代码逻辑, 如果需要了解整体的过程, 可以配合 [03.主从复制-replication源码分析] 这篇文章。


## 2.1 主从节点建立连接

Redis 主从节点建立连接的 3 种方式, 本质都是从节点执行 **slaveof** 命令, 和父节点建立初步的关联关系。   
这个命令执行的方法为 **replicaofCommand**。

```C
void replicaofCommand(client *c) {

    // 开启了集群功能, 直接返回, 集群模式不允许执行 slaveof 
    if (server.cluster_enabled) {
        addReplyError(c,"REPLICAOF not allowed in cluster mode.");
        return;
    }
    
    // 第一参数为 no, 第二个参数为 one
    // slaveof no one, 可以让从节点和主节点断开连接, 停止主从复制 
    if (!strcasecmp(c->argv[1]->ptr,"no") && !strcasecmp(c->argv[2]->ptr,"one")) {

        // 如果保存了主节点IP
        if (server.masterhost) {
            
            // 取消复制操作, 同时设置当前节点为主节点
            replicationUnsetMaster();

            // 获取 client 的每种信息, 并以 sds 形式返回, 并打印到日志中
            sds client = catClientInfoString(sdsempty(),c);
            serverLog(LL_NOTICE,"MASTER MODE enabled (user request from '%s')", client);
            sdsfree(client);
        }

    } else {

        long port;

        // 当前的客户端的标识为从节点标识
        // 本身是一个从节点了, 无法在执行 salveof ip 端口
        if (c->flags & CLIENT_SLAVE) {

            addReplyError(c, "Command is not valid when client is a replica.");
            return;
        }

        // 从入参中获取端口
        if ((getLongFromObjectOrReply(c, c->argv[2], &port, NULL) != C_OK))
            return;

        // 已经有主节点了, 同时主节点的的 host 和 ip 和入参的相同
        if (server.masterhost && !strcasecmp(server.masterhost,c->argv[1]->ptr) && server.masterport == port) {    

            serverLog(LL_NOTICE,"REPLICAOF would result into synchronization with the master we are already connected with. No operation performed.");
            addReplySds(c,sdsnew("+OK Already connected to specified master\r\n"));
            return;
        }

        // 保存主节点的信息
        replicationSetMaster(c->argv[1]->ptr, port);

        sds client = catClientInfoString(sdsempty(),c);
        serverLog(LL_NOTICE,"REPLICAOF %s:%d enabled (user request from '%s')", server.masterhost, server.masterport, client);
        sdsfree(client);
    }

    addReply(c,shared.ok);
}

```

这个函数的逻辑涉及很多细节
> 释放之前被阻塞的客户端，这些通常是使用 Redis 阻塞列表而被阻塞的客户端
> 断开当前实例的所有 slave
> 清除缓存的 master 信息, 释放复制积压缓冲区 backlog
> 取消正在进行的握手过程
> 等等

但是当前第一步主要的逻辑就是将当前的主节点的 IP 和 Post 保存起来, 同时经过这一步, 当前实例的复制状态设置为 REPL_STATE_CONNECT。

执行完上的逻辑后, salveof 就结束的, 但是整个的主从复制还没有开始, 可以得出 salveof 是一个异步的命令。 接下来的步骤则是由定时函数 serverCron 定时的调用。

## 2.2 主从网络连接建立

在第一步中, 只是将主节点的信息保存到从节点中就结束了, 之间还是没有建立起相关的网络连接的, 第二步就是完成这个网络连接的操作。


```C
int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {

    // 省略

    // 定时 1 秒执行一次
    run_with_period(1000) replicationCron();

    // 省略
}
```

replicationCron 里面涉及到了大量的逻辑, 基本整个复制运行阶段的状态判断等都是在里面判断的, 这里只截取了涉及到当前步骤相关的逻辑。
在第一步操作完成后, 可以知道从节点当前的状态为 **REPL_STATE_CONNECT**。

```C
void replicationCron(void) {

    // 省略

    // 当前的状态为 REPL_STATE_CONNECT (开启了主从复制, 但是还没连接上主节点), 顺利执行了 salveof 后, 从节点的默认状态
    if (server.repl_state == REPL_STATE_CONNECT) {

        // 尝试连接主节点, 连接成功后, 从节点的状态会变为 REPL_STATE_CONNECTING (正在连接主节点)
        if (connectWithMaster() == C_OK) {
            serverLog(LL_NOTICE, "MASTER <-> REPLICA sync started");
        }
    }

    // 省略

}
```

第二步的逻辑很简单, 和主节点建立起了 Socket 连接, 同时将当前节点的状态更新为 REPL_STATE_CONNECTING


## 2.3 发送 PING 命令

在第二步的步骤中, 通过保存的主节点 IP 和端口建立起连接后, 会向事件轮询中注册一个 AE_READABLE|AE_WRITABLE 的事件, 
在底层的 epollo 中就是同时注册了一个 EPOLLIN | EPOLLOUT 事件, 这样会触发一次 EPOLLOUT 事件, 也就是触发一次  AE_WRITABLE 事件,
也就是在下次事件轮询中会执行到其注册的函数 syncWithMaster 函数, 所以第三步的入口就是这个函数了。

同样的这个方法涉及到了大量的主从通信复制相关的逻辑, 整个逻辑很复杂, 所以也截取了相关的代码

```C
// 入参中的 fd 就是和主节点建立的 Socket 连接的文件描述符
void syncWithMaster(aeEventLoop *el, int fd, void *privdata, int mask) {

    int sockerr = 0;
    socklen_t errlen = sizeof(sockerr);
    
    UNUSED(el);
    UNUSED(privdata);
    UNUSED(mask);

    // 状态为 REPL_STATE_NONE, 关闭对应的文件描述符
    if (server.repl_state == REPL_STATE_NONE) {
        close(fd);
        return;
    }

    // 检查当前的 Socket 通道的状态
    if (getsockopt(fd, SOL_SOCKET, SO_ERROR, &sockerr, &errlen) == -1)
        // 获取异常信息
        sockerr = errno;

    // 有异常信息
    if (sockerr) {
        serverLog(LL_WARNING,"Error condition on socket for SYNC: %s", strerror(sockerr));
        goto error;
    }


    if (server.repl_state == REPL_STATE_CONNECTING) {

        serverLog(LL_NOTICE,"Non blocking connect for SYNC fired the event.");
        
        // 删除当前这个 Socket 的可写事件, 不关心写事件
        aeDeleteFileEvent(server.el,fd,AE_WRITABLE);

        // 状态修改为 REPL_STATE_RECEIVE_PONG (发送 pong, 等待 ping 回答)
        server.repl_state = REPL_STATE_RECEIVE_PONG;
        
        // 发送同步命令, 也就是 ping 到主节点, SYNC_CMD_WRITE = 1
        err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,"PING",NULL);
        if (err) 
            goto write_error;
        return;
    }

    // 省略

error:
    // 删除对应的事件和文件描述符
    aeDeleteFileEvent(server.el,fd,AE_READABLE|AE_WRITABLE);
    if (dfd != -1) close(dfd);
    close(fd);
    server.repl_transfer_s = -1;
    // 重新将状态设置为 REPL_STATE_CONNECT, 重新走一遍建立连接的过程
    server.repl_state = REPL_STATE_CONNECT;
    return;

write_error:
    // 打印日志
    serverLog(LL_WARNING,"Sending command to master in replication handshake: %s", err);
    sdsfree(err);
    goto error;

}
```

从节点向主节点发送了一个 Ping 的命令, 这时候主节点收到了从节点的 Ping 命令后, 处理正常后, 会响应一个 Pong 的命令。
这时候从节点的状态为 REPL_STATE_RECEIVE_PONG

**主节点**执行的 Ping 命令的逻辑如下

```C
void pingCommand(client *c) {

    // ping 命令的参数只能是 1 个或者 0 个
    if (c->argc > 2) {
        addReplyErrorFormat(c,"wrong number of arguments for '%s' command",
            c->cmd->name);
        return;
    }

    // 对应的客户端处于 Pub/Sub 模式
    if (c->flags & CLIENT_PUBSUB) {
        addReply(c,shared.mbulkhdr[2]);
        addReplyBulkCBuffer(c,"pong",4);
        if (c->argc == 1)
            addReplyBulkCBuffer(c,"",0);
        else
            addReplyBulk(c,c->argv[1]);
    } else {

        // 其他模式
        
        // 参数是 1 个, 响应一个 pong
        if (c->argc == 1)
            addReply(c,shared.pong);
        else
            // 响应入参的第 2 个参数
            addReplyBulk(c,c->argv[1]);
    }
}
```

**从节点** 收到了主节点发送过来的 Ping 命令, 同时在上面第 2 步就建立了对应的可读事件, 这时事件轮询循环中找到了监听到了可读事件, 又执行到 **syncWithMaster** 函数

```C

void syncWithMaster(aeEventLoop *el, int fd, void *privdata, int mask) {

    // 省略

    // 当前从节点处于 REPL_STATE_RECEIVE_PONG 状态 (发送 ping, 等待 pong  应答)
    if (server.repl_state == REPL_STATE_RECEIVE_PONG) {
        
        // 读取主节点响应的信息
        err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);

        // 异常情况
        if (err[0] != '+' && strncmp(err,"-NOAUTH",7) != 0 && strncmp(err,"-ERR operation not permitted",28) != 0) {
            serverLog(LL_WARNING,"Error reply to PING from master: '%s'",err);
            sdsfree(err);
            goto error;
        } else {
            // 响应的是 Pong, 响应了 Ping 请求, 能继续处理
            serverLog(LL_NOTICE, "Master replied to PING, replication can continue...");
        }
        sdsfree(err);
        // 状态切换到 REPL_STATE_SEND_AUTH, 等待认证结果应答
        server.repl_state = REPL_STATE_SEND_AUTH;
    }
}
```


## 2.4 认证权限

在从节点发送 Ping, 主节点响应 Pong , 从节点收到 Pong 响应后, 进入处理时 (syncWithMaster 函数), 
状态修改为 **REPL_STATE_SEND_AUTH** 后, 方法继续执行下去, 立即进入认证权限的过程。

```C

void syncWithMaster(aeEventLoop *el, int fd, void *privdata, int mask) {

    // 省略

    // 当前从节点处于 REPL_STATE_RECEIVE_PONG 状态 (发送 ping, 等待 pong  应答)
    if (server.repl_state == REPL_STATE_RECEIVE_PONG) {

        // 省略

        // 状态切换到 REPL_STATE_SEND_AUTH, 等待认证结果应答
        server.repl_state = REPL_STATE_SEND_AUTH;
    }

    // 进入认证, 如果需要的话
    if (server.repl_state == REPL_STATE_SEND_AUTH) {
        // 配置了主节点的密码
        if (server.masterauth) {
            // 发送认证请求和密码到主节点
            err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,"AUTH",server.masterauth,NULL);
            if (err) 
                goto write_error;
            // 状态切换为 REPL_STATE_RECEIVE_AUTH
            server.repl_state = REPL_STATE_RECEIVE_AUTH;
            return;
        } else {
            // 不需要认证, 状态之间切换为 REPL_STATE_SEND_PORT 准备发送端口
            server.repl_state = REPL_STATE_SEND_PORT;
        }
    }

}
```

**从节点**根据是否配置了主节点认证密码, 走不通的逻辑
> 1. 配置了认证密码, 发送 AUTH 密码, 同时带上密码到主节点, 同时状态变为 REPL_STATE_RECEIVE_AUTH (等待主节点响应认证结果应答)
> 2. 没有配置认证密码, 直接将状态变为 REPL_STATE_SEND_PORT (准备发送从节点的监听的端口)


**主节点**收到从节点的认证请求 auth, 就会进入到权限认证的过程,  执行的逻辑如下:

```C
void authCommand(client *c) {

    // 主节点不需要密码认证
    if (!server.requirepass) {
        addReplyError(c,"Client sent AUTH, but no password is set");
    } else if (!time_independent_strcmp(c->argv[1]->ptr, server.requirepass)) {

      // 密码认证成功  
      c->authenticated = 1;
      addReply(c,shared.ok);

    } else {

      // 密码认证失败  
      c->authenticated = 0;
      addReplyError(c,"invalid password");
    }
}
```

同 Ping Pong 的处理逻辑一样, 这时从节点读取到主节点的响应, 事件轮询触发 **syncWithMaster** 函数

```C
void syncWithMaster(aeEventLoop *el, int fd, void *privdata, int mask) {

    // 接收到请求认证的响应
    if (server.repl_state == REPL_STATE_RECEIVE_AUTH) {

        // 读取响应信息
        err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);
        
        // 认证失败
        if (err[0] == '-') {
            serverLog(LL_WARNING,"Unable to AUTH to MASTER: %s",err);
            sdsfree(err);
            goto error;
        }

        // 认证成功
        sdsfree(err);
        // 状态变为 REPL_STATE_SEND_PORT (准备发送从节点的监听的端口)
        server.repl_state = REPL_STATE_SEND_PORT;
    }
}
```

## 2.5 发送端口号

在不需要权限认证或者从节点收到主节点的权限认证成功后, 此时从节点的状态为 **REPL_STATE_SEND_PORT**, 同时是在上一步的处理逻辑中, 继续处理

```C
void syncWithMaster(aeEventLoop *el, int fd, void *privdata, int mask) {

    // 省略

    // 收到权限认证的响应
    if (server.repl_state == REPL_STATE_RECEIVE_AUTH) {

        // 省略

        server.repl_state = REPL_STATE_SEND_PORT;
    }

    // 进入发送端口阶段
    if (server.repl_state == REPL_STATE_SEND_PORT) {

        // 如果有配置一个专门复制的端口的话, 使用配置的端口, 没有使用当前服务器的端口
        sds port = sdsfromlonglong(server.slave_announce_port ? server.slave_announce_port : server.port);

        // 发送端口信息给主节点
        err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,"REPLCONF", "listening-port",port, NULL);
        sdsfree(port);
        if (err) 
            goto write_error;
        sdsfree(err);
        // 切换状态为 REPL_STATE_RECEIVE_PORT ()
        server.repl_state = REPL_STATE_RECEIVE_PORT;
        return;
    }
}
```

**主节点**收到从节点的发送端口请求 REPLCONF, 执行的逻辑如下

```C
void replconfCommand(client *c) {

    int j;

    // 参数需要是 2 的倍数
    if ((c->argc % 2) == 0) {
        addReply(c,shared.syntaxerr);
        return;
    }

    for (j = 1; j < c->argc; j+=2) {
        // 每个循环使用 2 个参数

        // replconf listening-port port
        if (!strcasecmp(c->argv[j]->ptr,"listening-port")) {

            long port;

            // 获取下一个项, 也就是端口号
            if ((getLongFromObjectOrReply(c,c->argv[j+1], &port,NULL) != C_OK))
                return;

            // 保存到对应的客户端的 slave_listening_port     
            c->slave_listening_port = port;
        } else if (!strcasecmp(c->argv[j]->ptr,"ip-address")) {
            // 省略
        } else if (!strcasecmp(c->argv[j]->ptr,"capa")) {
            // 省略
        } else if (!strcasecmp(c->argv[j]->ptr,"ack")) {
            // 省略
        }  else if (!strcasecmp(c->argv[j]->ptr,"getack")) {
            // 省略
        } else {
            // 响应错误
            addReplyErrorFormat(c,"Unrecognized REPLCONF option: %s", (char*)c->argv[j]->ptr);
            return;
        }
    }

    // 响应 OK 
    addReply(c,shared.ok);
}
```


可以看到主节点收到从节点发送过来的端口, 会保存到从节点客户端 client 的 slave_listening_port 字段。

收到主节点的响应后, 从节点同样是事件轮询触发 **syncWithMaster** 函数

```C
void syncWithMaster(aeEventLoop *el, int fd, void *privdata, int mask) {

    // 省略

    // REPL_STATE_RECEIVE_PORT 等待主节点响应发送 IP 请求的响应
    if (server.repl_state == REPL_STATE_RECEIVE_PORT) {

        err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);
        if (err[0] == '-') {
            serverLog(LL_NOTICE,"(Non critical) Master does not understand REPLCONF listening-port: %s", err);
        }
        sdsfree(err);
        // 状态变为 REPL_STATE_SEND_IP, 准备发送 IP 到主节点
        server.repl_state = REPL_STATE_SEND_IP;
    }
}
```

## 2.6 发送 IP 地址

发送端口和收到主节点对应的响应, 从节点的状态变为 REPL_STATE_SEND_IP (准备发送 IP 地址), 然后顺着函数的逻辑, 继续执行下去

```C
void syncWithMaster(aeEventLoop *el, int fd, void *privdata, int mask) {

    // 省略

    // REPL_STATE_RECEIVE_PORT 等待主节点响应发送 IP 请求的响应
    if (server.repl_state == REPL_STATE_RECEIVE_PORT) {
        // 省略
        // 状态变为 REPL_STATE_SEND_IP, 准备发送 IP 到主节点
        server.repl_state = REPL_STATE_SEND_IP;
    }

    // 没有配置宣布的 IP, slave_announce_ip 为空, 直接跳过发送 IP 的阶段
    if (server.repl_state == REPL_STATE_SEND_IP && server.slave_announce_ip == NULL) {
        // 进入下一个节点 准备发送从节点的发送能力
        server.repl_state = REPL_STATE_SEND_CAPA;
    }

    if (server.repl_state == REPL_STATE_SEND_IP) {
        err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,"REPLCONF", "ip-address",server.slave_announce_ip, NULL);
        if (err) 
            goto write_error;
        sdsfree(err);
        // 状态变为 REPL_STATE_RECEIVE_IP 切换为 等待主节点响应收到从节点的 IP 地址
        server.repl_state = REPL_STATE_RECEIVE_IP;
        return;
    }
}
```

从节点进入发送 IP 地址阶段时, 除了状态需要为 REPL_STATE_SEND_IP (准备发送 IP 地址阶段), 还必须有指定 slave_announce_ip, 从节点的 IP (对应配置文件的 slave-announce-ip),  
2 个条件都满足的情况下, 才会真正的进入发送 IP 地址, 否则直接进入下一阶段。

**主节点**收到从节点的发送端口请求 REPLCONF, 执行的逻辑如下

```C
void replconfCommand(client *c) {

    int j;

    // 参数需要是 2 的倍数
    if ((c->argc % 2) == 0) {
        addReply(c,shared.syntaxerr);
        return;
    }

    for (j = 1; j < c->argc; j+=2) {
        // 每个循环使用 2 个参数

        if (!strcasecmp(c->argv[j]->ptr,"listening-port")) {
            // 省略
        } else if (!strcasecmp(c->argv[j]->ptr,"ip-address")) {
            
            // replconf ip-address ip

            // 获取对应的从节点发送的 IP 
            sds ip = c->argv[j+1]->ptr;

            // IP 的长度判断
            if (sdslen(ip) < sizeof(c->slave_ip)) {
                // 保存到客户端的 client 的 slave_ip 属性
                memcpy(c->slave_ip,ip,sdslen(ip)+1);
            } else {
                // 错误提示
                addReplyErrorFormat(c,"REPLCONF ip-address provided by replica instance is too long: %zd bytes", sdslen(ip));
                return;
            }

        } else if (!strcasecmp(c->argv[j]->ptr,"capa")) {
            // 省略
        } else if (!strcasecmp(c->argv[j]->ptr,"ack")) {
            // 省略
        }  else if (!strcasecmp(c->argv[j]->ptr,"getack")) {
            // 省略
        } else {
            // 响应错误
            addReplyErrorFormat(c,"Unrecognized REPLCONF option: %s", (char*)c->argv[j]->ptr);
            return;
        }
    }
    
    // 响应 OK 
    addReply(c,shared.ok);
}
```

主节点收到从节点发送的 IP 地址, 会将其保存到从节点的客户端 client 的 slave_ip 字段。

收到主节点的响应后, 从节点同样是事件轮询触发 **syncWithMaster** 函数

```C
void syncWithMaster(aeEventLoop *el, int fd, void *privdata, int mask) {

    // 省略

    // 收到主节点对发送 IP 请求的响应
    if (server.repl_state == REPL_STATE_RECEIVE_IP) {

        err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);

        if (err[0] == '-') {
            serverLog(LL_NOTICE,"(Non critical) Master does not understand REPLCONF ip-address: %s", err);
        }
        sdsfree(err);

        // 状态变为等待发送发送能力状态
        server.repl_state = REPL_STATE_SEND_CAPA;
    }
}
```

## 2.7 发送同步能力 (数据同步的方式)

收到主节点响应的 IP 请求, 从节点的状态切换为了 REPL_STATE_SEND_CAPA, 当然如果从节点没有配置  slave-announce-ip, 也就不会有发送 IP 相关的操作, 直接过度到 REPL_STATE_SEND_CAPA。
然后继续下面的逻辑, 同样在 **syncWithMaster** 函数

```C

void syncWithMaster(aeEventLoop *el, int fd, void *privdata, int mask) {

    if (server.repl_state == REPL_STATE_SEND_CAPA) {

        // 发送从节点支持的发送能力到主节点
        err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,"REPLCONF", "capa","eof","capa","psync2",NULL);
        if (err) goto write_error;
        sdsfree(err);
        // 状态修改为 REPL_STATE_RECEIVE_CAPA, 等待主节点响应发送能力的应答
        server.repl_state = REPL_STATE_RECEIVE_CAPA;
        return;
    }
}
```

从节点发送过去的支持的 2 种发送能力
> 1. eof: 全量复制, 能够解析出 RDB 文件的 EOF 流格式, 用于无盘复制的方式中
> 2. psync2: 部分复制, 利用复制积压缓冲区等实现部分同步

**主节点**收到从节点的发送端口请求 REPLCONF, 执行的逻辑如下

```C
void replconfCommand(client *c) {

    int j;

    // 参数需要是 2 的倍数
    if ((c->argc % 2) == 0) {
        addReply(c,shared.syntaxerr);
        return;
    }

    for (j = 1; j < c->argc; j+=2) {
        // 每个循环使用 2 个参数

        if (!strcasecmp(c->argv[j]->ptr,"listening-port")) {
            // 省略
        } else if (!strcasecmp(c->argv[j]->ptr,"ip-address")) {
            // 省略
        } else if (!strcasecmp(c->argv[j]->ptr,"capa")) {

            if (!strcasecmp(c->argv[j+1]->ptr,"eof"))
                // SLAVE_CAPA_EOF = 1
                c->slave_capa |= SLAVE_CAPA_EOF;
            else if (!strcasecmp(c->argv[j+1]->ptr,"psync2"))
                // SLAVE_CAPA_PSYNC2 = 2 
                c->slave_capa |= SLAVE_CAPA_PSYNC2;

            // 如果不支持的能力, 不做处理
        } else if (!strcasecmp(c->argv[j]->ptr,"ack")) {
            // 省略
        }  else if (!strcasecmp(c->argv[j]->ptr,"getack")) {
            // 省略
        } else {
            // 响应错误
            addReplyErrorFormat(c,"Unrecognized REPLCONF option: %s", (char*)c->argv[j]->ptr);
            return;
        }
    }
    
    // 响应 OK 
    addReply(c,shared.ok);
}
```

收到从节点发送过来的支持的发送的同步能力后, 将其放到从节点客户端的 slave_capa 中。

从节点收到主节点的响应后, 从节点同样是事件轮询触发 **syncWithMaster** 函数

```C
void syncWithMaster(aeEventLoop *el, int fd, void *privdata, int mask) {

    // 省略

    if (server.repl_state == REPL_STATE_RECEIVE_CAPA) {
        err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);

        if (err[0] == '-') {
            serverLog(LL_NOTICE,"(Non critical) Master does not understand REPLCONF capa: %s", err);
        }
        sdsfree(err);

        // 向主节点发送 psync 命令, 请求全量复制
        server.repl_state = REPL_STATE_SEND_PSYNC;
    }
    // 省略
}
```

到了这一步, 相关的配置发送基本完成了, 下一步就是真正的同步复制的开始了

## 2.8 发送 PSYNC 命令

从节点收到了主节点对其同步能力的响应后, 这是会发送一个 psync 的命令给主节点, 这个请求就是同步复制的真正开始了

```C
void syncWithMaster(aeEventLoop *el, int fd, void *privdata, int mask) {

    if (server.repl_state == REPL_STATE_SEND_PSYNC) {

        if (slaveTryPartialResynchronization(fd,0) == PSYNC_WRITE_ERROR) {
            err = sdsnew("Write error sending the PSYNC command.");
            goto write_error;
        }

        // 切换状态为 REPL_STATE_RECEIVE_PSYNC
        server.repl_state = REPL_STATE_RECEIVE_PSYNC;
        return;
    }

}
```

