# 2 主从复制 - 源码

## 2.1 主从节点建立连接

Redis 主从节点建立连接的 3 种方式, 本质都是从节点执行 **slaveof** 命令, 这个命令执行的方法为 **replicaofCommand**。

```C
void replicaofCommand(client *c) {

    // 开启了集群功能, 直接返回, 集群模式不允许执行 slaveof 
    if (server.cluster_enabled) {
        addReplyError(c,"REPLICAOF not allowed in cluster mode.");
        return;
    }
    
    // 第一参数为 no, 第二个参数为 one
    // slaveof no one, 可以让从节点和主节点断开连接, 停止主从复制 
    if (!strcasecmp(c->argv[1]->ptr,"no") && !strcasecmp(c->argv[2]->ptr,"one")) {

        // 如果保存了主节点IP
        if (server.masterhost) {
            
            // 取消复制操作，同时设置当前节点为主节点
            replicationUnsetMaster();

            // 获取 client 的每种信息，并以 sds 形式返回，并打印到日志中
            sds client = catClientInfoString(sdsempty(),c);
            serverLog(LL_NOTICE,"MASTER MODE enabled (user request from '%s')", client);
            sdsfree(client);
        }

    } else {

        long port;

        // 当前的客户端的标识为从节点标识
        // 本身是一个从节点了, 无法在执行 salveof ip 端口
        if (c->flags & CLIENT_SLAVE) {

            addReplyError(c, "Command is not valid when client is a replica.");
            return;
        }

        // 从入参中获取端口
        if ((getLongFromObjectOrReply(c, c->argv[2], &port, NULL) != C_OK))
            return;

        // 已经有主节点了, 同时主节点的的 host 和 ip 和入参的相同
        if (server.masterhost && !strcasecmp(server.masterhost,c->argv[1]->ptr) && server.masterport == port) {    

            serverLog(LL_NOTICE,"REPLICAOF would result into synchronization with the master we are already connected with. No operation performed.");
            addReplySds(c,sdsnew("+OK Already connected to specified master\r\n"));
            return;
        }

        // 设置主节点的信息
        replicationSetMaster(c->argv[1]->ptr, port);

        sds client = catClientInfoString(sdsempty(),c);
        serverLog(LL_NOTICE,"REPLICAOF %s:%d enabled (user request from '%s')", server.masterhost, server.masterport, client);
        sdsfree(client);
    }

    addReply(c,shared.ok);
}

void replicationUnsetMaster(void) {

    if (server.masterhost == NULL) 
        return;

    sdsfree(server.masterhost);
    server.masterhost = NULL;

    shiftReplicationId();
    if (server.master) 
        freeClient(server.master);

    replicationDiscardCachedMaster();
    cancelReplicationHandshake();

    disconnectSlaves();
    server.repl_state = REPL_STATE_NONE;

    server.slaveseldb = -1;

    server.repl_no_slaves_since = server.unixtime;
}

void shiftReplicationId(void) {

    memcpy(server.replid2,server.replid,sizeof(server.replid));

    server.second_replid_offset = server.master_repl_offset+1;
    changeReplicationId();
    serverLog(LL_WARNING,"Setting secondary replication ID to %s, valid up to offset: %lld. New replication ID is %s", server.replid2, server.second_replid_offset, server.replid);
}

void changeReplicationId(void) {
    getRandomHexChars(server.replid,CONFIG_RUN_ID_SIZE);
    server.replid[CONFIG_RUN_ID_SIZE] = '\0';
}
```