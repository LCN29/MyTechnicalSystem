# 2 主从复制 - 源码

## 2.1 主从节点建立连接

Redis 主从节点建立连接的 3 种方式, 本质都是从节点执行 **slaveof** 命令, 和父节点建立初步的关联关系。   
这个命令执行的方法为 **replicaofCommand**。

```C
void replicaofCommand(client *c) {

    // 开启了集群功能, 直接返回, 集群模式不允许执行 slaveof 
    if (server.cluster_enabled) {
        addReplyError(c,"REPLICAOF not allowed in cluster mode.");
        return;
    }
    
    // 第一参数为 no, 第二个参数为 one
    // slaveof no one, 可以让从节点和主节点断开连接, 停止主从复制 
    if (!strcasecmp(c->argv[1]->ptr,"no") && !strcasecmp(c->argv[2]->ptr,"one")) {

        // 如果保存了主节点IP
        if (server.masterhost) {
            
            // 取消复制操作, 同时设置当前节点为主节点
            replicationUnsetMaster();

            // 获取 client 的每种信息, 并以 sds 形式返回, 并打印到日志中
            sds client = catClientInfoString(sdsempty(),c);
            serverLog(LL_NOTICE,"MASTER MODE enabled (user request from '%s')", client);
            sdsfree(client);
        }

    } else {

        long port;

        // 当前的客户端的标识为从节点标识
        // 本身是一个从节点了, 无法在执行 salveof ip 端口
        if (c->flags & CLIENT_SLAVE) {

            addReplyError(c, "Command is not valid when client is a replica.");
            return;
        }

        // 从入参中获取端口
        if ((getLongFromObjectOrReply(c, c->argv[2], &port, NULL) != C_OK))
            return;

        // 已经有主节点了, 同时主节点的的 host 和 ip 和入参的相同
        if (server.masterhost && !strcasecmp(server.masterhost,c->argv[1]->ptr) && server.masterport == port) {    

            serverLog(LL_NOTICE,"REPLICAOF would result into synchronization with the master we are already connected with. No operation performed.");
            addReplySds(c,sdsnew("+OK Already connected to specified master\r\n"));
            return;
        }

        // 设置主节点的信息
        replicationSetMaster(c->argv[1]->ptr, port);

        sds client = catClientInfoString(sdsempty(),c);
        serverLog(LL_NOTICE,"REPLICAOF %s:%d enabled (user request from '%s')", server.masterhost, server.masterport, client);
        sdsfree(client);
    }

    addReply(c,shared.ok);
}

```

释放之前被阻塞的客户端，这些通常是使用 Redis 阻塞列表而被阻塞的客户端。
断开当前实例的所有slave。
清除缓存的master信息。
释放 backlog，backlog 是堆积环形缓冲区。
取消正在进行的握手过程。
将当前实例的复制状态设置为 REPL_STATE_CONNECT

执行完上的逻辑后, salveof 就结束的, 但是整个的主从复制还没有开始, 接下来的步骤则是由定时函数 serverCron 定时的调用

```C
int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {

    // 省略

    // 定时 1 秒执行一次
    run_with_period(1000) replicationCron();

    // 省略
}
```

```C
void replicationCron(void) {


    static long long replication_cron_loops = 0;

    // 非阻塞连接超时判断, 下面 3 个条件都满足, 取消握手状态
    // 1. 有主节点配置
    // 2. 当前的状态为 REPL_STATE_CONNECTING (真正建立连接中) 或者处于握手阶段
    // 3. 当前的时间 - 上次读取数据开始的时间 > 配置的超时时间
    if (server.masterhost && (server.repl_state == REPL_STATE_CONNECTING || slaveIsInHandshakeState()) && (time(NULL)-server.repl_transfer_lastio) > server.repl_timeout) {
        serverLog(LL_WARNING,"Timeout connecting to the MASTER...");
        // 取消握手
        cancelReplicationHandshake();
    }

    // 批量传输 I/O 超时, 下面 3 个条件都满足, 取消握手状态
    // 1. 有主节点配置
    // 2. 当前的状态为 REPL_STATE_CONNECTING (正在接收从主节点发送过来的 RDB 文件)
    // 3. 当前的时间 - 上次读取数据开始的时间 > 配置的超时时间
    if (server.masterhost && server.repl_state == REPL_STATE_TRANSFER && (time(NULL)-server.repl_transfer_lastio) > server.repl_timeout) {
        serverLog(LL_WARNING,"Timeout receiving bulk data from MASTER... If the problem persists try to set the 'repl-timeout' parameter in redis.conf to a larger value.");
        cancelReplicationHandshake();
    }

    // 主从节点已经建立连接了, 但是主节点的心跳超时, 每隔 10 s，主节点从节点发送 PING 命令，从节点每隔 1s, 向主节点报告复制偏移量
    // 1. 有主节点配置
    // 2. 当前的状态为 REPL_STATE_CONNECTED (主从节点已经存于连接状态)
    // 3. 当前的时间 - 主节点的上次心跳时间 > 配置的超时时间
    if (server.masterhost && server.repl_state == REPL_STATE_CONNECTED && (time(NULL)-server.master->lastinteraction) > server.repl_timeout) {
        serverLog(LL_WARNING,"MASTER timeout: no data nor PING received...");
        // 释放主节点
        freeClient(server.master);
    }

    // 当前的状态为 REPL_STATE_CONNECT (开启了主从复制, 但是还没连接上主节点), 顺利执行了 salveof 后, 从节点的默认状态
    if (server.repl_state == REPL_STATE_CONNECT) {
        serverLog(LL_NOTICE,"Connecting to MASTER %s:%d", server.masterhost, server.masterport);

        // 连接主节点
        if (connectWithMaster() == C_OK) {
            serverLog(LL_NOTICE,"MASTER <-> REPLICA sync started");
        }
    }

    // 有主节点配置, 同时主节点的标识不是 CLIENT_PRE_PSYNC, 发送 ack 到主节点
    if (server.masterhost && server.master && !(server.master->flags & CLIENT_PRE_PSYNC))
        replicationSendAck();

    // 如果服务器有从节点, 需要定期发送 PING 命令
    // 所以从节点可以实现一个显式的 timeout 去判断和主节点的超时连接，即使 TCP 连接不会中断，也能察觉一个连接的重新连接, 上面的超时判断就是基于这个操作

    listIter li;
    listNode *ln;
    robj *ping_argv[1];

    
    // 这个是集群 cluster 的功能逻辑, 可以跳过
    // replication_cron_loops 方法开头声明的变量, 初始为 0 , repl_ping_slave_period 主节点 PING 的间隔, 默认 10s 
    if ((replication_cron_loops % server.repl_ping_slave_period) == 0 && listLength(server.slaves)) {
        
        // 开启了集群功能
        // 当前处于手动故障转移中, (mf_end, mf_end 为 0, 表示没有正在进行手动故障转移, 大于 0 了, 表示进行中)
        // 当前所有的客户端 (从节点和 阻塞客户端不算) 都是处于暂停状态
        int manual_failover_in_progress = server.cluster_enabled && server.cluster->mf_end && clientsArePaused();

        if (!manual_failover_in_progress) {

            // 创建出一个 PING
            ping_argv[0] = createStringObject("PING",4);
            // 发送 PING 到从节点
            replicationFeedSlaves(server.slaves, server.slaveseldb, ping_argv, 1);
            // 减少引用次数
            decrRefCount(ping_argv[0]);
        }
    }

    listRewind(server.slaves,&li);
    while((ln = listNext(&li))) {
        
        client *slave = ln->value;

        // 如果从节点的复制状态处于等待 RDB 文件被主节点创建的状态
        // 从节点的复制状态处于等待 RDB 文件创建节点 并且 RDB 文件的类型不是无盘传输
        int is_presync = (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_START || (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_END && server.rdb_child_type != RDB_CHILD_TYPE_SOCKET));

        if (is_presync) {
            // 发送一个'\n'，保持活跃主从连接的状态
            if (write(slave->fd, "\n", 1) == -1) {
            }
        }
    }

    // 断开所有超时的客户端
    if (listLength(server.slaves)) {
        listIter li;
        listNode *ln;

        listRewind(server.slaves,&li);
        while((ln = listNext(&li))) {
            client *slave = ln->value;

            if (slave->replstate != SLAVE_STATE_ONLINE) continue;

            if (slave->flags & CLIENT_PRE_PSYNC) continue;

            // 当前时间 - 客户端上次 ack 的时间 > 配置的超时时间
            if ((server.unixtime - slave->repl_ack_time) > server.repl_timeout) {
                serverLog(LL_WARNING, "Disconnecting timedout replica: %s",replicationGetSlaveName(slave));
                freeClient(slave);
            }
        }    
    }

    // 没有从节点
    // 缓冲区不为空
    // 没有配置的主节点
    if (listLength(server.slaves) == 0 && server.repl_backlog_time_limit && server.repl_backlog && server.masterhost == NULL) {

        // 计算出当前时间到没有从节点的时间
        time_t idle = server.unixtime - server.repl_no_slaves_since;

        //超过 repl_backlog_time_limit 限制则释放 backlog
        if (idle > server.repl_backlog_time_limit) {

            //  重新生成一个 runId, 并赋值到 server.replid
            changeReplicationId();
            // 清除 replid2 的值
            clearReplicationId2();
            // 释放 repl_backlog 占的内存, 同时置为空
            freeReplicationBacklog();
            serverLog(LL_NOTICE, "Replication backlog freed after %d seconds without connected replicas.", (int) server.repl_backlog_time_limit);
        }
    }

    // 没有从节点
    // aof 功能关闭
    // 复制脚本缓存有数据
    if (listLength(server.slaves) == 0 && server.aof_state == AOF_OFF && listLength(server.repl_scriptcache_fifo) != 0) {
        // 清空复制脚本缓存
        replicationScriptCacheFlush();
    }

    // 没有后台进程在 RDB 或者 AOF
    if (server.rdb_child_pid == -1 && server.aof_child_pid == -1) {

        time_t idle, max_idle = 0;
        int slaves_waiting = 0;
        int mincapa = -1;
        listNode *ln;
        listIter li;

        listRewind(server.slaves,&li);
        // 遍历所有的从节点，记录等待 BGSAVE 的开始的从节点个数
        while((ln = listNext(&li))) {

            client *slave = ln->value;
            if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_START) {

                // 空闲的时间, 当前的时间 - 当前从节点上次心跳的时间
                idle = server.unixtime - slave->lastinteraction;

                // 最大空闲时间
                if (idle > max_idle) 
                    max_idle = idle;
                
                slaves_waiting++;

                // slave_capa 从节点支持的能力 0：什么都不支持 1：支持通过解析 RDB 文件流 2：支持 PSYNC2 协议
                // 获取所有从节点都支持的最小能力
                mincapa = (mincapa == -1) ? slave->slave_capa : (mincapa & slave->slave_capa);
            }

        }

        // 存在等待 bgsave 的从节点 
        // 服务器不支持无盘复制 或 最大空闲时间超过无盘复制的延迟时限
        if (slaves_waiting && (!server.repl_diskless_sync || max_idle > server.repl_diskless_sync_delay)) {
            // 开启后台的复制
            startBgsaveForReplication(mincapa);
        }
    }

    // 更新延迟小于 min-slaves-max-lag 的从服务器数量
    refreshGoodSlavesCount();
    replication_cron_loops++;
}
```
