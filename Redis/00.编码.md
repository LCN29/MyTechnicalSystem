# Redis 编码

## Redis 数据结构

> 1. strings 
> 2. hashes
> 3. lists
> 4. sets
> 5. sorted sets
> 6. bitmaps 位图
> 7. hyperloglogs 一种用于计算唯一事物的概率数据结构, 大数据量的基数统计 {1,2,1,4,5} 
> 8. geospatial indexes 一种用于存储地理位置的数据结构
> 9. streams 类似于消息队列的完善实现, 死信, 消费组, 消息转移等

## Redis 编码

strings, hashes 等 Redis 对外的数据结构。

这些数据结构, 在 Redis 内部, 会根据存储的内容和场景选择不同的实现，这些实现在 Reids 中叫做 内部编码。

有点类似于 接口 和 具体的实现类的关系。
在 Redis 中 总共有 12 种不同的编码方式, 基本 5 种常用的数据结构都可以由 2 种以上的编码进行实现。

OBJ_ENCODING_RAW
OBJ_ENCODING_INT
OBJ_ENCODING_HT
OBJ_ENCODING_ZIPMAP
OBJ_ENCODING_LINKEDLIST
OBJ_ENCODING_ZIPLIST
OBJ_ENCODING_INTSET
OBJ_ENCODING_SKIPLIST
OBJ_ENCODING_EMBSTR
OBJ_ENCODING_QUICKLIST
OBJ_ENCODING_STREAM
OBJ_ENCODING_LISTPACK

strings -> int embstr, raw
hashs -> ziplist, hashtable
list -> 早期 ziplist, linkedlist 3.2 版本后 quicklist
set -> intset, hashtable
sorted sets -> ziplist, skiplist


## Sds

### C语言 char[]

C 语言本身没有字符串类型 (只能用字符数组 char[] 实现)。

在 C 语言中通过 char[] 数组实现字符串的功能, 会涉及到的一些问题

> 1. C字符串不记录自身长度和空闲空间，容易造成缓冲区溢出
> 2. 字符串长度变化了，需要重新分配内存
> 3. 需要获取到长度, 就行进行遍历 O(n), C 语言的数组没有提供 len 或者 len() 方法直接获取长度
> 4. C语言中通过 **\0** 代表字符串的结束, 存储其他的格式的内存，二进制表示的音频图片等, 可能会出现问题，也就是二进制不安全

struct sds {

    int len;// buf 中已占用字节数, 可以看做是使用的长度
    int free;// buf 中剩余可用字节数, 可以看做是剩余的长度
    char buf[];// 数据数组
}

3.2 版本之前 redis 对字符串的实现

空间预分配和惰性空间释放


Redis 是一款基于内存的数据库, 那么 内存是极其重要的。那么上面的 sds 从内存上考虑有什么问题吗?

表示长度和剩余长度的 len / free, 用的是 int 修饰的, 最大值为 2147483647, 正常情况下字符串的长度会超过这个吗？ 应该不会, 那么是否可以
用 2 个字节的 uint16_t (Java 层面的 short, 最大值为 32768) 进行存储呢?

既然可以用 2 个字节, 那么 1 个字节呢, 不足一个字节的呢？

所以在 Redis 3.2 后, 对 sds 更进一步的细化, 分成了 5 种实现, 基于 1, 2, 4, 8 个字节的实现 + 基于 5 位的实现, 同时在结构体内追加了一个 1 个字节的 flags 表示这个结构体的类型

```c
struct __attribute__((__packed__))sdshdr8 {
    uint8_t len;
    uint8_t alloc;
    unsigned char flags;
    char buf[];
}

struct __attribute__((__packed__))sdshdr16 {

    uint16_t len;
    uint16_t alloc;
    unsigned char flags;
    char buf[];

}

struct __attribute__((__packed__))sdshdr32 {

    uint32_t len;
    uint32_t alloc;
    unsigned char flags;
    char buf[];

}

struct __attribute__((__packed__))sdshdr64 {

    uint64_t len;
    uint64_t alloc;
    unsigned char flags;
    char buf[];

}

// 几乎不会使用到, 外部使用时, 即使一个很小的字符串也会先转换为 8 位存储
// 只在内部源码中别使用到
struct __attribute__((__packed__))sdshdr5 {

    /** flags 只有 5 种情况， 3 位存储够了 */
    /** 把长度和类型放在一起 */
    /** 低3位存储类型, 高5位存储长度 */
    unsigned char flags; 

    char buf[];
}
```

平时在使用字符串时, 字符串的长度一般会多长呢?  超过 32768 的可能大吗？


## String

embstr raw 本质就是 sds, 不同的是 sds 和 redisObject 内存的组织方式。


Redis k-v 中 同一个 k 对应着一个 value,



```java
typedef struct dictEntry {

    /** void 可以指向任何类型, 指向 k */
    void* key;

    union {
        /** uint64_t、int64_t 或 double 类型时，就不再需要额外的存储，这有利于减少内存碎片 */
        void *val;
        uint64_t u64;
        int64_t s64;
    } v;

    // 链往后继节点, 用于解决 hash 冲突
    struct dictEntry *next;
}
```

val 指向的是一个 redisObject 

```C
typedef struct redisObject {
    
    /** 数据类型: OBJ_STRING, OBJ_LIST, OBJ_HASH, OBJ_SET, OBJ_ZSET */
    unsigned type:4;

    /** 底层存储的数据结构编码 */
    unsigned encoding:4;

    /** 与内存回收有关, 对象最后一次被程序访问的时间或者被返回的次数等 */
    unsigned lru:LRU_BITS;

    /** 被引用的次数, 当 refcount 为 0 的时候, 表示该对象已经不被任何对象引用, 则可以进行垃圾回收了 */
    int refcount;

    /** 指向对象实际的数据结构, 也就是真正的值 */
    void *ptr;

} robj;
```

raw 和 embstr *prt 都是指向一个 sds.
所以在 embstr 和 raw 本质都是一个 sds.

那么 2 者之间的唯一的区别在于 redisObject 和 sds 这 2 个对象之间如何进行内存分配。

常用的内存分配器为 jemalloc、tcmalloc

这 2 个 的共同特点就是在进行内容分配时，都是按照 2 的 n 次方进行分配的, 既 2,4,8 的方式进行分配。

在对 value 进行分配时, 需要分配的有 2 个， redisObject + sds

从上面可以知道 一个 redisObject 最少需要  (4 + 4 + 24) + 4 + 8 = 16 个字节

而一个 sds 最少需要 3 个字节 (sds5 会被转换为 sds8 进行分配) 

那么需要分配一个 string 的 value 至少需要 19 个字节， 也就是需要分配 32 个字节, 如果存储的字符串再大一些， 那么就需要分配到 64 个字节等。
那么基于这个机制，将 redisObject 和 sds 在分配内存时，一起分配, 基于这种情况分配的 sds 就是 embstr, RedisObject和SDS 内存地址是连续的
那么 raw, 就是则是通过 2 次内存分配， redisobject 和 sds 之间的内存地址可能是不连续的。



embstr　形式，可以存储最大字符串长度是 44 字节

SDS 已经变大，取得大的连续内存得不偿失


if (len < 20 && string2l(char)) {

    

}



int embstr raw

int -> long

embstr raw 本质就是 sds, 不同的时， 在 Redis 声明 value 的对象时, value 对象 和 sds 之间一起分配内存的


https://blog.csdn.net/u013099854/article/details/115399466

https://www.cnblogs.com/sunchong/p/11924295.html
https://www.cnblogs.com/yinbiao/p/10740212.html






# Redis 的字符串的编码

## Redis 数据编码

> 1. strings 
> 2. hashes
> 3. lists
> 4. sets
> 5. sorted sets

高版本 Redis 中, 提供了 4 种新的 4 的结构
> 1. bitmaps 位图
> 2. hyperloglogs 一种用于计算唯一事物的概率数据结构, 大数据量的基数统计 {1,2,1,4,5} 
> 3. geospatial indexes 一种用于存储地理位置的数据结构 {经度, 纬度, 名称}
> 4. streams 类似于消息队列的完善实现, 死信, 消费组, 消息转移等


其实, strings, hashes， list 这些都是 Redis 对外的数据结构。  

这些数据结构, 在 Redis 内部, 会根据存储的内容等情况, 选择不同的实现，这些实现在 Reids 中叫做内部编码。
有点类似于 接口 和 具体的实现类的关系。


Reids 中 String 类型的数据, 在实现上有 3 种 编码方式

> 1. int (OBJ_ENCODING_INT), 存储 8 个字节的长整型 (long, 2^64 - 1)
> 2. embstr (OBJ_ENCODING_EMBSTR ), 存储小于 44 个字节的字符串
> 3. raw (OBJ_ENCODING_RAW), 存储大于 44 个字节的字符串 (3.2 版本之前是 39 字节)


embstr 和 raw 虽然是 2 种不同的编码, 但是内部的实现都是一个字符串。


## Redis 中的字符串实现


Redis 是基于 C 语言实现的, 而在 C 中是没有字符串的类型的, 所以要实现字符串的效果需要借助 char[] 数组的。


直接使用 char[] 时, 在使用时有一些问题
> 1. 字符串长度变化了，需要重新分配内存
> 2. 需要获取到长度, 就需要进行遍历, 或者通过内存进行计算等, C 语言的数组没有提供 len 属性或者 len() 方法直接获取长度
> 3. C 语言字符串不记录自身长度和空闲空间，容易造成缓冲区溢出
> 4. C 语言中通过 **\0** 代表字符串的结束, 会在字符串结束的位置追加一个 "\0" 表示字符串, 比如 "one" 需要 4 个 char 进行存储 "one\0", 
这个特点在存储其他的格式的内存，二进制表示的音频图片等, 可能会出现问题，也就是二进制不安全

基于这些问题，Redis 内部自定义了一个 sds (Simple Dynamic String) 的结构体, 来代替 char[]，达到字符串的效果。

其实现有点像 Java 中的 ArrayList, 采用 **预分配冗余空间** 的方式来减少内存的频繁分配, 同时在达到内存的上限时, 自动扩容等。

当字符串长度小于 1M 时, 扩容都是加倍现有的空间, 如果超过 1M, 扩容时一次只会多扩 1M 的空间 (字符串最大长度为 512M) 。

在早期的 Redis 中的实现如下

```C
struct sds {

    /** buf 中已经使用的字节 */
    int len; 

    /** buf 中剩余多少字节 */
    int free;

    /** 存储数据的数组 */
    char buf[];
}
```

本质还是一个 char[] 数组, 但是多了 2 个字段

由于有长度统计变量 len 的存在，读写字符串时不依赖“\0”终止 符，保证了二进制安全
同时有借助 len 和 free 可以做到空间预分配和惰性空间释放, 同时更安全的使用数组
buf[] 是一个柔性数组, 在内存中查找性能影响不大(不需要额外通过指针找到字符串的位置)

3.2 版本之前 redis 对字符串的实现? 

Redis 是一款基于内存的数据库, 那么内存是极其重要的, 结合平时使用字符串的长度和内存的使用上考虑有什么问题吗?

 len / free, 用的是 int 修饰的, 最大值为 2147483647, 正常情况下字符串的长度会超过这个吗？ 应该不会, 那么是否可以
用 2 个字节的 uint16_t (Java 层面的 short, 最大值为 32768) 进行存储呢?


既然可以用 2 个字节, 那么 1 个字节呢, 不足一个字节的呢？

所以在 Redis 3.2 后, 对 sds 更进一步的细化, 分成了 5 种实现, 基于 1, 2, 4, 8 个字节的实现 + 基于 5 位的实现, 同时在结构体内追加了一个 1 个字节的 flags 表示这个结构体的类型




/* Note: sdshdr5 is never used, we just access the flags byte directly.
 * However is here to document the layout of type 5 SDS strings. */


键不更新而值会更新，故键用尽可能小的结构存

长度小于 32 的键值对，key 的底层是 sdshdr5


SDS 不用担心内存溢出问题, 如果需要会对 SDS 进行扩容。通过"空间预分配" (sdsMakeRoomFor 方法) 和 "惰性空间释放", 防止多次重分配内存。
同时在 SDS 中存储了 len 变量, 存储当前字符串的长度, 那么可以直接通过 len 获取到字符串的长度, 变为了 O(1)。同时字符串的结束可以完全通过 len 进行判断, 而忽略 C 语言中的遇 '\0' 结束的特点。

综上: SDS 具备了**可动态扩展内存**, **二进制安全**, **快速遍历字符串**和**与传统的 C 语言字符串类型兼容**的特点。




## String 的编码


embstr 和 raw 本质都是 sds, 不同的是 sds 和对 value 进行包装的 redisObject 2 者在内存的组织方式。


当向 Redis 中存入一个 k 和 v。
这个 k 和 v，会被组织成一个 dictEntry, dictEntry 中有 2 指针， 一个指向了代表 key 的 sds, 一个指向了包装着 value 的 RedisObject,

```C
typedef struct redisObject {
    
    /** 数据类型: OBJ_STRING, OBJ_LIST, OBJ_HASH, OBJ_SET, OBJ_ZSET */
    unsigned type:4;

    /** 底层存储的数据结构编码 */
    unsigned encoding:4;

    /** 与内存回收有关, 对象最后一次被程序访问的时间或者被返回的次数等 */
    unsigned lru:LRU_BITS;

    /** 被引用的次数, 当 refcount 为 0 的时候, 表示该对象已经不被任何对象引用, 则可以进行垃圾回收了 */
    int refcount;

    /** 指向对象实际的数据结构, 也就是真正的值 */
    void *ptr;

} robj;
```

raw 和 embstr *prt 都是指向一个 sds.  embstr 和 raw 本质都是一个 sds. 而 embstr 指定是 redisObject 和代表存储数据的 sds 在进行内存分配是一次性分配，连续在一起的。
而 raw 则是 redisObject 和 sds 分成 2 次分配内存，可能是在 2 个不同的内存块

常用的内存分配器为 jemalloc、tcmalloc
这 2 个 的共同特点就是在进行内容分配时，都是按照 2 的 n 次方进行分配的, 既 2,4,8 的方式进行分配。


在对 value 进行分配时, 需要分配的有 2 个， redisObject + sds

从上面可以知道 一个 redisObject 最少需要  (4 + 4 + 24) + 4 + 8 = 16 个字节

而一个 sds 最少需要 3 个字节 (sds5 会被转换为 sds8 进行分配) 

那么需要分配一个 string 的 value 至少需要 19 个字节， 在分配时最少需要分配 32 个字节, 如果存储的字符串再大一些， 那么就需要分配到 64 个字节等。

那么基于这个机制，可以将 redisObject 和 sds 在分配内存时，一起分配, 基于这种情况分配的话 RedisObject和SDS 内存地址是连续的
这种 redisObject 和 sds 在一起的就是 embstr
而  分成 2 次分配，可能不连续的就是 raw


查找更快

embstr 和 raw 的分界线?

embstr 和 raw 存储小于 44 个字节的字符串

44 也是根据上面的进行分配的

Redis 以 64 字节为分界线, 一次分配大于这个临界值的内存, 认为是一个得不偿失的行为。
所以以 64 字节为界限, 在还能使用的内存我 44 字节, 也就是

### int 

很简单，数字，完全可以不用 char[] 存储，直接用一个 long 进行存储即可了， 所以 在 redis 中 int 编码就是一个 long 


而在 reids 中 对应 long 这个编码的实现和 Java 的 long 类型，内部也是先声明了一个缓存池，缓存的范围为 0 - 9999 1 万个数。

在没有配置最大内存或者配置的内存过期策略为 MAXMEMORY_FLAG_NO_SHARED_INTEGERS 的情况下，

当 value 在这个范围内, 直接使用缓存的，而不是直接创建

超过这个范围，才进行内存的分配


```java

// 获取传入的内容的长度
int len = sdslen(content);

Long value;
// 整数, long 最大值为 20 位
if (len <= 20 && string2l(content, value)) {
    
    // 在没有设置最大内存的情况下 或者设置了内存过期策略为 MAXMEMORY_FLAG_NO_SHARED_INTEGERS  的情况下
    if (maxmemory == 0 || maxmemory.policy == MAXMEMORY_FLAG_NO_SHARED_INTEGERS) {
        if  ( value > 0 && value < Long.MAX_VALUE)
        return shared.integers[value];
    } else {
        redisObject o = new redisObject();
        o.ptr = value;
        return 0;
    }
}

// TODO 字符串处理
```


### 2.2.1 int 和 embstr 什么时候转化为 raw

当 int 数据不再是整数或大小超过了 long 的范围 (2^63-1 = 9223372036854775807) 时, 自动转化为 embstr (小于等于 44 个字节) / raw (大于 44 个字节)

在 Redis 中, embstr 是被设置为只读的, 当对 embstr 字符串进行修改 (例如: append), 无论 embstr 是否超过了 44 个字节, 都会变为 raw.

### 2.2.2 embstr 和 raw 的区别

embstr 的使用只分配一次内存空间 (因为 RedisObject 和 SDS 是连续的), 而 raw 需要分配两次内存空间 (分别为 RedisObject 和 SDS 分配空间)。

因此, 与 raw 相比, embstr 的好处在于创建时少分配一次空间, 删除时少释放一次空间, 以及对象的所有数据连在一起, 寻找方便。

而 embstr 的坏处也很明显, 如果字符串的长度增加需要重新分配内存时, 整个 RedisObject 和 SDS 都需要重新分配空间, 因此 Redis 中的 embstr 实现为只读。

### 2.2.3 当长度小于阈值时, 会还原吗

Redis 内部编码的转换, 都符合以下规律: 编码转换在 Redis 写入数据时完成, 且转换过程不可逆, 只能从小内存编码向大内存编码转换。但是可以通过重新 set, 可以重新分配。

### 2.2.4 为什么要对底层的数据结构进行一层包装呢

通过封装, 可以根据对象的类型动态地选择存储结构和可以使用的命令, 实现节省空间和优化查询速度



