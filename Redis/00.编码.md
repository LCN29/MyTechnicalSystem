# Redis 编码


## Redis 数据结构

> 1. strings 
> 2. hashes
> 3. lists
> 4. sets
> 5. sorted sets
> 6. bitmaps 位图
> 7. hyperloglogs 一种用于计算唯一事物的概率数据结构, 大数据量的基数统计 {1,2,1,4,5} 
> 8. geospatial indexes 一种用于存储地理位置的数据结构
> 9. streams 类似于消息队列的完善实现, 死信, 消费组, 消息转移等

## Redis 编码

strings, hashes 等 Redis 对外的数据结构。

这些数据结构, 在 Redis 内部, 会根据存储的内容和场景选择不同的实现，这些实现在 Reids 中叫做 内部编码。

有点类似于 接口 和 具体的实现类的关系。
在 Redis 中 总共有 12 种不同的编码方式, 基本 5 种常用的数据结构都可以由 2 种以上的编码进行实现。

OBJ_ENCODING_RAW
OBJ_ENCODING_INT
OBJ_ENCODING_HT
OBJ_ENCODING_ZIPMAP
OBJ_ENCODING_LINKEDLIST
OBJ_ENCODING_ZIPLIST
OBJ_ENCODING_INTSET
OBJ_ENCODING_SKIPLIST
OBJ_ENCODING_EMBSTR
OBJ_ENCODING_QUICKLIST
OBJ_ENCODING_STREAM
OBJ_ENCODING_LISTPACK

strings -> int embstr, raw
hashs -> ziplist, hashtable
list -> 早期 ziplist, linkedlist 3.2 版本后 quicklist
set -> intset, hashtable
sorted sets -> ziplist, skiplist


## Sds

### C语言 char[]

C 语言本身没有字符串类型 (只能用字符数组 char[] 实现)。

在 C 语言中通过 char[] 数组实现字符串的功能, 会涉及到的一些问题

> 1. C字符串不记录自身长度和空闲空间，容易造成缓冲区溢出
> 2. 字符串长度变化了，需要重新分配内存
> 3. 需要获取到长度, 就行进行遍历 O(n), C 语言的数组没有提供 len 或者 len() 方法直接获取长度
> 4. C语言中通过 **\0** 代表字符串的结束, 存储其他的格式的内存，二进制表示的音频图片等, 可能会出现问题，也就是二进制不安全

struct sds {

    int len;// buf 中已占用字节数, 可以看做是使用的长度
    int free;// buf 中剩余可用字节数, 可以看做是剩余的长度
    char buf[];// 数据数组
}

3.2 版本之前 redis 对字符串的实现

空间预分配和惰性空间释放


Redis 是一款基于内存的数据库, 那么 内存是极其重要的。那么上面的 sds 从内存上考虑有什么问题吗?

表示长度和剩余长度的 len / free, 用的是 int 修饰的, 最大值为 2147483647, 正常情况下字符串的长度会超过这个吗？ 应该不会, 那么是否可以
用 2 个字节的 uint16_t (Java 层面的 short, 最大值为 32768) 进行存储呢?

既然可以用 2 个字节, 那么 1 个字节呢, 不足一个字节的呢？

所以在 Redis 3.2 后, 对 sds 更进一步的细化, 分成了 5 种实现, 基于 1, 2, 4, 8 个字节的实现 + 基于 5 位的实现, 同时在结构体内追加了一个 1 个字节的 flags 表示这个结构体的类型

```c
struct __attribute__((__packed__))sdshdr8 {
    uint8_t len;
    uint8_t alloc;
    unsigned char flags;
    char buf[];
}

struct __attribute__((__packed__))sdshdr16 {

    uint16_t len;
    uint16_t alloc;
    unsigned char flags;
    char buf[];

}

struct __attribute__((__packed__))sdshdr32 {

    uint32_t len;
    uint32_t alloc;
    unsigned char flags;
    char buf[];

}

struct __attribute__((__packed__))sdshdr64 {

    uint64_t len;
    uint64_t alloc;
    unsigned char flags;
    char buf[];

}

// 几乎不会使用到, 外部使用时, 即使一个很小的字符串也会先转换为 8 位存储
// 只在内部源码中别使用到
struct __attribute__((__packed__))sdshdr5 {

    /** flags 只有 5 种情况， 3 位存储够了 */
    /** 把长度和类型放在一起 */
    /** 低3位存储类型, 高5位存储长度 */
    unsigned char flags; 

    char buf[];
}
```

平时在使用字符串时, 字符串的长度一般会多长呢?  超过 32768 的可能大吗？


## String

embstr raw 本质就是 sds, 不同的是 sds 和 redisObject 内存的组织方式。


Redis k-v 中 同一个 k 对应着一个 value,



```java
typedef struct dictEntry {

    /** void 可以指向任何类型, 指向 k */
    void* key;

    union {
        /** uint64_t、int64_t 或 double 类型时，就不再需要额外的存储，这有利于减少内存碎片 */
        void *val;
        uint64_t u64;
        int64_t s64;
    } v;

    // 链往后继节点, 用于解决 hash 冲突
    struct dictEntry *next;
}
```

val 指向的是一个 redisObject 

```C
typedef struct redisObject {
    
    /** 数据类型: OBJ_STRING, OBJ_LIST, OBJ_HASH, OBJ_SET, OBJ_ZSET */
    unsigned type:4;

    /** 底层存储的数据结构编码 */
    unsigned encoding:4;

    /** 与内存回收有关, 对象最后一次被程序访问的时间或者被返回的次数等 */
    unsigned lru:LRU_BITS;

    /** 被引用的次数, 当 refcount 为 0 的时候, 表示该对象已经不被任何对象引用, 则可以进行垃圾回收了 */
    int refcount;

    /** 指向对象实际的数据结构, 也就是真正的值 */
    void *ptr;

} robj;
```

raw 和 embstr *prt 都是指向一个 sds.
所以在 embstr 和 raw 本质都是一个 sds.

那么 2 者之间的唯一的区别在于 redisObject 和 sds 这 2 个对象之间如何进行内存分配。

常用的内存分配器为 jemalloc、tcmalloc

这 2 个 的共同特点就是在进行内容分配时，都是按照 2 的 n 次方进行分配的, 既 2,4,8 的方式进行分配。

在对 value 进行分配时, 需要分配的有 2 个， redisObject + sds

从上面可以知道 一个 redisObject 最少需要  (4 + 4 + 24) + 4 + 8 = 16 个字节

而一个 sds 最少需要 3 个字节 (sds5 会被转换为 sds8 进行分配) 

那么需要分配一个 string 的 value 至少需要 19 个字节， 也就是需要分配 32 个字节, 如果存储的字符串再大一些， 那么就需要分配到 64 个字节等。
那么基于这个机制，将 redisObject 和 sds 在分配内存时，一起分配, 基于这种情况分配的 sds 就是 embstr, RedisObject和SDS 内存地址是连续的
那么 raw, 就是则是通过 2 次内存分配， redisobject 和 sds 之间的内存地址可能是不连续的。



embstr　形式，可以存储最大字符串长度是 44 字节

SDS 已经变大，取得大的连续内存得不偿失


if (len < 20 && string2l(char)) {

    

}



int embstr raw

int -> long

embstr raw 本质就是 sds, 不同的时， 在 Redis 声明 value 的对象时, value 对象 和 sds 之间一起分配内存的


https://blog.csdn.net/u013099854/article/details/115399466

https://www.cnblogs.com/sunchong/p/11924295.html
https://www.cnblogs.com/yinbiao/p/10740212.html





