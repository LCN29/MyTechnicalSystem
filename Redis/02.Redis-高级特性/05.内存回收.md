# 5 Redis - 内存回收

Reids 所有的数据都是存储在内存中的, 如果不进行任何的内存回收的话, 那么很容易就会出现内存爆满的情况。所以在某些情况下需要对占用的内存空间进行回收。  
Redis 中内存回收主要分为两类, 
> 一类是 key 过期,
> 一类是内存使用达到上限（max_memory） 触发内存淘汰。

## 5.1 过期策略

实现方式 2 种
> 1. 定时过期 (主动淘汰)
> 2. 惰性过期 (被动淘汰)

* 定时过期

每个设置过期时间的 key 都需要创建一个定时器, 到过期时间就会立即清除。该策略可以立即清除过期的数据, 对内存很友好。但是会占用大量的 CPU 资源去处理过期的数据, 从而影响缓存的响应时间和吞吐量。

* 惰性过期

只有当访问一个 key 时, 才会判断该 key 是否已过期, 过期则清除。该策略可以最大化地节省 CPU 资源, 却对内存非常不友好。极端情况可能出现大量的过期 key 没有再次被访问, 从而不会被清除, 占用大量内存。

比如 String 类型的数据, 
在读取时, 会调用 expireIfNeeded 就会去判断是否需要删除这个 key 等。  
在写入时, 但内存判断不够时, 会调用 activeExpireCycle 释放一部分内存。

* 定期过期

```C
typedef struct redisDb {

    /** 所有的键值对 */
    dict *dict;    

    /** 设置了过去时间的键值对 */
    dict *expires;

    ...

} redisDb;
```

每隔一定时间, 会扫描 expires 字典中一定数量的 key (采样), 并清除其中已过期的 key。 这个策略是前 2 种方式的一个折中。通过调整定时扫描的时间间隔和每次扫描的限定耗时, 可以在不同情况下使得 CPU 和内存资源达到最优的平衡效果。


## 5.2 淘汰策略

Redis 的内存淘汰策略, 是指当内存使用达到最大内存极限时, 需要使用淘汰算法来决定清理掉哪些数据, 以保证新数据的存入。


* Redis 最大内存设置

可以在配置文件 **redis.conf** 的 **maxmemory** 后面设置最大的内存容量, 单位字节。如果不设置获取设置为 0, 则在 64 位系统表示不设置内存大小, 32 位系统最大为 3G 内存。

同样的可以通过 **cofnig set maxmemory XXGB** 进行动态的设置

| 策略  | 含义   |
|:-:| :-:|
| noeviction  | 默认策略, 不会删除任何数据, 但是拒绝所有写入操作并返回客户端错误信息 (error)OOM command not allow when used memory。此时 Redis 只响应度操作。|
|volatile-lru|Least Recently Used, 最近最少使用。在所有设置了 expire 的 key 中删除最近最少使用的键值对, 即距离上次访问时间最久的。|
|allkeys-lru|Least Recently Used, 最近最少使用。在所有的 key 中删除最近最少使用的键值对, 即距离上次访问时间最久的。|
|volatile-lfu |Least Frequently Used, 最不经常使用。在所有设置了 expire 的 key 中删除最不经常使用用的键值对, 即访问次数最少的。|
|allkeys-lfu|Least Frequently Used, 最不经常使用。在所有的 key 中删除最不经常使用用的键值对, 即访问次数最少的。|
|volatile-random|在所有设置了 expire 的 key 中随机选择删除|
|allkeys-random| 在所有的 key 中随机选择删除|
|volatile-ttl|Time To Live, 存活时间。 在所有设置了 expire 的 key 中删除距离当前时间最近的键值对。|

volatile-lru, volatile-random, volatile-ttl, 在没有复核条件的 key 的情况下, 会按照 noeviction 的策略进行处理。

一般情况下, 建议使用 volatile-lru，在保证正常服务的情况下, 优先删除最近最少使用的 key。

## 5.3 LRU 淘汰原理