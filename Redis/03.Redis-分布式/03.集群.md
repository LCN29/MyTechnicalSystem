# 3 Redis - 集群 (Cluster)


## 3.1 数据分片的实现方式

> 1. 在客户端实现相关分片逻辑
> 2. 把分片的逻辑抽离出来, 做出一个代理的服务
> 3. 在服务端实现相关分片逻辑

### 3.1.1 在客户端实现相关分片逻辑

![Alt 'ClientShardingModel'](https://raw.githubusercontent.com/PictureRespository/Redis/main/picture/ClientShardingModel.png)

如图: 在客户端中通过分片逻辑, 路由到具体的 Redis 组中, 具体的代表有 Jedis。

使用 ShardedJedis 之类的客户端分片代码的优势是配置简单, 不依赖于其他中间件, 分区的逻辑可以自定义, 比较灵活。  
但是基于客户端的方案, 不能实现动态的服务增减, 每个客户端需要自行维护分片策略, 存在重复代码。


### 3.1.2. 将分片逻辑抽离为一个代理服务

![Alt 'ProxyServerModel'](https://raw.githubusercontent.com/PictureRespository/Redis/main/picture/ProxyServerModel.png)

如图: 客户连接到代理服务 (或代理服务的集群), 代理服务根据分片逻辑, 再路由到具体的 Redis 组。

典型的代理分区方案有 Twitter 开源的 Twemproxy 和国内的豌豆荚开源的 Codis

#### 3.1.2.1 Twemproxy

![Alt 'TwitterTwemproxyModel'](https://raw.githubusercontent.com/PictureRespository/Redis/main/picture/TwitterTwemproxyModel.png)

如图就是 TwemproxyModel 常用的架构图。

优点：比较稳定，可用性高。

缺点:
> 1. 出现故障不能自动转移, 架构复杂, 需要借助其他组件 (LVS/HAProxy + Keepalived) 实现 HA
> 2. 扩缩容需要修改配置, 不能实现平滑地扩缩容 (需要重新分布数据)

#### 3.1.2.2 Codis

![Alt 'CodisModel'](https://raw.githubusercontent.com/PictureRespository/Redis/main/picture/CodisModel.png)

如图就是 Codis 常用的架构图。

Codis 配置了 N 个槽, 槽的个数等于后面的 Redis 组的个数。Codis 对 key 进行 CRC32 运算, 得到一个 32 位的数字, 然后模以 N (槽的个数), 得到余数。  
这个余数就是对应的槽, 槽后面就是具体的 Redis 实例或 Redis 分组。  

Codis 的槽位映射关系是保存在 Proxy 中的。如果要解决单点的问题, Codis 也要做集群部署, 多个 Codis 节点之间通过一个 Coordinator (例如: ZooKeeper) 进行槽，实例之间的同步。