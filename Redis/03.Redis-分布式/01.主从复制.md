# 1 Redis - 主从复制

## 1.1 为什么需要集群

* 性能  
Redis 本身的 QPS 已经很高了, 但是如果在一些并发量非常高的情况下, 性能还是会受到影响。这个时候可以借助更多的 Redis 服务来协助工作

* 扩展  
因为 Redis 所有的数据都放在内存中, 如果数据量大, 很容易受到硬件的限制。升级硬件收效和成本比太低, 需要有一种横向扩展的方法

* 可用性  
如果只有一个 Redis 服务, 一旦服务宕机，那么所有的客户端都无法访问, 会对业务造成很大的影响。另一个, 如果硬件发生故障, 而单机的数据无法恢复的话, 带来的影响也是灾难性的。

## 1.2  Redis 主从复制 (replication)

将一台 Redis 服务器的数据, 复制到其他的 Redis 服务器。前者称为主节点 (master), 后者称为从节点 (slave)。  
数据的复制是单向的, 只能由主节点到从节点, 同时主节点以写为主 (可写也可以读), 从节点只能读不可写入。

### 1.2.1 主从复制的配置

假设
当前主节点为    192.168.0.1, 端口为 6379  
从节点 1 为     192.168.0.2, 端口为 6379  
从节点 2 为     192.168.0.3, 端口为 6379  

在 2 个从节点的 redis.conf 文件中追加 **slaveof 192.168.0.1 6379**
然后启动主节点, 在依次启动从节点, 这样一主两从的配置就完成了。

当然也可以不使用配置, 启动完成主节点好，在 2 个从节点启动的时候添加参数 **./redis-server --slaveof 192.168.0.1 6379**

从节点也可以使用 **slaveof no one** 脱离集群, 自身成为主节点。

最终可以通过 **info replication** 可以查看当前的集群信息

一主多从的特点:
> 1. 主节点挂了, 从节点依然还是从节点, 无法变为主节点
> 2. 主节点挂了, 重启后, 还是为主节点


### 1.2.2 主从复制流程

#### 1.2.2.1 连接阶段

**1. 保存主节点信息**

从节点服务器内部维护了两个字段, 即 masterhost 和 masterport 字段, 用于存储主节点的 ip 和 port 信息。

从节点启动时, 会将主节点的 ip 和 port 保存到下来。  
如果执行 slaveof 命令, 这是一个异步的命令, 会立即返回 OK, 然后后台将主节点的 ip 和 port 保存下来。


**2. 建立 socket 连接**

从节点内部有个定时任务 replicationCron (源码 replication.c), 每隔 1 秒钟检查是否有新的主节点要连接和复制, 如果发现, 就跟主节点建立 socket 网络连接, 如果连接成功了  

从节点: 为该 socket 建立一个专门处理复制工作的文件事件处理器, 负责后续的复制工作, 如接收 RDB 文件, 接收命令传播等  
主节点: 接收到从节点的 socket 连接后 (既 accept 之后), 为该 socket 创建相应的客户端状态, 并将从节点看做是连接到主节点的一个客户端，后面的步骤会以从节点向主节点发送命令请求的形式来进行

**3. 发送 ping 命令**

从节点成为主节点的客户端之后, 会先发送 ping 命令进行首次请求, 目的是: 检查 socket 连接是否可用, 以及主节点当前是否能够处理请求。

从节点发送 ping 命令后, 可能出现 3 种情况:
> 1. 返回 pong: 说明 socket 连接正常, 且主节点当前可以处理请求, 复制过程继续。
> 2. 超时: 一定时间后从节点仍未收到主节点的回复, 说明 socket 连接不可用, 则从节点断开 socket 连接, 并重连
> 3. 返回 pong 以外的结果: 如果主节点返回其他结果, 如正在处理超时运行的脚本, 说明主节点当前无法处理命令, 则从节点断开 socket 连接, 并重连。

**4. 身份验证**  
如果从节点中设置了 masterauth 选项, 则从节点需要向主节点进行身份验证, 没有设置该选项, 则不需要验证。  
从节点进行身份验证是通过向主节点发送 auth 命令进行的, auth 命令的参数即为配置文件中的 masterauth 的值。

如果主节点设置密码的状态, 与从节点 masterauth 的状态一致 (一致是指都存在，且密码相同，或者都不存在), 则身份验证通过, 复制过程继续, 如果不一致, 则从节点断开 socket 连接, 并重连。

**5. 发送从节点端口信息**

身份验证之后, 从节点会向主节点发送其监听的端口号, 主节点将该信息保存到该从节点对应的客户端的 slave_listening_port 字段中。
该端口信息除了在主节点中执行 info Replication 时显示以外, 没有其他作用

#### 1.2.2.2 数据同步阶段

主从节点之间的连接建立以后, 便可以开始进行数据同步, 该阶段可以理解为从节点数据的初始化。  
具体执行的方式是: 从节点向主节点发送 psync 命令 (Redis 2.8 以前是 sync 命令), 开始同步。

数据同步阶段是主从复制最核心的阶段, 根据主从节点当前状态的不同, 可以分为**全量复制**和**部分复制**。这里涉及的内容比较多, 下面介绍。

#### 1.2.2.3 命令传播阶段

数据同步阶段完成后, 主从节点进入命令传播阶段。  
在这个阶段主节点将自己执行的写命令发送给从节点, 从节点接收命令并执行, 从而保证主从节点数据的一致性。

在命令传播阶段, 除了发送写命令, 主从节点还维持着心跳机制： **PING** 和 **REPLCONF ACK**。 
由于心跳机制的原理涉及部分复制, 因此将在介绍了部分复制的相关内容后单独介绍该心跳机制。


**数据同步的延迟与不一致**  
命令传播是异步的过程, 即主节点发送写命令后并不会等待从节点的回复。 因此实际上主从节点之间很难保持实时的一致性, 延迟在所难免。数据不一致的程度, 与主从节点之间的网络状况, 主节点写命令的执行频率以及主节点中的 repl-disable-tcp-nodelay 配置等有关


**repl-disable-tcp-nodelay 配置作用**  
该配置作用于命令传播阶段, 控制主节点是否禁止与从节点的 TCP_NODELAY, 默认 no, 即不禁止 TCP_NODELAY。  
当设置为 yes 时, TCP 会对包进行合并从而减少带宽, 但是发送的频率会降低, 从节点数据延迟增加, 一致性变差。  
具体发送频率与 Linux 内核的配置有关, 默认配置为 40ms。当设置为 no 时, TCP 会立马将主节点的数据发送给从节点, 带宽增加但延迟变小。

一般来说, 只有当应用对 Redis 数据不一致的容忍度较高, 且主从节点之间网络状况不好时, 才会设置为 yes, 多数情况使用默认值 no。

### 1.2.2 数据同步阶段 - 数据复制模式

在 Redis 2.8 以前, 从节点向主节点发送 sync 命令请求同步数据, 此时的同步方式是全量复制。  
在 Redis 2.8 及以后, 从节点可以发送 psync 命令请求同步数据, 此时根据主从节点当前状态的不同, 同步方式可能是全量复制或部分复制。

> 1. 全量复制：用于初次复制或其他无法进行部分复制的情况, 将主节点中的所有数据都发送给从节点, 是一个非常重型的操作
> 2. 部分复制：用于网络中断等情况后的复制, 只将中断期间主节点执行的写命令发送给从节点, 与全量复制相比更加高效。需要注意的是, 如果网络中断时间过长, 导致主节点没有能够完整地保存中断期间执行的写命令, 则无法进行部分复制, 仍使用全量复制

#### 1.2.2.1 全量复制

Redis 通过 psync 命令进行全量复制的过程如下

1) 从节点判断无法进行部分复制, 向主节点发送全量复制的请求或从节点发送部分复制的请求, 但主节点判断无法进行部分复制 (具体的判断规则, 看部分复制部分)

2) 主节点收到全量复制的命令后, 执行 bgsave, 在后台生成 RDB 文件, 并使用一个缓冲区 (称为复制缓冲区) 记录从现在开始执行的所有写命令

3) 主节点的 bgsave 执行完成后, 将 RDB 文件发送给从节点 (如果超时了会重连, 可以调大 repl-timeout 的值)。从节点首先清除自己的旧数据, 然后载入接收的 RDB 文件, 将数据库状态更新至主节点执行 bgsave 时的数据库状态

4) 主节点将前述复制缓冲区中的所有写命令发送给从节点, 从节点执行这些写命令，将数据库状态更新至主节点的最新状态

5) 如果从节点开启了AOF, 则会触发 bgrewriteaof 的执行, 从而保证 AOF 文件更新至主节点的最新状态


从上面的步骤可以看出, 全量复制是一个很耗时的过程

> 1. 主节点通过 bgsave 命令 fork 子进程进行 RDB 持久化, 该过程是非常消耗 CPU, 内存(页表复制), 硬盘 IO 的
> 2. 主节点通过网络将 RDB 文件发送给从节点, 对主从节点的带宽都会带来很大的消耗
> 3. 从节点清空老数据, 载入新 RDB 文件的过程是阻塞的, 无法响应客户端的命令
> 4. 数据同步完成后, 从节点会执行 bgrewriteaof, 也会带来额外的消耗

#### 1.2.2.2 部分复制

部分复制的实现, 依赖于三个重要的概念

**1. 复制偏移量**


**2. 复制积压缓冲区**


**3. 服务器运行 ID (runid)**


## 参考
[深入学习Redis（3）：主从复制](https://www.cnblogs.com/kismetv/p/9236731.html)