# 2 AOF

AOF 全称: Append Only File, 是 Redis 提供了另一种数据保存模式,  Redis 默认不开启。  
AOF 采用日志的形式来记录每个写操作, 并追加到文件。开启后, 执行更改 Redis 数据的命令时, 就会把命令写入到 AOF 文件中。   
Redis 重启时会根据日志文件的内容把写指令从前到后执行一次以完成数据的恢复工作。

## 2.1 AOF 相关的配置

```sh
appendonly no                   # AOF 开关, 默认为关闭
appendfilename "appendonly.aof" # 保存的文件名
appendfsync everysec            # AOF 持久化策略 (硬盘缓存写入到硬盘) 
```

开启 AOF 后, 每天修改的命令都会存到 Redis 的一个缓存区。缓存区的数据最终是需要写入到磁盘的, 而系统层面提供的数据写入到磁盘的函数有 2 个 **write** 和 **fsync**。
> 1. write: write 会将数据先保存到系统层级的缓存, 后续由系统自身将数据保存到
> 2. fsync: 直接跳过系统缓存, 直接写入到磁盘中, 这是一个阻塞且缓慢的操作, 会影响到执行的线程。

所以上面的配置的第 3 项就是控制这个 Redis 缓存到磁盘的行为
> 1. everysec: AOF 默认的持久化策略。每秒执行一次 fsync, 可能导致丢失 1s 数据, 这种策略兼顾了安全性和效率
> 2. no: 表示不执行 fsync, 由操作系统保证数据同步到磁盘, 速度最快, 但是不太安全
> 3. always: 表示每次写入到执行 fsync, 保证数据同步到磁盘, 效率很低

除了上面的 3 个基础配置, 还有几个关于 AOF 执行中的行为配置

```sh
# 默认为 100
# 当目前 AOF 文件大小超过上次重写的 AOF 文件的百分之多少进行重写 (重写的含义可以看下面的重写机制), 即当 AOF 文件增长到一定大小的时候, Redis 能够调用 bgrewriteaof 对日志文件进行重写
auto-aof-rewrite-percentag  100

# 默认为 64m
# 设置允许重写的最小 AOF 文件大小, 避免达到约定百分比但占用的容量仍然很小的情况就重写
auto-aof-rewrite-min-size  64mb

# 默认为 no
# 在 AOF 重写时, 是否不要执行 fsync, 将缓存写入到磁盘, 默认为 no。
# 如果对低延迟要求很高的应用, 这里可以设置为 yes, 否则设置为 no, 这样对持久化特性来说这是更安全的选择
# 设置为 yes 表示 rewrite 期间对新写操作不 fsync, 暂时存在内存中, 等 rewrite 完成后再写入
# 默认为 no, 建议改为 yes, 因为 Linux 的默认 fsync 策略为 30 秒, 所以可能丢失 30 秒数据
no-appendfsync-on-rewrite  no

# 默认为 yes
# 当 Redis 启动的时候, AOF 文件的数据会被重新载入内存
# 但是 AOF 文件可能在尾部是不完整的, 比如突然的断电宕机什么的, 可能导致 AOF 文件数据不完整
# 对于不完整的 AOF 文件如何处理
# 配置为 yes, 当截断的 AOF 文件被导入的时候, 会自动发布一个 log 给客户端, 然后继续加载文件中的数据
# 配置为 no, 用户必须手动 redis-check-aof 修复 AOF 文件才可以
aof-load-truncated yes
```

## 2.2 AOF 重写机制

由于 AOF 持久化是 Redis 不断将写命令记录到 AOF 文件中, 随着 Redis 不断的运行, AOF 文件将会越来越大, 占用服务器磁盘越来越大, 同时 AOF 恢复要求时间越长。  

为了解决这个问题, Redis 新增了重写机制, 当 AOF 文件的大小超过了所设定的阈值时, Redis 就会自动启动 AOF 文件的内容压缩, 只保留可以恢复数据的最小指令集。   
AOF 文件不是对原文件进行整理, 而是直接读取服务器现有的键值对, 然后用一条命令去代替之前记录这个键值对的多条命令, 生成一个新的文件替换原来的 AOF 文件。  

可以通过 **bgrewriteaof** 命令来手动触发 AOF 文件的重写, 也是通过子进程实现的。  
在子进程进行 AOF 重写时, 主线程需要保证
> 1. 处理客户端的请求
> 2. 将新增和更新命令追加到现有的 AOF 文件中
> 3. 将新增和更新命令追加到 AOF 重写缓存中

## 2.4 AOF 文件的优势和劣势

优势  
> 1. AOF 持久化的方法提供了多种的同步频率, 即使使用默认的同步频率每秒同步一次, Redis 最多也就丢失 1 秒的数据而已
> 2. AOF 日志文件以 append-only 模式写入, 所以没有任何磁盘寻址的开销, 写入性能非常高, 而且文件不容易受损, 即使文件尾部受损, 也能很容易恢复, 打开文件, 把后面损坏的数据删除即可

劣势  
> 1. 对于具有相同数据的的 Redis, AOF 文件通常会比 RDF 文件体积更大 (RDB 存的是数据快照) 
> 2. 虽然 AOF 提供了多种同步的频率, 默认情况下, 每秒同步一次的频率也具有较高的性能。在高并发的情况下, RDB 比 AOF 具好更好的性能保证


## 2.5 AOF 的过程

> 1. 所有的修改命令会追加到 Redis 的一个 AOF 缓存区
> 2. AOF 缓存区根据配置的策略向硬盘做同步操作
> 3. 随着 AOF 文件越来越大, 达到配置的条件, 对 AOF 文件进行重写, 达到压缩的目的

## 2.6 AOF 和 RDB  两种方案比较

如果可以忍受一小段时间内数据的丢失, 使用 RDB 是最好的, 定时生成 RDB 快照 (snapshot) 非常便于进行数据库备份, 并且 RDB 恢复数据集的速度也要 比 AOF 恢复的速度要快。 否则使用 AOF 重写。  
但是一般情况下建议不要单独使用某一种持久化机制, 而是应该两种一起用, 在这种情况下, 当 Redis 重启的时候会优先载入 AOF 文件来恢复原始的数据, 因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集要完整。

在 Redis 4.0 带来了一个新的持久化选项 —— 混合持久化。将 RDB 文件的内容和增量的 AOF 日志文件存在一起。
这里的 AOF 日志不再是全量的日志, 而是自持久化开始到持久化结束的这段时间发生的增量 AOF 日志, 通常这部分 AOF 日志很小。

在 Redis 重启的时候, 可以先加载 RDB 的内容, 然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放, 重启效率因此大幅得到提升。

到此, AOF 的理论知识就没了, 下面是从源码进行分析。

## 2.7 AOF 文件结构

比如向 Redis 中写入一个 key 为 redis-key, value 为 redis-value 的字符串键值对后, 这对键值对在 AOF 文件的保存如下

```
*3\r\n$3\r\nset\r\n$9\r\nredis-key\r\n$11\r\nredis-value\r\n
```
以 `*数字` 的格式开始, 表示后面的命令的参数个数, 然后通过 `$数字` 表示后面参数的长度, 然后各个分隔之间通过 `\r\n` 进行分隔。  
Redis 中有多个数据库, 写入的数据是保存在哪个数据库的确定是会把 **select 数据库的编号** 这条命令也写入到文件中。

可以看到这种文本格式具有很高的可读性, 同时可以直接进行修改。

将 key 和 value 转换为上面的文件格式的实现是由 2 个函数实现的: catAppendOnlyGenericCommand 和 catAppendOnlyExpireAtCommand, 前者处理的是没有过期时间的键值对, 而后者处理的是带有过期时间的键值对。

### 2.7.1 catAppendOnlyGenericCommand 

```C
/**
 * @param dst 当前未写入到文件的命令文本, 新的命令会追加到这个的后面
 * @param argc 命令参数的个数
 * @param argv 命令参数
 */
sds catAppendOnlyGenericCommand(sds dst, int argc, robj **argv) {

    char buf[32];
    int len, j;
    robj *o;

    // 命令开始的前置为 *
    buf[0] = '*';
    // 计算出长度
    len = 1+ll2string(buf+1,sizeof(buf)-1,argc);
    // 追加 \r\n
    buf[len++] = '\r';
    buf[len++] = '\n';

    // 拼接到dst的后面
    dst = sdscatlen(dst,buf,len);

    // 拼接参数列表
    for (j = 0; j < argc; j++) {
        o = getDecodedObject(argv[j]);
        buf[0] = '$';
        len = 1+ll2string(buf+1,sizeof(buf)-1,sdslen(o->ptr));
        buf[len++] = '\r';
        buf[len++] = '\n';
        dst = sdscatlen(dst,buf,len);
        dst = sdscatlen(dst,o->ptr,sdslen(o->ptr));
        dst = sdscatlen(dst,"\r\n",2);
        decrRefCount(o);
    }
    return dst;
}
```

### 2.7.2 catAppendOnlyExpireAtCommand

```C
/**
 * @param buf 当前未写入到文件的命令文本, 新的命令会追加到这个的后面
 * @param cmd 执行的命令
 * @param key redis 的 key 值
 * @param second 
 */
sds catAppendOnlyExpireAtCommand(sds buf, struct redisCommand *cmd, robj *key, robj *seconds) {


}
```


## 1.5 代码实现



