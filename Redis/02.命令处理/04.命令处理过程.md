# 4 命令处理过程

整个命令处理的过程可以分为 3 步
> 1. 解析命令请求
> 2. 调用命令
> 3. 返回结果给客户端

整个过程都在 **readQueryFromClient** 整个函数中

## 4.1 解析命令请求

为了解决 TCP 的半包与粘包问题, Redis 采用自定义协议格式实现不同命令请求的区分。  

比如
```C
set redis-key value
```

客户端会将该命令请求转换为以下协议格式, 然后发送给服务器

```
*3\r\n$3\r\nset\r\n$9\r\nredis-key\r\n$5\r\nvalue\r\n
```

> 1. 以 `\r\n` 作为分隔符, 区分真正的内容
> 2. `*数字`表示当前的请求命令后多少个参数
> 3. `$数字`表示当前参数的字符串长度

Redis 还支持在 telnet 会话输入命令的方式，只是此时没有了请求协议中的 "*" 来声明参数的数量，因此必须使用空格来分隔各个参数, 服务器在接收到数据之后，会将空格作为参数分隔符解析命令请求。这种方式的命令请求称为**内联命令**。


```C
/**
 * 客户端请求处理, 代码有省略
 */ 
void readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask) {

    // 获取对应的客户端对象
    client *c = (client*) privdata;

    int nread, readlen;
    size_t qblen;

    // PROTO_IOBUF_LEN = 1024*16
    readlen = PROTO_IOBUF_LEN;

    // 获取缓冲区的长度
    qblen = sdslen(c->querybuf);

    // 缓存区扩容
    c->querybuf = sdsMakeRoomFor(c->querybuf, readlen);
    
    // 数据写入到 querybuf 中
    nread = read(fd, c->querybuf+qblen, readlen);
    // 更新长度
    sdsIncrLen(c->querybuf,nread);
    // 更新上次的修改时间为当前时间
    c->lastinteraction = server.unixtime;

    processInputBufferAndReplicate();
}

/**
 * 这是一个 processInputBuffer 的包装器, 这个方法也可以用来处理复制数据到从节点。
 * 通过这个方法防止客户端 c 被标记为主节点。
 * 通常是调用这个方法而不是直接调用 processInputBuffer
 *
 */
void processInputBufferAndReplicate(client *c) {

    // CLIENT_MASTER = 1, 主服务器标识
    // 客户端 flags 默认为 0
    if (!(c->flags & CLIENT_MASTER)) {

        processInputBuffer(c);
    } else {

        size_t prev_offset = c->reploff;
        processInputBuffer(c);
        size_t applied = c->reploff - prev_offset;
        if (applied) {
            replicationFeedSlavesFromMasterStream(server.slaves, c->pending_querybuf, applied);
            sdsrange(c->pending_querybuf,applied,-1);
        }
    }
}

void processInputBuffer(client *c) {

    /** 当输入缓冲区中有东西时继续处理 */
    while(c->qb_pos < sdslen(c->querybuf)) {

        ...

        /** 确保请求类型 */        
        if (!c->reqtype) {
            if (c->querybuf[c->qb_pos] == '*') {
                // multibulk 请求
                c->reqtype = PROTO_REQ_MULTIBULK;
            } else {
                // 内联请求
                c->reqtype = PROTO_REQ_INLINE;
            }
        }
        
        // 根据请求方式, 对参数进行解析
        // 内部都是对字符串的处理, 跳过
        if (c->reqtype == PROTO_REQ_INLINE) {
            // 内联请求
            if (processInlineBuffer(c) != C_OK) 
                break;
        } else if (c->reqtype == PROTO_REQ_MULTIBULK) {
            // multibulk 请求
            if (processMultibulkBuffer(c) != C_OK)
                break;
        } else {
            serverPanic("Unknown request type");
        }
    }
}
```

到此就是 Redis 命令处理过程的第一步: 解析命令请求.

Redis 服务器接收到的命令请求
> 1. 存储在客户端对象的 querybuf 输入缓冲区
> 2. 解析命令请求各个参数，并存储在客户端对象的 argv (参数对象数组) 和 argc (参数个数) 字段

## 4.2 调用命令

在第一步解析命令请求中 processInputBuffer 中, 对参数解析完成后， 会进入命令调用的执行, 步骤如下:

```C
void processInputBuffer(client *c) {

    ...

    while(c->qb_pos < sdslen(c->querybuf)) {

        ...
        // 省略上面的参数解析步骤

        // 解析后的参数为 0, 直接重置客户端端, 处理下一个命令
        if (c->argc == 0) {
            resetClient(c);
        } else {

            // 可以看出命令的执行是在 processCommand 中的, 又调用到 server.c 中的 processCommand 函数
            if (processCommand(c) == C_OK) {

                ...
                // 处理成功后的逻辑
            }

            if (server.current_client == NULL) 
                break;
        }

    }



}

int processCommand(client *c) {

    // module 执行命令过滤器, 不会影响到正常的命令
    moduleCallCommandFilters(c);

    // 命令是 quit, 设置返回结果为 ok, 然后
    if (!strcasecmp(c->argv[0]->ptr,"quit")) {

        // 向客户端的响应的 输出链表 reply 添加一个 ok 的节点
        addReply(c,shared.ok);
        // 设置客户端的 flags 为关闭状态
        c->flags |= CLIENT_CLOSE_AFTER_REPLY;
        return C_ERR;
    }

    // 通过 lookupCommand 从命令缓存字典中找到对应的 redisCommond 命令
    c->cmd = c->lastcmd = lookupCommand(c->argv[0]->ptr);

    if (!c->cmd) {

        // 命令失败执行的一个操作
        // 如果 客户端的 flag 包含了 CLIENT_MULTI, 向 flag 添加一个 CLIENT_DIRTY_EXEC, 用来让命令失败
        flagTransaction(c);

        ...

        addReplyErrorFormat(c,"unknown command `%s`, with args beginning with: %s", (char*)c->argv[0]->ptr, args);
        sdsfree(args);
        return C_OK;

    } else if ((c->cmd->arity > 0 && c->cmd->arity != c->argc) || (c->argc < -c->cmd->arity)) {
        // 命令需要参数， 但是现在命令需要的参数和命令的参数不一样
        // 命令需要的参数 > 命令的参数
        flagTransaction(c);
        addReplyErrorFormat(c,"wrong number of arguments for '%s' command", c->cmd->name);
        return C_OK;
    }

    if (server.requirepass && !c->authenticated && c->cmd->proc != authCommand) {
        flagTransaction(c);
        addReply(c,shared.noautherr);
        return C_OK;
    }


}

struct redisCommand *lookupCommand(sds name) {

    // 本质就是调用字典的 dictFind 中的对应的 key 对应的 value
    // 查找的字典为 server.commands 
    return dictFetchValue(server.commands, name);
}



```


