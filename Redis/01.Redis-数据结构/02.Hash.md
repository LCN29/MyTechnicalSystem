# 2 Redis-Hash

Redis 是一个 K-V 的数据存储系统, 通过 K 可以找到对应的 V。而 Hash 结构的话, 其 V 也是一个包含 K-V 的无序散列表。
在使用中, 可以通过 2 个 K 得到最终的 value (key - Field - Value)。 Hash 最终的这个 value 只能是字符串了, 不能是其他类型。而不像 Java 中的 Hash, 可以无限嵌套。

## 2.1 Hash 常用的一些命令

[Hash 常用命令](https://redis.io/commands#hash)

## 2.2 Hash 和 String 的区别
> 1. 可以把相关的值聚集到一个 key 中, 节省内存空间
> 2. 只使用一个 key, 减少 key 的冲突
> 3. 当需要批量获取值的时候, 只需要使用一个命令, 减少 内存 / IO / CPU 消耗

## 2.2 Hash 不适用的场景
> 1. 没法单独对 Field 设置过期时间, 设置过期时间的话, 所有的 Field 都会起作用
> 2. 没有 bit 操作
> 3. 数据分布不均匀 (value 值非常大的话, 无法分布到多个节点, Redis 的数据分布是通过 Key 实现)

## 2.3 Hash 的编码

Reids 中 Hash 类型的数据, 在实现上有 2 种 编码方式

> 1. ziplist (OBJ_ENCODING_ZIPLIST): 压缩列表
> 2. hashtable (OBJ_ENCODING_HT): 哈希表格

## 2.4 ziplist

首先看一下官方的介绍

```
The ziplist is a specially encoded dually linked list that is designed
to be very memory efficient. It stores both strings and integer values,
where integers are encoded as actual integers instead of a series of
characters. It allows push and pop operations on either side of the list
in O(1) time. However, because every operation requires a reallocation of
the memory used by the ziplist, the actual complexity is related to the
amount of memory used by the ziplist.

ziplist 是一个经过特殊编码的内存高效的双向链表。
它同时存储字符串和整数值，其中整数被编码为实际整数，而不是一系列字符。
它允许在 O(1) 时间内对列表的两边进行 push 和 pop 操作。
但是, 因为每个操作都需要重新分配 ziplist 所使用的内存, 所以实际的复杂性与 ziplist 所使用的内存数量有关。
```

ziplist 是一个双向链表。但是它不存储指向上一个链表节点和指向下一个链表节点的指针, 而是存储上一个节点长度和当前节点长度。
通过牺牲部分读写性能, 来换取高效的内存空间利用率, 是一种时间换空间的思想。

### 2.4.1 ziplist 的实现逻辑

在 Redis 中, ziplist 虽然是一个双向链表, 却是通过一个 **char[]** 数组实现的, 先后遍历时, 借助在存储数据时冗余的上一个节点长度和当前节点长度, 计算后得到上下节点的位置。
所以, 在 Reids 中, **ziplist == char[]**。

首先明确一点, 在 C 语言中, char 类型只占 8 位 (这个很重要, 因为下面的内容基本都是会涉及到很多的字节内容), 整个 char[] 数组会被按照下面的格式进行划分。

![Alt 'ZipListCharArrFormat'](https://raw.githubusercontent.com/PictureRespository/MiddleWare/main/Redis/ZipListCharArrFormat.png)


其中的 entry 就是存储数据的元素。

整个 char[] 数组的划分如下:  
> 1. 0 ~ 3 位, 4 个字节, 叫做 **zlbytes**, 表示当前整个 ziplist 的字节长度, 也就是整个数组的长度, 因此压缩列表最多有 2^32 - 1 个字节
> 2. 4 ~ 7 位, 4 个字节, 叫做 **zltail**, 表示当前 ziplist 的起始位置到最后一个 entry 元素的起始位置相差的字节数, 也就是 ziplist 的起始位置 + zltail = ziplist 最后一个 entry 的起始位置 (简单理解就是, 数组的第几位是最后一个 entry 的开始位置)  
> 3. 8 ~ 9 位, 2 个字节, 叫做 **zllen**, 表示当前整个 ziplist 中的 entry 个数, 也就是整个 ziplist 最多有 2^16 - 1 个 entry
> 4. 10 ~ n 位, 字节数不定, 就是真正存储数据的 entry 集合
> 5. 最后 1 位, 1 个字节, 叫做 **zlend**, 表示整个 ziplist 的结束位, 固定为 0xFF (255, 1111 1111), 也就是 


#### 2.4.1.1 entry 

整个 ziplist 的大体布局了解完了, 看一下存储数据的 entry, 整个 entry 的话分成了 3 部分

> 1. previous_entry_length: 当前 entry 的前一个 entry 的占的字节长度
> 2. encoding: 当前 entry 存储的数据内容是什么类型, 大体有 2 种：整数和字节数组 (也就是字符串)
> 3. content： 真正存储的内容的地方

**previous_entry_length**  

表示前一个 entry 的字节长度，会占 1 个或者 5 个字节, 占的字节数取决于上一个 entry 的的字节长度。  
当前一个 entry 的长度小于 254 字节时，用 1 个字节表示。  
当前一个 entry 的长度大于或等于 254 字节时，用 5 个字节来表示, 这 5 个字节中第一个固定为 0xFE (254, 1111 1110)

**encoding**  

当前 entry 的编码, 不同的编码，表示后面的 content 是不同的内容, 会占 1, 2 或者 5 个字节, 占的字节取决于存储在当前 entry 内的内容的格式

| encoding 占的字节数 | encoding 的二进制 | 二进制的前 2 位的 | 表示的内容 |
| :-: | :-: | :-:| :-:|
| 1 |  00 bbbbbb |  00 | 长度最大为 63 的字节数组,  encoding 后面的 6 位用来存储字节数组的长度 |
| 1 |  1100 0000 |  11 | int_16 的整数 | 
| 1 |  1101 0000 |   11 | int 32 的整数 |













