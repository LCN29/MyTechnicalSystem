## 零拷贝

零拷贝是指计算机执行 IO 操作时, CPU 不需要将数据从一个存储区域复制到另一个存储区域, 从而可以减少上下文切换以及CPU的拷贝时间。


### 用户态和内核态

用户态和内核态是操作系统中两种不同的运行级别。

用户态是指**应用程序**运行的状态, 具有较低的权限, 不能直接访问硬件资源。  
内核态是**操作系统内核**运行的状态, 具有最高的权限, 可以直接操作硬件资源。

用户态程序需要通过系统调用接口请求内核态服务, 从而实现对硬件资源的访问和管理。

### DMA

DMA (Direct Memory Access): 直接内存访问, 是一种计算机技术，允许外围设备（如硬盘驱动器、显卡、网络适配器等）直接访问系统内存，而不需要 CPU 的干预。  
减少 CPU 的参与, 提高数据传输的效率。

### 零拷贝技术的实现技术

现在常见的零拷贝技术有 2 种
> mmap
> sendFile
> 带有 DMA 收集拷贝功能的 sendfile


### 传统 IO 执行流程

![Alt '传统 IO 执行流程'](https://s21.ax1x.com/2025/01/06/pE9rgKJ.png)

* 用户应用进程, 发起 read 系统调用, 向系统发起 IO 请求 (第一次上下文切换:用户态->内核态)
* DMA 控制器将数据从硬件中读取到**内核缓冲区** (第一次拷贝: DMA 拷贝)
* CPU 把**内核缓冲区数据**原封不动地拷贝到**用户缓冲区**, read 系统调用结束 (第二次拷贝： CPU 拷贝, 第二次上下文切换: 内核态->用户态)
* 用户应用进程, 发起 write 系统调用, 向系统发起 IO 请求 (第三次上下文切换: 用户态->内核态)
* CPU 把**用户缓冲区数据**原封不动地拷贝到**内核缓冲区**(第四次拷贝: CPU 拷贝)
* DMA 控制器将数据从**内核缓冲区**拷贝到硬件中, write 系统调用结束 (第三次拷贝: DMA 拷贝, 第四次上下文切换: 内核态->用户态)

总结: 传统 IO 方式, 一共发生了 4 次上下文切换, 4 次数据的拷贝过程, 包括 2 次 DMA 拷贝和 2 次 CPU 拷贝。

### mmap 

![Alt 'MMap'](https://s21.ax1x.com/2025/01/06/pE9Dj9U.png)

![Alt 'mmap'](https://s21.ax1x.com/2025/01/06/pE9rqrd.png)

MMap 只需要三次拷贝和四次上下文切换，从而能够提升程序整体的执行效率，并且节省了程序的内存空间

一共发生了 4 次的上下文切换，3 次的 I/O 拷贝，包括 2 次 DMA 拷贝和 1 次的 I/O 拷贝，相比于传统 IO 减少了一次 I/O 拷贝


### senFile 方法

![Alt 'senFile 方法'](https://s21.ax1x.com/2025/01/06/pE9Dv3F.png)

![Alt 'senFile 方法'](https://s21.ax1x.com/2025/01/06/pE9rLqA.png)


1、发起 sendfile() 系统调用，操作系统由用户态空间切换到内核态空间（第一次上下文切换）
2、通过 DMA 引擎将数据从磁盘拷贝到内核态空间的输入的 socket 缓冲区中（第一次拷贝）
3、将数据从内核空间拷贝到与之关联的 socket 缓冲区（第二次拷贝）
4、将 socket 缓冲区的数据拷贝到协议引擎中（第三次拷贝）
5、sendfile() 系统调用结束，操作系统由用户态空间切换到内核态空间（第二次上下文切换）

一共有 2 次的上下文切换，3 次的 I/O 拷贝。我们看到从用户空间到内核空间并没有出现数据拷贝，从操作系统角度来看，这个就是零拷贝


sendfile 零拷贝消除了所有内核空间缓冲区与用户空间缓冲区之间的数据拷贝过程，因此 sendfile 零拷贝 I/O 的实现是完成在内核空间中完成的，这对于应用程序来说就无法对数据进行操作了。
减少了一次从内核空间到与之相关的 socket 缓冲区的数据拷贝


支持 scatter-gather 特性的 sendfile 数据零拷贝：
还可以减少一次内核态内部的 CPU 拷贝

![Alt 'sendfile+DMA scatter-gather'](https://s21.ax1x.com/2025/01/06/pE9rXVI.png)


| | CPU 拷贝（次数） | DMA 拷贝（次数） | 上下文切换（次数）|
| --- | --- | --- | --- |
| 传统 IO | 2 | 2 | 4 |
| MMap | 1 | 2 | 4 |
| sendFile | 1 | 2 | 2 |


* 在什么场景下使用 mmap() 去访问文件会更高效？

对文件执行随机访问时，如果使用 read() 或 write()，则意味着较低的 cache 命中率。这种情况下使用 mmap() 通常将更高效。
多个进程同时访问同一个文件时（无论是顺序访问还是随机访问），如果使用mmap()，那么操作系统缓冲区的文件内容可以在多个进程之间共享，从操作系统角度来看，使用 mmap() 可以大大节省内存。


* 什么场景下没有使用 mmap() 的必要？

访问小文件时，直接使用 read() 或 write() 将更加高效。
单个进程对文件执行顺序访问时 (sequential access)，使用 mmap() 几乎不会带来性能上的提升。譬如说，使用 read() 顺序读取文件时，文件系统会使用 read-ahead 的方式提前将文件内容缓存到文件系统的缓冲区，因此使用 read() 将很大程度上可以命中缓存。


https://heapdump.cn/article/3290793