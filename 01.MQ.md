

MQ 的选择




服务性能




存储


高可用


ActiveMq

支持 Java, 集群模式也还可以 
并发不行, 消息堆积, 阻塞, 延迟
存储支持 MySQL, 内存等

kafka

会丢失数据, 并且不支持事务
可能会重复消费数据, 消息会乱序
需要配合 zookeeper 进行元数据管理


RocketMq

商业版收费

事务


|      |   kafka        |   RocketMq   |   RabbitMq     |
| :-:  |   :-      |  :-  |  :- |
|  设计定位    |   系统间的数据流管道, 实时数据处理。  例如: 常规的消息系统, 网站活性跟踪, 监控数据, 日志收集处理等。 |    非日志的可靠消息传输。  例如: 订单, 交易, 流计算等。 |  可靠消息传输。 和 RocketMq 类似。|
| 成熟度 |   日志领域成熟    | 成熟  | 成熟   |
| 所属社区/公司  | Apache  | Alibaba 开发, 已加入 Apache |  Mozilla Public License |
| 社区活跃度 | 高  |   中  |  高|
| API 完备度 | 高|  高| 高|
| 文档完备性 | 高| 高 | 高|
| 开发语言 |  Scala | Java | Erlang|
| 支持协议 | 一套自行设计的基于 TCP 的二进制协议| 自定义协议 (社区版提供 JMS 协议, 但不成熟) | AMQP |
| 客户端语言 | C/C++, Python, Go, Erlang, Java 等  | Java (高版本开始支持其他语言 ) | Java, C/C++, Python 等   |
| 持久化方式 | 磁盘文件| 磁盘文件 | 内存, 磁盘文件 |
| 部署方式 |  单机/集群 |  单机/集群  |   单机/集群  |
| 集群管理方式  | ZooKeeper | name server|   |
| 选主模式 | 从 ISP 中自动选取一个 leader |||
| 可用性 | 非常高, 分布式 + 主从 | 非常高 分布式 + 主从   | 高, 主从, 采用镜像模式实现, 数据量大时可能产生性能瓶颈 |
| 主从切换 | 自动切换, N 个副本, 允许 N - 1 个失败； 主节点失效后自动从从节点中选择一个为主节点。 | 不支持自动切换。 主节点失效后不能向主节点发送信息, Consumer 大概 30s (默认) 可以感知此事, 此后变为从节点消费; 如果主节点无法恢复, 异步复制是可能出现部分信息丢失。   | 自动切换。 最早加入集群的从节点升级为主节点, 因为新加入的从节点不会同步主节点之前的数据, 所以可能会出现部分数据丢失。 |
| 数据可靠性 | 很好。 支持 producer 单条发送、同步刷盘、同步复制、单这场景下性能明显下降。 |很好。 支持 producer 单条发送, broker 端支持同步刷盘、异步刷盘、同步双写, 异步复制。| 好。 producer 支持同步/异步 ack, 支持队列数据持久化, 镜像模式中支持主从同步|
|消息写入性能| 非常好。 每条 10 字节测试: 百万条 /s | 很好。每条 10 字节测试: 单机单 broker 约 7w/s, 单机 3 个 broker 约 12w/s| RAM 约为 RockeetMq 的 1/2, Disk 的性能约为 RAM 性能的 1/3  |
|性能的稳定性 | 队列/分区多时性能不稳定, 明显下降。消息堆积时性能稳定。 | 队列较多, 消息堆积时性能稳定 | 消息堆积时, 性能不稳定, 明显下降|
| 单机支持的队列数 | 单机超过 64 个队列/分区, Load 会发生明显的飙高, 队列越多, load越高, 发送消息响应时间变长 | 单机支持最高 5 万个队列, Load 不会发生明显变化 | 依赖于内存|
| 堆积能力 | 非常好。 消息存储在 log 中, 每个分区一个 log 文件 | 非常好。 所有的消息存储在同一个 commit log 中 | 一般。 生产者、消费者正常是, 性能表现稳定, 消费者不消费或消费缓慢时, 性能不稳定  | 
| 复制备份 | 消息先希尔 leader 的 log, followers 从 leader 中 pull 到数据以后先 ack leader, 然后写入 log 中。 ISR 中维护与 leader 同步的列表, 落后太多的 follwers 被删除 | 同步双写。  异步复制: slave 自动线程从 master 中拉数据 | 普通模式下不复制。 镜像模式下, 消息先到 master, 入集群之前的消息不会被复制到新的 slave 上。 |
|消息投递实时性 | 毫秒级。 具体有 consumer 轮询间隔时间决定 | 毫秒级 支持 pull、push 2种模式, 延时通常在毫秒级 | 毫秒级 |
|顺序消费 | 支持顺序消费, 但是一套 Broker 宕机后, 就会产生消息乱序  | 支持顺序消费。在顺序消息场景下, 消费失败时消费队列将会暂停 | 支持顺序消费。 但是如果一个消费失败, 此消息的顺序会被打乱|
|定时消息 | 不支持 | 开源版本仅支持定时 Level |本身不支持, 但是可以通过插件形式支持  |
| 事务消息 | 不支持 | 支持 | 支持|
|Broker 端消息过滤| 不支持 | 支持。 通过 tag 过滤, 类似于子 topic | 不支持|
|消息查询| 不支持 | 支持。根据 MessageId 查询, 支持根据 MessageKey 查询消息 | 不支持|
|消费失败重试| 不支持失败重试, offset 存储在 consumer 中, 无法保证。 0.8.2 版本后支持将 offset 存储在 zk 中  | 支持失败重试, offset 存储在 broker 中 | 支持失败重试 |
| 消息重新消费 | 支持通过修改 offset 来重新消费 | 支持安装时间来重新消费  | 支持|
| 发送端赋值均衡| 可自由指定 | 可自由指定| 需要单独 loadlancer 支持 |
|消费并行度 | 消费并行度和分区数一致  | 顺序消费: 消费并行度和分区数一致。 乱序消费: 消费服务器和消费线程数之和 | 镜像模式下其实也是从 master 消费|
| 批量发送 | 支持。 默认 producer 缓存、压缩, 然后批量发送 | 不支持  | 不支持 |
|访问权限控制| 无 | 无 | 类似数据库一样, 需要配置用户名和密码|
|系统维护| Scala 语言开发, 维护成本高 | Java 语言开发, 维护成本低 | Erlang 语言开发, 维护成本高|
| 部署依赖  | ZooKeeper | nameserver | Erlang 环境 |
|管理后台 | 官网不提供, 第三方开源管理工具可供使用, 不用重新开发  | 官方提供, rocketmq-console | 官方提供 rabbitmq-admin |
| 优点 | (1)高吞吐、低延迟、高可用、集群热扩展 (2) producer 端提供缓存、压缩功能, 可节省西能、提高消息 (3) 生态完善, 在大数据处理方面有大佬配套的设施 | (1) 吞吐、低延迟、高可用, 消息堆积性能也很好 (2) api、系统设计适合在业务处理的场景 (3) 支持多种消费方式, 事务, 消息过滤 | (1) 高吞吐、高可用上较前两者有所不如 (2)支持多种客户端语言, 支持 amqp 协议 (3) 由于 erlang 语言特性, 性能可用, 使用 RAM 模式时, 性能好 (4) 管理界面丰富 |
| 缺点 | (1) 消费集群数目受到分区数目的限制 (2)单机 topic 多时, 性能会明显降低 (3) 不止事务 || (1) 相对于 kafka, 使用者少, 生态不够完善, 消费堆积、吞吐率也有所不如 (2) 不支持主从自动切换, master 实现后, 消费者需要一定的时间才能感知 | (1) Erlang 语言难度较大, 集群不支持动态扩展 (2) 消息吞吐能力有限 (3) 消息堆积时, 性能会明显降低|
