# ES 

## 入门

非结构化数据搜索
> 顺序扫描
> 全文检索

### 全文检索

一种用于在 大规模文本数据集中 进行 关键词搜索和匹配 的技术。

步骤
> 文本数据被分解为单词或词组 (这些单词或词组被称为 "词项"(terms)), 并保存该单词在文本中的位置、以及出现的次数 (保存了词项和文档的映射)
> 根据用户提供的关键词，在索引中查找匹配的词项，并返回相应的文档列表 

搜索原理简单概括的话可以分为这么几步
> 内容爬取，停顿词过滤比如一些无用的像"的"，“了”之类的语气词/连接词
> 内容分词，提取关键词
> 根据关键词建立倒排索引
> 用户输入关键词进行搜索

### 倒排索引
文档集合中的**每个词项**都会被映射到包含该词项的文档列表。这意味着对于每个词项，都会记录下包含该词项的文档的引用或位置信息。

倒排索引通常包含以下主要部分
> 词项（Terms）：文本数据中的单词或词组
> 文档列表（Document List）：包含每个词项所出现的文档的列表，通常使用文档标识符（如文档ID）来表示
> 位置信息（Positional Information）：可选的部分，记录了词项在文档中的具体位置，用于支持短语查询等高级搜索功能

查找顺序 词项 -> 文档列表 --> 文档 

非聚簇索引查询 --> 
区别: 但是倒排索引也会对搜索关键字分词

### 正排索引

正排索引通常包含以下主要部分
> 文档标识符（Document Identifier）：用于唯一标识每个文档
> 词项列表（Term List）：包含每个文档中出现的词项

查找顺序 文档标识符 -> 文档

主键 id 查询

### ES

Elasticsearch 与 Lucene 核心库竞争的优势在于： 
> 完美封装了 Lucene 核心库，设计了友好的 Restful-API，开发者无需过多关注底层机制，直接开箱即用。
> 分片与副本机制，直接解决了集群下性能与高可用问题。

#### 集群架构

ES Server 进程 (一个进程就是一个节点) (  主从架构, 基于 raft 协议 (奇数节点)  )
数据存放在分片 --> 一个分片对应着一个 Lucene 实例。

分片和副本数不是跟着节点数来得, 1 个 ES节点可以有多个lucene实例, 即 一个 ES 节点可以指定一个索引的多个分片。

举例:
一个集群, 有 3 个节点, 1 主 2 从.
现在有一个索引, 主分片数为 3, 副本分片数为 1, (意思是这个索引的数据会被分成 3 份存储, 每份存储都会有 1 个副本)
那么主分片会分配在每个节点上，而对应的副本会分配在另外 2 个节点中的一个，不会主副分片都在同一个节点上。
这样一个节点上就会有多个分片数据。
极端上，假设现在我一个索引主分片有 4 个，那么就会有一个节点有 2 个主分片，即 2 个 Lucene 实例。


#### Solar 的比较

当单纯的对已有数据进行搜索时，Solr更快。但实时建立索引时, Solr会产生io阻塞，查询性能较差, Elasticsearch具有明显的优势。
Solr 利用 Zookeeper 进行分布式管理，而Elasticsearch 自身带有分布式协调管理功能。
Solr 在传统的搜索应用中表现好于 Elasticsearch，但在处理实时搜索应用时效率明显低于 Elasticsearch
Solr 支持更多格式的数据，比如JSON、XML、CSV，而 Elasticsearch 仅支持json文件格式

#### Elastic Stack生态圈
Elasticsearch，Logstash，Kibana

Elasticsearch 数据存储
Kibana 可视化界面
Logstash 数据抓取清洗，比较重， 单纯抓取日志的化可以用 beats.

日志指标

Java 应用  -> beats 抓取 --> kafka/ Redis (缓冲, 抓取快但是消费慢) --> Logstash 消费写入 --> Elasticsearch <-- kibana 查询
